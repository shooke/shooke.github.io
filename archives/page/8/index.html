<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="python,php,mysql,前端">
  
  
  <title>
    Archives |
    
    舒克的博客
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title">Archives</h1>
    
  
  
  
  
  
  
  <div class="archives-wrap">
    <div class="archive-year-wrap">
      <a href="/archives/2019" class="archive-year">2019</a>
    </div>
    <div class="archives">
      
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/04/11/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ecs%E4%B8%BB%E6%9C%BA%E6%89%93%E9%80%A0shadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/">使用阿里云ecs主机打造shadowsocks服务器,实现科学上网</a>
  </h2>
  
  

      <a href="/2019/04/11/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ecs%E4%B8%BB%E6%9C%BA%E6%89%93%E9%80%A0shadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" class="archive-article-date">
  <time datetime="2019-04-11T07:10:46.000Z" itemprop="datePublished">04/11</time>
</a>
    </header>
    
      <p>要想打造一台自己的ss(shadowsocks)或ssr（shadowsocksR）服务器。要具备一下条件：</p>
<ol>
<li>要有一台自己的服务器vps或ecs云主机都可以，虚拟主机是不行滴</li>
<li>服务器一定要在海外或中国香港。推荐日、韩、香港、新加坡服务器<br>下面已阿里ecs为实例说明，主要是ecs降价了<code>366/年</code>的价格速度很快。比网上说的搬瓦工、Vultr强多了。</li>
</ol>
    
    
    
  </div>

</article>
      
  
  
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/04/03/linux%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83/">linux安装java环境</a>
  </h2>
  
  

      <a href="/2019/04/03/linux%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83/" class="archive-article-date">
  <time datetime="2019-04-03T07:04:54.000Z" itemprop="datePublished">04/03</time>
</a>
    </header>
    
      
    
    
    
  </div>

</article>
      
  
  
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/04/02/VirtualBox-v5-2-12-Ubuntu18-04-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E4%BA%92%E9%80%9A%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%B8%8A%E7%BD%91%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/">VirtualBox v5.2.12 Ubuntu18.04 宿主机和虚拟主机互通，都可上网配置方式</a>
  </h2>
  
  

      <a href="/2019/04/02/VirtualBox-v5-2-12-Ubuntu18-04-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E4%BA%92%E9%80%9A%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%B8%8A%E7%BD%91%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/" class="archive-article-date">
  <time datetime="2019-04-02T05:29:28.000Z" itemprop="datePublished">04/02</time>
</a>
    </header>
    
      <h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><p>点击管理，全局设置；<br>选择网络，里面只有 NAT 网络；<br>点击添加，列表新增 NatNetwork，点击确定。</p>
<h2 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h2><p>点击管理，选择主机网络管理；<br>选择创建，列表新增 vboxnet0，只要这一个就够了；<br>选中点击 vboxnet0，点击手动配置网卡；<br>点击 IPv4 地址，输入配置的网关 IP，如：192.168.56.1；<br>如果不想使用 DHCP，取消启用 DHCP，点击应用。</p>
<h2 id="给虚拟机添加网卡"><a href="#给虚拟机添加网卡" class="headerlink" title="给虚拟机添加网卡"></a>给虚拟机添加网卡</h2><p>右键点击一个虚拟主机，选择设置；<br>选择网络；<br>选中点击网卡 1，勾选启用网络连接；<br>连接方式选择网络地址转换(NAT)，界面可以空着；<br>选中点击网卡 2，勾选启用网络连接；<br>连接方式选择仅主机(Host-Only)网络，界面名称为 vboxnet0，点击确认。</p>
    
    
    
  </div>

</article>
      
  
  
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E5%A4%A7%E7%99%BD%E8%AF%9D/">设计模式基本原则大白话</a>
  </h2>
  
  

      <a href="/2019/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E5%A4%A7%E7%99%BD%E8%AF%9D/" class="archive-article-date">
  <time datetime="2019-04-01T14:35:47.000Z" itemprop="datePublished">04/01</time>
</a>
    </header>
    
      <h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>   简单点说就是最小化封装，一个方法只负责一个功能，一个类只负责一类功能。如果一个功能比较复杂，那就差分成多个小功能，然后去实现。<br>   这样做的好处是</p>
<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>   简单点说就是子类可以扩展父类的功能，但不能改变父类原有的功能。<br>   注意一下几点即可</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<p>这样做可以有效避免，功能耦合度太高，改一个小功能影响到其他功能的情况</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>   依赖倒置就是控制翻转，又名 IOC，简单点说，就是将需要的外部对象，通过构造函数参数传递或属性赋值的方式，让当前对象可以使用注入的外部对象。<br>   注意一下几点即可</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则</li>
</ul>
<p>这样做可以有效解耦，功能发生改变时，只需要替换外部的依赖对象，而不必修改主体功能代码。</p>
    
    
    
  </div>

</article>
      
  
  
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/03/27/vscode-%E4%BF%9D%E5%AD%98%E8%87%AA%E5%8A%A8%E6%8C%89eslint%E6%A0%BC%E5%BC%8F%E5%8C%96/">vscode 保存自动按eslint格式化</a>
  </h2>
  
  

      <a href="/2019/03/27/vscode-%E4%BF%9D%E5%AD%98%E8%87%AA%E5%8A%A8%E6%8C%89eslint%E6%A0%BC%E5%BC%8F%E5%8C%96/" class="archive-article-date">
  <time datetime="2019-03-27T06:26:43.000Z" itemprop="datePublished">03/27</time>
</a>
    </header>
    
      <p>三步走：</p>
<ol>
<li>安装 vuter，eslint，Prettier-code fromatter<br>vuter 是 vue 高高亮插件，安装后 vscode 就可以识别<code>.vue</code>文件了</li>
<li>配置 vscode 首选项<br>选择 file 》Preferences 》Settings 打开配置。然后选择 User Settings，点击右上角的<code>&#123;&#125;</code>按钮，进入文本编辑状态</li>
<li>配置内容</li>
</ol>
    
    
    
  </div>

</article>
      
  
  
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/03/15/elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E9%9B%86%E7%BE%A4%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/">elasticsearch学习笔记 - 集群相关术语</a>
  </h2>
  
  

      <a href="/2019/03/15/elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E9%9B%86%E7%BE%A4%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/" class="archive-article-date">
  <time datetime="2019-03-15T01:33:28.000Z" itemprop="datePublished">03/15</time>
</a>
    </header>
    
      <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>Cluster：集群。<br>顾名思义就是好多es服务器，拜了把子成了兄弟，在一起搞事情，他们讲义气不背叛，一个有难八方支援。比如你有8台服务器，其中一台挂了，剩余的兄弟会立刻顶上。客户让然可以正常使用你的服务，从而实现<code>高可用性</code>。</p>
</li>
<li><p>Node：节点。<br>集群中的每台服务器称之为一个节点。每个节点都是一个兄弟。既然拜了把子，那就有个长幼顺序（节点类型），这个看下面的节点类型小节，先看分片。</p>
</li>
<li><p>Shard：分片。<br>一只烤全羊，一个人肯定吃不了，怎么办呢？大家分着吃啊。所以就有了分片，大量的数据汇聚过来，一个节点可能由于内存或磁盘处理能力不足，那就把数据切成一小块一小块的（这就是分片），好几个兄弟一起处理。每个分片放到不同的服务器上。 这样处理起来就快了。<br>有肉一起吃，敌人来了当然也要一起扛。当有查询过来的时候，ES会把查询发送给每个相关的分片，并将结果组合在一起，然后返回给用户。</p>
</li>
<li><p>Replia：副本。<br>分着吃羊肉，羊是吃完了，但每个人分到的不一样啊，有人吃羊腿，有人吃羊尾巴，显然这样长期下去也是不行的。怎么办呢，再来一只，吃羊腿的再吃羊尾巴，吃羊尾巴的再吃羊腿，这样就公平了。每个人都能说出整只羊各个部位是什么味道。<br>同样的道理，数据分片，放在了不同的节点上，如果一台服务器挂掉了，那岂不是数据就丢失了，这种事是不允许发生的，因此就有了副本。每个切片复制一份，发送给其他节点。这样保证每个节点有完整的数据。集群中有一台宕机了也不影响使用。</p>
</li>
</ol>
    
    
    
  </div>

</article>
      
  
  
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/03/14/elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%AE%89%E8%A3%85/">elasticsearch学习笔记 - 安装</a>
  </h2>
  
  

      <a href="/2019/03/14/elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%AE%89%E8%A3%85/" class="archive-article-date">
  <time datetime="2019-03-14T05:30:16.000Z" itemprop="datePublished">03/14</time>
</a>
    </header>
    
      <p>最近用到了es，于是从网上找资料，但是好多都过时了，比如type在elasticsearch 6.0开始已经不推荐使用了。联合查询6.x使用的是join类型的字段，也不在支持type之间的联合查询。问什么要取消type呢？官方给出的理由是</p>
<blockquote>
<p>①，而在我们elasticsearch中同一 Index 下，同名 Field 类型必须相同，即使不同的 Type；<br>②， 同一 Index 下，TypeA 的 Field 会占用 TypeB 的资源（互相消耗资源），会形成一种稀疏存储的情况。尤其是 doc value ，为什么这么说呢？doc value为了性能考虑会保留一部分的磁盘空间，这意味着 TypeB 可能不需要这个字段的 doc_value 而 TypeA 需要，那么 TypeB 就被白白占用了一部分没有半点用处的资源；<br>③，Score 评分机制是 index-wide 的，不同的type之间评分也会造成干扰。<br>④，索引元数据本身是放在主节点中维护的，CP 设计。意味着涉及到大量字段变更及元数据变更的操作，都会导致该 Index 被堵塞或假死。我们应该对这样的 Index 做隔离，避免影响到其他 Index 正常的增删改查。甚至当涉及到字段变更十分频繁且无法预定义 schema 的场景时，是否要使用 ES 都应该慎思熟虑了！</p>
</blockquote>
<p>出现这种情况主要是在elasticsearch早期时候提出的一些概念，当时为了便于推广，跟关系型数据库作了如下比喻：</p>
<table>
<thead>
<tr>
<th>myql</th>
<th>elasticsearch</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>index</td>
</tr>
<tr>
<td>table</td>
<td>type</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
</tr>
</tbody></table>
<p>很多学习elasticsearch的人估计都看过这个比喻，但其实这是错误的。elasticsearch是基于 Lucene开发的，而在 Lucene中是没有table概念的，有的只是文档和字段。</p>
    
    
    
  </div>

</article>
      
  
  
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/03/13/linux%E4%BD%BF%E7%94%A8apt%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85mysql5-7/">linux使用apt方式安装mysql5.7</a>
  </h2>
  
  

      <a href="/2019/03/13/linux%E4%BD%BF%E7%94%A8apt%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85mysql5-7/" class="archive-article-date">
  <time datetime="2019-03-13T15:13:33.000Z" itemprop="datePublished">03/13</time>
</a>
    </header>
    
      <p>安装3步曲：</p>
<ol>
<li>使用apt-get安装</li>
<li>设置root密码和验证方式</li>
<li>重启服务</li>
</ol>
    
    
    
  </div>

</article>
      
  
  
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/03/06/python%E5%AD%97%E8%8A%82%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/">python字节和字符串相互转换</a>
  </h2>
  
  

      <a href="/2019/03/06/python%E5%AD%97%E8%8A%82%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/" class="archive-article-date">
  <time datetime="2019-03-06T09:43:39.000Z" itemprop="datePublished">03/06</time>
</a>
    </header>
    
      
    
    
    
  </div>

</article>
      
  
  
      <article class="archive-article archive-type-post">
  
  
  <div class="archive-article-inner">
    <header class="archive-article-header">
      
  
  <h2 class="archive-article-title" itemprop="name">
    <a href="/2019/03/06/nohup%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E/">nohup命令说明</a>
  </h2>
  
  

      <a href="/2019/03/06/nohup%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E/" class="archive-article-date">
  <time datetime="2019-03-06T09:21:00.000Z" itemprop="datePublished">03/06</time>
</a>
    </header>
    
      <p>nohup是Linux的一个常用命令，当你想要在退出账户或者关闭终端后进程仍在运行时，就可以使用nohup命令。nohup就是不挂断的意思（no hang up）。</p>
<p>nohup的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup command &gt;&gt; file 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>如果不将 nohup 命令的输出重定向，输出将附加到当前目录的 nohup.out 文件中，否则就是自己指定的文件。</p>
    
    
    
  </div>

</article>
      
      
    </div>
  </div>
  
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/archives/page/7/">Prev</a><a class="page-number" href="/archives/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/page/6/">6</a><a class="page-number" href="/archives/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/archives/page/9/">9</a><a class="extend next" rel="next" href="/archives/page/9/">Next</a>
  </nav>
  
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>舒克的博客 &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="舒克的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>