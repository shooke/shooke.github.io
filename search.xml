<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>deepin编译安装nginx问题总结.md</title>
    <url>/2020/10/08/2020/deepin%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="c-compiler-cc-is-not-found"><a href="#c-compiler-cc-is-not-found" class="headerlink" title="c compiler cc is not found"></a>c compiler cc is not found</h2><p>检查是否一安装gcc如果没有，执行<code>apt install gcc</code>进行安装<br>如果已经安装了gcc，但还是包错误，就需要执行<code>apt install build-essential</code></p>
<span id="more"></span>

<h2 id="configure-error-the-HTTP-rewrite-module-requires-the-PCRE-library"><a href="#configure-error-the-HTTP-rewrite-module-requires-the-PCRE-library" class="headerlink" title=".&#x2F;configure: error: the HTTP rewrite module requires the PCRE library"></a>.&#x2F;configure: error: the HTTP rewrite module requires the PCRE library</h2><p>遇到这个问题只需要安装pcre就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure>

<h2 id="configure-error-the-HTTP-gzip-module-requires-the-zlib-library"><a href="#configure-error-the-HTTP-gzip-module-requires-the-zlib-library" class="headerlink" title=".&#x2F;configure: error: the HTTP gzip module requires the zlib library"></a>.&#x2F;configure: error: the HTTP gzip module requires the zlib library</h2><p>说明缺少zlib，执行下面的命令安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install zlib1g-dev</span><br></pre></td></tr></table></figure>

<p>另外openssl也是常用的所以最好也安装一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install openssl libssl-dev</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编译nginx之前先做好准备工作,这样就可以安心编译了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install make gcc libpcre3 libpcre3-dev  zlib1g-dev openssl libssl-dev</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox网络模式说明</title>
    <url>/2020/12/07/2020/Virtualbox%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h2><p>VirtualBox的提供了四种网络接入模式，它们分别是：<br>1、NAT 网络地址转换模式(NAT,Network Address Translation)<br>2、Bridged Adapter 桥接模式<br>3、Internal 内部网络模式<br>4、Host-only Adapter 主机模式 </p>
<span id="more"></span>

<h2 id="不同模式的功能"><a href="#不同模式的功能" class="headerlink" title="不同模式的功能"></a>不同模式的功能</h2><h3 id="NAT-网络地址转换模式"><a href="#NAT-网络地址转换模式" class="headerlink" title="NAT 网络地址转换模式"></a>NAT 网络地址转换模式</h3><p>主要用于虚拟机访问外部网络。虚拟机可以访问宿主机，也可以访问外部网络的其他主机。<br>但是，这种模式下虚拟机对外是不可见的。任何主机都无法访问虚拟机，包括宿主机。<br>虚拟机就像一个幕后大佬，只有他看到你，你看不到他。</p>
<h3 id="Bridged-Adapter（网桥模式）"><a href="#Bridged-Adapter（网桥模式）" class="headerlink" title="Bridged Adapter（网桥模式）"></a>Bridged Adapter（网桥模式）</h3><p>这是一种最open的方式，它是通过主机网卡，架设了一条桥，直接连入到网络中了。因此，它使得虚拟机能被分配到一个网络中独立的IP，所有网络功能完全和在网络中的真实机器一样。<br>这种模式让虚拟机对外可见，虚拟机可以访问任何主机，其他主机也可以访问虚拟机。由于虚拟主机可见了，虚拟主机之间也可以相互访问。</p>
<h3 id="Internal（内网模式）"><a href="#Internal（内网模式）" class="headerlink" title="Internal（内网模式）"></a>Internal（内网模式）</h3><p>这是一种只有虚拟机之间通讯的模式，虚拟机不能访问宿主机，也不能访问外网。宿主机也无法访问虚拟机。<br>当你启动多个虚拟机，并且设置为同一网段时，虚拟机之间可以相互通讯。</p>
<h3 id="Host-only-Adapter（主机模式）"><a href="#Host-only-Adapter（主机模式）" class="headerlink" title="Host-only Adapter（主机模式）"></a>Host-only Adapter（主机模式）</h3><p>高级diy模式，默认情况下与<code>Internal（内网模式）</code>有点相似，虚拟主机之间可以通讯，不同支出在于，它不限制网段。虚拟机无需设置为同一个网段，即可相互通讯。<br>主机模式，这是一种比较复杂的模式，需要有比较扎实的网络基础知识才能玩转。可以说前面几种模式所实现的功能，在这种模式下，通过虚拟机及网卡的设置都可以被实现。</p>
<p>我们可以理解为Guest在主机中模拟出一张专供虚拟机使用的网卡，所有虚拟机都是连接到该网卡上的，我们可以通过设置这张网卡来实现上网及其他很多功能，比如（网卡共享、网卡桥接等）。</p>
<p>虚拟机与主机的关系：默认不能相互访问，双方不属于同一IP段，host-only网卡默认IP段为192.168.56.X 子网掩码为255.255.255.0，后面的虚拟机被分配到的也都是这个网段。通过网卡共享、网卡桥接等，可以实现虚拟机于主机相互访问。</p>
<p>虚拟机与网络主机的关系：默认不能相互访问，原因同上，通过设置，可以实现相互访问。</p>
<p>虚拟机与虚拟机的关系：默认可以相互访问，都是同处于一个网段。</p>
<h2 id="实战环节"><a href="#实战环节" class="headerlink" title="实战环节"></a>实战环节</h2><h3 id="虚拟主机访问外网"><a href="#虚拟主机访问外网" class="headerlink" title="虚拟主机访问外网"></a>虚拟主机访问外网</h3><p>将网卡设置为NAT模式即可</p>
<h3 id="虚拟主机与宿主机互通并可以链接外网"><a href="#虚拟主机与宿主机互通并可以链接外网" class="headerlink" title="虚拟主机与宿主机互通并可以链接外网"></a>虚拟主机与宿主机互通并可以链接外网</h3><p>最简单的方式使用桥接模式，一张网卡就足够了<br>还有一种复杂的方式，使用<code>NAT</code>与<code>Host-only Adapter</code>组合实现。网卡一用<code>NAT</code>可以保证虚拟机访问外网。网卡二<code>Host-only Adapter</code>让虚拟机拥有自己的ip，这样宿主机就可以访问到虚拟机了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/chaishen10000/article/details/82984811">https://blog.csdn.net/chaishen10000/article/details/82984811</a><br><a href="https://jingyan.baidu.com/article/215817f7cd8d9f5fda1423ce.html">https://jingyan.baidu.com/article/215817f7cd8d9f5fda1423ce.html</a><br><a href="https://blog.csdn.net/dkfajsldfsdfsd/article/details/79441874">https://blog.csdn.net/dkfajsldfsdfsd/article/details/79441874</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>limits.conf配置说明</title>
    <url>/2020/01/03/2020/limits-conf%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>最近发生了奇怪的事情，mysql总是会连不上，查了半天原因，最后发现进程文件没有生成。es报警“Too many open files”。搜索才发现是，打开文件太多了，超过了限制。解决方法是修改<code>/etc/security/limits.conf</code>。另外还牵扯到了另一个配置<code>file-max</code>。经过调试还是踩了不少坑的。坐下笔记，防止重复踩坑。</p>
<span id="more"></span>

<h2 id="limits-conf-和-file-max的关系"><a href="#limits-conf-和-file-max的关系" class="headerlink" title="limits.conf 和 file-max的关系"></a>limits.conf 和 file-max的关系</h2><p>这两个配置都是为了限制系统资源，防止造成资源耗尽。<br>一般如果遇到文件句柄达到上限时，会碰到”Too many open files”或者Socket&#x2F;File: Can’t open so many files等错误。<br>limits.conf是用户级别的配置，它可以针对每个用户进行限制。<br>file-max是系统级别的配置，它会限制所有用户的打开句柄总数。</p>
<p>file-max无法限制limits.conf。因为linux是多用户系统。比如 file-max设置100，limits设置是10，如果服务器有11个用户，每个用户设置是10，他们所有人占用的句柄总数加起来有可能超过file-max。</p>
<h2 id="file-max设置"><a href="#file-max设置" class="headerlink" title="file-max设置"></a>file-max设置</h2><p>查看file-max限制，我们可以查看<code>/proc/sys/fs/file-max</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure>
<p>修改file-max限制，需要修改<code>/etc/sysctl.conf</code>，找到file-max配置进行修改就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p>末尾加入<code>fs.file-max = 2000000</code>如有了<code>fs.file-max</code>直接修改值即可。</p>
<blockquote>
<p>修改后需要重启电脑才会生效，如果要历史修改可以直接修改<code>/proc/sys/fs/file-max</code>文件内的值，如果可以的话。我测试的时候没有修改成功</p>
</blockquote>
<h2 id="limits-conf设置"><a href="#limits-conf设置" class="headerlink" title="limits.conf设置"></a>limits.conf设置</h2><p>limits的限制可以分为shell级别和系统级别。shell级别顾名思义，只针对当前会话有效。设置方法很简单</p>
<h3 id="shell级别配置"><a href="#shell级别配置" class="headerlink" title="shell级别配置"></a>shell级别配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -n 901</span><br></pre></td></tr></table></figure>
<p>查看当前配置也很简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -n</span><br></pre></td></tr></table></figure>
<p>这样就设置好了当前会话的配置。</p>
<blockquote>
<p>普通用户设置ulimit，每次设置的值只能小于等于上一次设置的值。比如上面设置了901，再次设置只能小于等于901。没有执行ulimit设置之前，配置是从limits.conf文件内读取。因此，每次设置的值不能超过limits.conf文件设置的范围。<br>。<br>root用户不受限制，可以任意设置每次的值</p>
</blockquote>
<p>ulimit有一下可选参数</p>
<ul>
<li>ulimit -a   显示当前所有的资源限制</li>
<li>ulimit -H    设置硬件资源限制</li>
<li>ulimit -S    设置软件资源限制，该限制不能超过<code>-H</code>的限制</li>
<li>ulimit -n    设置进程最大打开文件描述符数</li>
</ul>
<p>上面的 <code>ulimit -n 901</code>相当于 <code>ulimit -Hn 901</code> + <code>ulimit -Sn 901</code></p>
<h3 id="系统级别配置"><a href="#系统级别配置" class="headerlink" title="系统级别配置"></a>系统级别配置</h3><p><code>ulimit</code>好处是配置及时生效，只影响当前shell，安全有保障。但是服务器上我们要配置永久有效，针对所有用户或特定用户有效。就需要配置<code>limits.conf</code>文件了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* soft nofile 655360        # open files  (-n)，不要设置为unlimited</span><br><span class="line">* hard nofile 655360        # 不要超过最大值1048576，不要设置为unlimited</span><br><span class="line"></span><br><span class="line">* soft nproc 655650</span><br><span class="line">* hard nproc 655650         # max user processes   (-u)</span><br><span class="line"></span><br><span class="line">hive   - nofile 655650</span><br><span class="line">hive   - nproc  655650</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>格式为<code>username|@groupname type resource limit</code></p>
<ul>
<li><code>username|@groupname</code> 设置需要被限制的用户名，组名前面加@和用户名区别。也可以用通配符*来做所有用户的限制。</li>
<li><code>type</code> soft，hard 和 -，soft是一个警告值，而hard则是一个真正意义的阀值，超过就会报错。soft 的限制不能比har 限制高。用 - 就表明同时设置了 soft 和 hard 的值。</li>
<li><code>resource</code> 配置项，要使 limits.conf 文件配置生效，必须要确保 pam_limits.so 文件被加入到启动文件中。查看 &#x2F;etc&#x2F;pam.d&#x2F;login 文件中有<code>session required /lib/security/pam_limits.so</code><ul>
<li>core - 限制内核文件的大小</li>
<li>date - 最大数据大小</li>
<li>fsize - 最大文件大小</li>
<li>memlock - 最大锁定内存地址空间</li>
<li>nofile - 打开文件的最大数目</li>
<li>rss - 最大持久设置大小</li>
<li>stack - 最大栈大小</li>
<li>cpu - 以分钟为单位的最多 CPU 时间</li>
<li>noproc - 进程的最大数目</li>
<li>as - 地址空间限制</li>
<li>maxlogins - 此用户允许登录的最大数目</li>
</ul>
</li>
<li><code>limit</code> 限制的值</li>
</ul>
<blockquote>
<p>limits.conf 文件修改后退出重新登录一下就生效了，如果不生效就重启下系统</p>
</blockquote>
<h2 id="常用排查命令"><a href="#常用排查命令" class="headerlink" title="常用排查命令"></a>常用排查命令</h2><p>所有用户创建的进程数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps h -Led -o user | sort | uniq -c | sort -n</span><br></pre></td></tr></table></figure>
<p>查看系统最大打开文件描述符数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure>
<p>设置系统最大打开文件描述符数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p>查看当前系统使用的打开文件描述符数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/fs/file-nr</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>limits.conf</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 为php7.0安装redis扩展</title>
    <url>/2020/02/12/2020/linux-%E4%B8%BAphp7-0%E5%AE%89%E8%A3%85redis%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>php一定要有<code>phpise</code>组件，如果是编译安装一般是有的，如果是apt或yum不一定有。也很简单，安装个php-dev就可以了。<br>另外gcc等必备的包，安装过程中缺什么就按什么。<br>笔记以apt安装php环境为基础做记录</p>
<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><ol>
<li><p>安装扩展</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/phpredis/phpredis/archive/4.0.2.tar.gz</span><br><span class="line">tar -zxvf 4.0.2.tar.gz</span><br><span class="line">cd phpredis-4.0.2</span><br><span class="line">./configure --with-php-config=/usr/bin/php-config7.0</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>php-config是一个获取php配置的程序，一般在php安装目录的bin目录下。多版本共存的情况下安装扩展可以让扩展准确知道，这是给哪个版本安装。<br>如果是apt安装的php，可以使用<code>whereis php-config</code>查看该文件所在目录。如果是自己编译安装更容易找，到安装目录下的bin目录就找到了。</p>
</li>
<li><p>启用扩展<br>找到<code>vi /etc/php/7.0/fpm/php.ini</code> 在里面添加 <code>extension=redis.so</code> 就可以了。<br>如果想在命令行模式下也使用这个扩展，可以在<code>/etc/php/7.0/cli/php.ini</code>里也添加 <code>extension=redis.so</code> 。</p>
</li>
<li><p>重启php-fpm和nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service php-fpm7.0 restart</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>
<p>经过这些处理redis扩展就可以正常使用了。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/eeds-wangwei/p/11016160.html">https://www.cnblogs.com/eeds-wangwei/p/11016160.html</a><br><a href="https://github.com/phpredis/phpredis">https://github.com/phpredis/phpredis</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置中root alias的区别</title>
    <url>/2020/05/15/2020/nginx%E9%85%8D%E7%BD%AE%E4%B8%ADroot-alias%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="alias用法"><a href="#alias用法" class="headerlink" title="alias用法"></a>alias用法</h2><ul>
<li>alias只能用在location块中</li>
<li>可以配置文件</li>
<li>可以配置目录</li>
</ul>
<p>代理特定文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = /market-api/bm/44O1jrDWhJ.txt &#123;</span><br><span class="line">                alias /var/www/wechat/44O1jrDWhJ.txt;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>代理目录，建议最后面的<code>/</code>保留</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = /market-api/bm/ &#123;</span><br><span class="line">                alias /var/www/wechat/;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="root用法"><a href="#root用法" class="headerlink" title="root用法"></a>root用法</h2><ul>
<li>可以在http、server、location、if块中</li>
<li>只可配置目录</li>
<li>配置目录最后带<code>/</code>会抛弃localtion配置中的目录，不带<code>/</code>则会拼接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = /market-api/bm &#123;</span><br><span class="line">                root /var/www/wechat/;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>带<code>/</code>时访问<code>/market-api/bm/a.txt</code>实际请求文件是<code>/var/www/wechat/a.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = /market-api/bm &#123;</span><br><span class="line">                root /var/www/wechat;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不加<code>/</code>时访问<code>/market-api/bm/a.txt</code>实际请求文件是<code>/var/www/wechat/market-api/bm/a.txt</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/57db2c5d0cb9">https://www.jianshu.com/p/57db2c5d0cb9</a><br><a href="https://segmentfault.com/a/1190000017304865">https://segmentfault.com/a/1190000017304865</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>root</tag>
        <tag>alias</tag>
      </tags>
  </entry>
  <entry>
    <title>linux硬盘管理工具baobab</title>
    <url>/2020/05/12/2020/linux%E7%A1%AC%E7%9B%98%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7baobab/</url>
    <content><![CDATA[<p>baobab是一个非常好用的磁盘分析工具，可以可视化的呈现磁盘的使用情况</p>
<p><img src="https://wiki.gnome.org/Apps/DiskUsageAnalyzer?action=AttachFile&do=get&target=screenshot.png" alt="Disk Usage Analyzer"></p>
<p>git地址  <a href="https://gitlab.gnome.org/GNOME/baobab.git">https://gitlab.gnome.org/GNOME/baobab.git</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>运维工具</tag>
        <tag>baobab</tag>
        <tag>Disk Usage Analyzer</tag>
      </tags>
  </entry>
  <entry>
    <title>python mysql-connector简要说明</title>
    <url>/2020/02/14/2020/python-mysql-connector%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install mysql-connector</span><br></pre></td></tr></table></figure>

<h2 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import mysql.connector</span><br><span class="line"> </span><br><span class="line"># 接收参数：user, password, host, port=3306, unix_socket and database</span><br><span class="line"># 返回一个MySQLConnection Object</span><br><span class="line">config = &#123;</span><br><span class="line">    &#x27;host&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">    &#x27;user&#x27;: &#x27;root&#x27;,</span><br><span class="line">    &#x27;password&#x27;: &#x27;root&#x27;,</span><br><span class="line">    &#x27;port&#x27;: 3306,</span><br><span class="line">    &#x27;database&#x27;: &#x27;test&#x27;,</span><br><span class="line">    &#x27;charset&#x27;: &#x27;utf8&#x27;</span><br><span class="line">&#125;</span><br><span class="line">try:</span><br><span class="line">    cnn = mysql.connector.connect(**config)</span><br><span class="line">except mysql.connector.Error as e:</span><br><span class="line">    print(&#x27;connect fails!&#123;&#125;&#x27;.format(e))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>conn就是mysql的链接对象，它可以提交开启事务、提交、回滚，也可以关闭来mysql断开链接</p>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>执行查询，需要经过以下几个过程：</p>
<ol>
<li>获取一个游标，数据操作都是基于游标来处理。链接的cursor方法会返回一个游标，如上面<code>conn.cursor()</code>就会返回游标。</li>
<li>调用游标的execute方法，执行sql。</li>
<li>获取执行结果，我们可以用fetchone()一次获取一条记录，也可以用fetchall()，一次性获取所有记录。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursor = cnn.cursor()</span><br><span class="line">try:</span><br><span class="line">    sql_query = &#x27;select name,age from stu ;&#x27;</span><br><span class="line">    cursor.execute(sql_query)</span><br><span class="line">    for name, age in cursor:</span><br><span class="line">        print (name, age)</span><br><span class="line">except mysql.connector.Error as e:</span><br><span class="line">    print(&#x27;query error!&#123;&#125;&#x27;.format(e))</span><br><span class="line">finally:</span><br><span class="line">    cursor.close()</span><br><span class="line">    cnn.close()</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h3 id="获取全部数据"><a href="#获取全部数据" class="headerlink" title="获取全部数据"></a>获取全部数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd = conn.cursor()</span><br><span class="line"># 执行一条原生的SQL语句，执行结果保存在cmd中，没有返回值</span><br><span class="line">cmd.execute(&quot;select id, name, age from stu&quot;)</span><br><span class="line"># 可以使用fetchall()，获取所有的查询结果集，返回值为一个tuple，每一个元素是一个list</span><br><span class="line">res = cmd.fetchall()</span><br><span class="line">print(res)</span><br><span class="line"># [(1, &#x27;LiMing&#x27;, 20), (2, &#x27;XiaoHua&#x27;, 30), (3, &#x27;LiLei&#x27;, 10)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取一条数据"><a href="#获取一条数据" class="headerlink" title="获取一条数据"></a>获取一条数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd = conn.cursor()</span><br><span class="line"> </span><br><span class="line">cmd.execute(&quot;select id, name, age from stu&quot;)</span><br><span class="line"> </span><br><span class="line"># 使用fetchone()返回一条结果集，每调用一次之后，内部指针会指向下一条结果集</span><br><span class="line">print(cmd.fetchone()) # (1, &#x27;LiMing&#x27;, 20)</span><br><span class="line">print(cmd.fetchone()) # (2, &#x27;XiaoHua&#x27;, 30)</span><br><span class="line">print(cmd.fetchone()) # (3, &#x27;LiLei&#x27;, 10)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="一次获取n条数据"><a href="#一次获取n条数据" class="headerlink" title="一次获取n条数据"></a>一次获取n条数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd = conn.cursor()</span><br><span class="line"> </span><br><span class="line">cmd.execute(&quot;select * from stu&quot;)</span><br><span class="line"> </span><br><span class="line">res = cmd.fetchmany(2)   # 指定返回2条记录</span><br><span class="line">print(res)</span><br><span class="line"># [(1, &#x27;LiMing&#x27;, 20), (2, &#x27;XiaoHua&#x27;, 30)]</span><br><span class="line"> </span><br><span class="line">res = cmd.fetchmany(1)   # 指定返回1条记录</span><br><span class="line">print(res)</span><br><span class="line"># [(3, &#x27;LiLei&#x27;, 10)]</span><br></pre></td></tr></table></figure>

<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个查询</span><br><span class="line">cmd = conn.cursor()</span><br><span class="line"> </span><br><span class="line"># 执行原生SQL语句</span><br><span class="line">cmd.execute(&quot;insert into stu (id, name, age) values (4, &#x27;LiBai&#x27;, 99)&quot;)</span><br><span class="line">print(cmd.rowcount)  # 1</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个查询</span><br><span class="line">cmd = conn.cursor()</span><br><span class="line"> </span><br><span class="line"># 执行原生SQL语句</span><br><span class="line">cmd.execute(&quot;update stu set name=&#x27;张三&#x27;&quot;)</span><br><span class="line">print(cmd.rowcount)  # 1</span><br><span class="line"> </span><br><span class="line">cmd.execute(&quot;select * from stu&quot;)</span><br><span class="line">res = cmd.fetchall()</span><br><span class="line">print(res)</span><br><span class="line"># [(1, &#x27;LiMing&#x27;, 20), (2, &#x27;XiaoHua&#x27;, 30), (3, &#x27;LiLei&#x27;, 10), (4, &#x27;LiBai&#x27;, 99)]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>知识点<br>fetchone() 一次获取一条数据，每执行一次游标自动移动到下一条，直到数据全部读出。<br>fetchmany(5) 一次获取5条数据，没执行一次游标向后移动，直到数据全部读出。<br>fetchall() 一次获取所有数据</p>
</blockquote>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>前面的例子都是直接执行sql语句，这样存在一定的危险性。预处理是不错的方式。execute方法支持3个参数：</p>
<blockquote>
<p>第一个参数是执行的sql，sql中的参数可以使用具体内容，也可以使用占位符<br>第二个参数，是当以一个参数使用了占位符时用到的，参数类型是一个元组(tuple),元祖的元素个数，根据第一个参数中的占位符个数决定<br>第三个表示第一个参数是不是多个SQL语句，如果是的话，就传入True，否则传入False</p>
</blockquote>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd = conn.cursor()</span><br><span class="line"> </span><br><span class="line"># 注意，在SQL中的占位符，统一写%s, 具体的类型，是在tuple中，传入的参数元素类型决定</span><br><span class="line">cmd.execute(&quot;select * from stu where id=%s and name=%s&quot;, (1, &#x27;LiMing&#x27;))</span><br><span class="line">res = cmd.fetchall()</span><br><span class="line">print(res)</span><br><span class="line"># [(1, &#x27;LiMing&#x27;, 20)]</span><br><span class="line"></span><br><span class="line"># 如果占位符只有一个，则tuple中要有一个逗号，这是tuple定义需要注意的</span><br><span class="line">cmd.execute(&quot;select * from stu where id=%s &quot;, (1,))</span><br><span class="line">res = cmd.fetchall()</span><br><span class="line">print(res)</span><br><span class="line"># [(1, &#x27;LiMing&#x27;, 20)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="更新、删除"><a href="#更新、删除" class="headerlink" title="更新、删除"></a>更新、删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除</span><br><span class="line">cmd.execute(&quot;delete from stu  where id=%s &quot;, (2,))</span><br><span class="line"># 注意，如果是更新操作一定要执行commit，否则数据库不会更新</span><br><span class="line">cmd.execute(&quot;update stu set name=&#x27;lisi&#x27; where id=%s &quot;, (1,))</span><br><span class="line">conn.commit()</span><br><span class="line"># 如果占位符只有一个，则tuple中要有一个逗号，这是tuple定义需要注意的</span><br><span class="line">cmd.execute(&quot;select * from stu where id=%s &quot;, (1,))</span><br><span class="line">res = cmd.fetchall()</span><br><span class="line">print(res)</span><br><span class="line"># [(1, &#x27;lisi&#x27;, 20)]</span><br></pre></td></tr></table></figure>
<p>上面的操作如果去掉conn.commit()，输出结果也会是<code>[(1, &#39;lisi&#39;, 20)]</code>，但进入数据库查看，数据库的内容并不会更新。</p>
<blockquote>
<p>知识点<br>预处理时，python会实时得知sql执行的最终结果。但是如果不执行<code>commit()</code>数据库内的数据不会真正更新。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/-beyond/p/9798970.html">https://www.cnblogs.com/-beyond/p/9798970.html</a><br><a href="https://www.cnblogs.com/xiaohuomiao/p/10729818.html">https://www.cnblogs.com/xiaohuomiao/p/10729818.html</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mysql-connector</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置结构说明</title>
    <url>/2020/01/10/2020/nginx%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>最近做项目发现服务器上nginx的配置很混乱，主要原因就是配置的人不太了解nginx的配置。从网上查了资料之后就复制了。</p>
<h2 id="配置结构"><a href="#配置结构" class="headerlink" title="配置结构"></a>配置结构</h2><p>nginx的配置其实很简单，总共也就分为4部分：main（全局设置）、server（主机设置）、upstream（负载均衡服务器设置）和 location（URL匹配特定位置的设置）<br>他们的关系是，server继承main，location继承server，upstream既不会继承其他设置也不会被继承。<br>所以配置的优先级就是 location &gt; server &gt; main</p>
<span id="more"></span>

<p>一级指的是nginx的入口配置文件<code>nginx.conf</code>,这个文件的存放位置根据安装环境有所差异。比如使用源码包安装nginx到<code>/usr/local</code>。nginx.conf就会在<code>/usr/local/nginx/conf/nginx.conf</code>。</p>
<p>nginx.conf中一般是这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user nobody nobody;</span><br><span class="line">worker_processes 2;</span><br><span class="line">error_log logs/error.log notice;</span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"> </span><br><span class="line">events&#123;</span><br><span class="line">use epoll;</span><br><span class="line">worker_connections 65536;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">            listen       80;</span><br><span class="line">            server_name  localhost;</span><br><span class="line"></span><br><span class="line">            #charset koi8-r;</span><br><span class="line"></span><br><span class="line">            #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">            location / &#123;</span><br><span class="line">                root   html;</span><br><span class="line">                index  index.html index.htm;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">            # redirect server error pages to the static page /50x.html</span><br><span class="line">            #</span><br><span class="line">            error_page   500 502 503 504  /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">                root   html;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">            #</span><br><span class="line">            #location ~ \.php$ &#123;</span><br><span class="line">            #    proxy_pass   http://127.0.0.1;</span><br><span class="line">            #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="http配置"><a href="#http配置" class="headerlink" title="http配置"></a>http配置</h2><p>http里面主要做一些server中会用到的通用配置，比如mime，日志格式log_format，负载均衡等。<br>http里面放多个server，一般为了方便管理，我们会把server放到一个叫vhost的文件夹内。然后用<code>include vhost/*.conf;</code>的方式加载进来。</p>
<h2 id="server配置"><a href="#server配置" class="headerlink" title="server配置"></a>server配置</h2><p>http中的配置项，server中也可以使用，如果某个站点需要个性化配置，可以自行配置。<br>相同的配置项，server中的配置优先级高于http。</p>
<h2 id="location配置"><a href="#location配置" class="headerlink" title="location配置"></a>location配置</h2><p>主要用于请求转发，或者针对某个路由进行特殊处理。经常用到的场景是为了节省域名，前端和后端都部署在一个域名下。接口用XXX.com&#x2F;api去访问，这时候可以通过location做转发</p>
<h2 id="upstream配置"><a href="#upstream配置" class="headerlink" title="upstream配置"></a>upstream配置</h2><p>负载均衡可以放在http内部，也可以放在http的外层。这就方便了灵活配置。如果只有一个负载配置多server公用，可以在<code>nginx.conf</code>中配置，在各个server中使用。<br>如果每个server有自己的负载配置。就可以把配置放在自己的配置文件<code>vhost/server1.conf</code>中。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>openresty+lua+kafka部署</title>
    <url>/2020/02/26/2020/openresty-lua-kafka%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>使用kafka作为消息队列，将信息收集起来</li>
<li>已有程序无需修改，改起来成本太高了<br>满足这两个条件，首先想到的就是用nginx把数据转发出去，这样程序不用改动，只改变运维环境就可以了。</li>
</ol>
<span id="more"></span>

<h2 id="安装openresty"><a href="#安装openresty" class="headerlink" title="安装openresty"></a>安装openresty</h2><p>openresty源码安装的过程中，与服务器上的包依赖有冲突。所以改用apt方式安装。很简单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装导入 GPG 公钥时所需的几个依赖包（整个安装过程完成后可以随时删除它们）：</span><br><span class="line">sudo apt-get -y install --no-install-recommends wget gnupg ca-certificates</span><br><span class="line"></span><br><span class="line"># 导入我们的 GPG 密钥：</span><br><span class="line">wget -O - https://openresty.org/package/pubkey.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"># 安装 add-apt-repository 命令</span><br><span class="line"># （之后你可以删除这个包以及对应的关联包）</span><br><span class="line">sudo apt-get -y install --no-install-recommends software-properties-common</span><br><span class="line"></span><br><span class="line"># 添加我们官方 official APT 仓库：</span><br><span class="line">sudo add-apt-repository -y &quot;deb http://openresty.org/package/ubuntu $(lsb_release -sc) main&quot;</span><br><span class="line"></span><br><span class="line"># 更新 APT 索引：</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"># 安装openresty</span><br><span class="line">sudo apt-get -y install openresty</span><br></pre></td></tr></table></figure>

<h2 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h2><ol>
<li>下载kafka<br>进入Apache官网<a href="http://kafka.apache.org/downloads.html">http://kafka.apache.org/downloads.html</a></li>
</ol>
<p>找到<code>Binary downloads</code>，选择版本进行下载。</p>
<p>也可以复制下载链接，然后用<code>wget</code>下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://apache.01link.hk/kafka/2.0.0/kafka_2.11-2.0.0.tgz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解压程序包<br>压缩包下载后先移动到<code>/opt</code>目录，这是我的习惯，自己安装的放到<code>/opt</code>目录下建一个软件目录，比如<code>/opt/kafka</code>,这样方便管理<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv kafka_2.11-2.0.0.tgz /opt</span><br><span class="line">cd /opt</span><br><span class="line">tar -xzf kafka_2.11-2.0.0.tgz</span><br></pre></td></tr></table></figure>
这样kafka就安装完了，安装目录就是<code>/opt/kafka_2.11-2.0.0</code></li>
</ol>
<p>3.配置hosts文件<br>将本机的局域网ip和127.0.0.1都配置上,否则会造成kafka无法启动。kafka启动过程中会根据当前主机名进行解析，如果不设置会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># shooke-pc是我的主机名，ip和主机名根据具体情况配置</span><br><span class="line">192.168.99.36 shooke-pc</span><br><span class="line">127.0.0.1 shooke-pc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动kafka服务</li>
</ol>
<p>启动zookeeper</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/kafka_2.11-2.0.0/bin/zookeeper-server-start.sh  /opt/kafka_2.11-2.0.0/config/zookeeper.properties </span><br></pre></td></tr></table></figure>
<p>kafka依赖zookeeper的，如果有自己的zookeeper服务，可以不启动这个。</p>
<p>启动kafka</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/kafka_2.11-2.0.0/bin/kafka-server-start.sh  /opt/kafka_2.11-2.0.0/config/server.properties </span><br></pre></td></tr></table></figure>
<p>这样kafka服务就启动了。</p>
<blockquote>
<p>如果希望后台运行可以加<code>-daemon</code>参数，或用<code>nohup</code>去实现效果</p>
</blockquote>
<h2 id="安装lua-resty-kafka"><a href="#安装lua-resty-kafka" class="headerlink" title="安装lua-resty-kafka"></a>安装lua-resty-kafka</h2><p><code>lua-resty-kafka</code>是<code>openresty</code>和<code>kafka</code>的桥梁。安装了这个插件就可以让<code>openresty</code>吧数据转发到<code>kafka</code>了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载插件</span><br><span class="line">wget https://github.com/doujiang24/lua-resty-kafka/archive/master.zip</span><br><span class="line"># 解压</span><br><span class="line">unzip master.zip</span><br><span class="line"># 老规矩自己装的软件放到/opt目录</span><br><span class="line">mv lua-resty-kafka-master /opt/lua-resty-kafka</span><br></pre></td></tr></table></figure>

<h2 id="让openresty和kafka建立联系"><a href="#让openresty和kafka建立联系" class="headerlink" title="让openresty和kafka建立联系"></a>让openresty和kafka建立联系</h2><p>1.配置kafka</p>
<p>修改<code>/opt/kafka_2.11-2.0.0/config/server.properties</code>，找到<code>listeners</code>，根据具体情况修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这个ip地址是kafka在内网的地址，记住这个ip，下面nginx配置中也会用到，一定要对应</span><br><span class="line">listeners=PLAINTEXT://192.168.99.36:9092</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.配置nginx</p>
<p>接下来配置openresty的nginx，让nginx和kafka联系起来<br>修改<code>/etc/openresty/nginx.conf</code> 在http节点内添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 配置个负载均衡方便测试</span><br><span class="line">    upstream apps &#123;</span><br><span class="line">        keepalive 80;</span><br><span class="line">        server 127.0.0.1:8078;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # `lua-resty-kafka`路径</span><br><span class="line">    lua_package_path &quot;/opt/lua-resty-kafka/lib/?.lua;/opt/lua-resty-http/lib/?.lua;&quot;;</span><br><span class="line">  </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8077;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line"></span><br><span class="line">            proxy_next_upstream http_502 http_504 http_404 error invalid_header;</span><br><span class="line">            # 负载均衡</span><br><span class="line">            proxy_pass http://apps;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            #proxy_set_header Connection &quot;&quot;;</span><br><span class="line">            proxy_set_header X-real-ip $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            # 编写lua脚本</span><br><span class="line">            log_by_lua &#x27;</span><br><span class="line">                local cjson = require &quot;cjson&quot;</span><br><span class="line">                local producer = require &quot;resty.kafka.producer&quot;</span><br><span class="line">                local broker_list = &#123;</span><br><span class="line">                  &#123; host = &quot;192.168.99.36&quot;, port = 9092 &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                local topic = &quot;logs&quot;</span><br><span class="line">                local log_json = &#123;&#125;</span><br><span class="line">                log_json[&quot;uri&quot;]=ngx.var.uri</span><br><span class="line">                log_json[&quot;args&quot;]=ngx.var.args</span><br><span class="line">                log_json[&quot;host&quot;]=ngx.var.host</span><br><span class="line">                log_json[&quot;cookie&quot;]=ngx.var.http_cookie</span><br><span class="line">                log_json[&quot;method&quot;]=ngx.var.request_method</span><br><span class="line">                log_json[&quot;request_body&quot;]=ngx.var.request_body</span><br><span class="line">                log_json[&quot;remote_addr&quot;] = ngx.var.remote_addr</span><br><span class="line">                log_json[&quot;remote_user&quot;] = ngx.var.remote_user</span><br><span class="line">                log_json[&quot;time_local&quot;] = ngx.var.time_local</span><br><span class="line">                log_json[&quot;status&quot;] = ngx.var.status</span><br><span class="line">                log_json[&quot;body_bytes_sent&quot;] = ngx.var.body_bytes_sent</span><br><span class="line">                log_json[&quot;http_referer&quot;] = ngx.var.http_referer</span><br><span class="line">                log_json[&quot;http_user_agent&quot;] = ngx.var.http_user_agent</span><br><span class="line">                log_json[&quot;http_x_forwarded_for&quot;] = ngx.var.http_x_forwarded_for</span><br><span class="line">                log_json[&quot;upstream_response_time&quot;] = ngx.var.upstream_response_time</span><br><span class="line">                log_json[&quot;http_current_user&quot;] = ngx.var.upstream_http_x_current_user</span><br><span class="line">                log_json[&quot;request_time&quot;] = ngx.var.request_time</span><br><span class="line">                local postargs = ngx.req.get_body_data()</span><br><span class="line">		            log_json[&quot;post_data&quot;] = postargs</span><br><span class="line">                log_json[&quot;res_body&quot;] = ngx.var</span><br><span class="line">                local message = cjson.encode(log_json);</span><br><span class="line">                local bp = producer:new(broker_list, &#123; producer_type = &quot;async&quot; &#125;)</span><br><span class="line">                local ok, err = bp:send(topic, nil, message)</span><br><span class="line">                if not ok then</span><br><span class="line">                    ngx.log(ngx.ERR, &quot;kafka send err:&quot;, err)</span><br><span class="line">                    return</span><br><span class="line">                end</span><br><span class="line">            &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen    8078;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          content_by_lua &#x27;ngx.say(&quot;hello world&quot;)&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置完成后执行<code>systemctl restart openresty</code>重启服务就好了。访问8077端口请求会转发到kafka。<br>让nginx配置生效也可以执行<code>/usr/local/openresty/nginx/sbin/nginx -s reload</code></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.<code>/etc/hosts</code>文件要配置上ip和主机名，否则kafka会无法启动报错找不到<br>2.kafka <code>server.properties</code>中<code>listeners</code>的ip要跟nginx配置的<code>broker_list</code>中<code>host</code>一致，否则会报错</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/expiator/p/9990171.html">https://www.cnblogs.com/expiator/p/9990171.html</a><br><a href="https://blog.csdn.net/qq_29497387/article/details/101290378">https://blog.csdn.net/qq_29497387/article/details/101290378</a><br><a href="https://blog.csdn.net/u011239989/article/details/52239785">https://blog.csdn.net/u011239989/article/details/52239785</a><br><a href="https://blog.csdn.net/qq_29497387/article/details/99745903">https://blog.csdn.net/qq_29497387/article/details/99745903</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>openresty</tag>
        <tag>lua</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>python捕获异常堆栈信息</title>
    <url>/2020/08/13/2020/python%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>python的异常对称相比java或php简单了很多，对象中的信息很少，只有简单的错误输出。这在开发过程中是无法满足使用需求的。我们还需要更多的错误信息，比如错误发生在哪一行，具体的错误信息是什么。这就需要获取错误堆栈信息。下面简单记录一下常用的集中异常处理。</p>
<span id="more"></span>

<h2 id="最简单的异常处理"><a href="#最简单的异常处理" class="headerlink" title="最简单的异常处理"></a>最简单的异常处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    a = &#123;&#125;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
<p>我们得到的信息是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;name&#x27;</span><br></pre></td></tr></table></figure>
<p>之所以出现<code>‘name’</code>错误，是因为咱们的字典<code>a</code>中没有<code>name</code>这个key。但这样的异常对我们来说毫无意义。</p>
<h2 id="repr带点说明的异常处理"><a href="#repr带点说明的异常处理" class="headerlink" title="repr带点说明的异常处理"></a>repr带点说明的异常处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    a = &#123;&#125;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(repr(e))</span><br></pre></td></tr></table></figure>
<p>我们得到信息是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KeyError(&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>
<p>这次使用了<code>repr</code>输出的信息总算是有点意义了，他让我们知道错误是因为一个<code>KeyError</code>。但这还不够我们需要知道错误发生在什么地方</p>
<h2 id="logging-exception显示异常发生位置"><a href="#logging-exception显示异常发生位置" class="headerlink" title="logging.exception显示异常发生位置"></a>logging.exception显示异常发生位置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    a = &#123;&#125;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">except Exception as e:</span><br><span class="line">    logging.exception(e)</span><br></pre></td></tr></table></figure>
<p>使用了<code>logging.exception</code>这次得到的信息就更加的丰富了，不但提示了错误，还指出了发生的所在行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:root:&#x27;name&#x27;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/var/www/gubeichun/gbcdata/test/test.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">KeyError: &#x27;name&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="使用traceback模块处理异常"><a href="#使用traceback模块处理异常" class="headerlink" title="使用traceback模块处理异常"></a>使用traceback模块处理异常</h2><h3 id="直接打印错误信息"><a href="#直接打印错误信息" class="headerlink" title="直接打印错误信息"></a>直接打印错误信息</h3><p>除了使用<code>logging.exception</code>还可以使用<code>traceback</code>模块来处理异常，更加方便</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import traceback</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    a = &#123;&#125;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">except Exception as e:</span><br><span class="line">    traceback.print_exc()</span><br><span class="line">    # msg = traceback.format_exc()</span><br><span class="line">    # print(msg)</span><br></pre></td></tr></table></figure>
<p>这次得到的错误信息是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/var/www/gubeichun/gbcdata/test/test.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">KeyError: &#x27;name&#x27;</span><br></pre></td></tr></table></figure>
<p>这样的错误比起<code>logging.exception</code>清爽了一些。<code>traceback.print_exc()</code>也是直接打印错误。</p>
<h3 id="获取错误信息，自行处理"><a href="#获取错误信息，自行处理" class="headerlink" title="获取错误信息，自行处理"></a>获取错误信息，自行处理</h3><p>有时候我们不希望错误被打印，而是希望接收错误，自己保存日志，这时候只要把<code>print_exc()</code>换成<code>format_exc()</code>就可以了</p>
<h2 id="使用sys和traceback模块处理异常"><a href="#使用sys和traceback模块处理异常" class="headerlink" title="使用sys和traceback模块处理异常"></a>使用sys和traceback模块处理异常</h2><h3 id="直接打印错误信息-1"><a href="#直接打印错误信息-1" class="headerlink" title="直接打印错误信息"></a>直接打印错误信息</h3><p><code>traceback</code>输出的错误信息，已经非常好了，但有时候我们希望更加个性话的处理日志，这时候就需要用到<code>sys</code>模块和<code>traceback</code>模块做个配合。<br>其实<code>print_exc()</code>只不过是对<code>print_exception</code>的封装。下面这样写，会得到<code>print_exc</code>一样的错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import traceback</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    a = &#123;&#125;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">except Exception as e:</span><br><span class="line">    et, ev, tb = sys.exc_info()</span><br><span class="line">    traceback.print_exception(et, ev, tb)</span><br></pre></td></tr></table></figure>
<p>错误信息跟<code>print_exc</code>一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/var/www/gubeichun/gbcdata/test/test.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">KeyError: &#x27;name&#x27;</span><br></pre></td></tr></table></figure>
<p>如果只想输出错误所在行的信息可以使用<code>print_tb</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import traceback</span><br><span class="line">import sys</span><br><span class="line">try:</span><br><span class="line">    a = &#123;&#125;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">except Exception as e:</span><br><span class="line">    et, ev, tb = sys.exc_info()</span><br><span class="line">    traceback.print_tb(tb)</span><br></pre></td></tr></table></figure>
<p>这样就得到了，更清爽的错误信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;/var/www/gubeichun/gbcdata/test/test.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">   print(a[&quot;name&quot;])</span><br></pre></td></tr></table></figure>

<h3 id="获取错误信息，自行处理-1"><a href="#获取错误信息，自行处理-1" class="headerlink" title="获取错误信息，自行处理"></a>获取错误信息，自行处理</h3><p><code>traceback</code>还提供了一个<code>format_exception</code>方法，他会将错误信息处理成一个可迭代对象，让我们更方便的处理错误信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import traceback</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    a = &#123;&#125;</span><br><span class="line">    print(a[&quot;name&quot;])</span><br><span class="line">except Exception as e:</span><br><span class="line">    et, ev, tb = sys.exc_info()</span><br><span class="line">    msg = traceback.format_exception(et, ev, tb)</span><br><span class="line">    for m in msg:</span><br><span class="line">        print(m)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>shadowsocks客户端启动报错问题</title>
    <url>/2020/02/11/2020/shadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sslocal -c shadowsocks.json</span><br></pre></td></tr></table></figure>
<p>报如下错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO: loading config from shadowsocks.json</span><br><span class="line">2020-02-11 10:50:45 INFO     loading libcrypto from libcrypto.so.1.1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/local/bin/sslocal&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    sys.exit(main())</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/shadowsocks/local.py&quot;, line 39, in main</span><br><span class="line">    config = shell.get_config(True)</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/shadowsocks/shell.py&quot;, line 262, in get_config</span><br><span class="line">    check_config(config, is_local)</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/shadowsocks/shell.py&quot;, line 124, in check_config</span><br><span class="line">    encrypt.try_cipher(config[&#x27;password&#x27;], config[&#x27;method&#x27;])</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/shadowsocks/encrypt.py&quot;, line 44, in try_cipher</span><br><span class="line">    Encryptor(key, method)</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/shadowsocks/encrypt.py&quot;, line 83, in __init__</span><br><span class="line">    random_string(self._method_info[1]))</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/shadowsocks/encrypt.py&quot;, line 109, in get_cipher</span><br><span class="line">    return m[2](method, key, iv, op)</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/rc4_md5.py&quot;, line 33, in create_cipher</span><br><span class="line">    return openssl.OpenSSLCrypto(b&#x27;rc4&#x27;, rc4_key, b&#x27;&#x27;, op)</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py&quot;, line 76, in __init__</span><br><span class="line">    load_openssl()</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py&quot;, line 52, in load_openssl</span><br><span class="line">    libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)</span><br><span class="line">  File &quot;/usr/lib/python2.7/ctypes/__init__.py&quot;, line 379, in __getattr__</span><br><span class="line">    func = self.__getitem__(name)</span><br><span class="line">  File &quot;/usr/lib/python2.7/ctypes/__init__.py&quot;, line 384, in __getitem__</span><br><span class="line">    func = self._FuncPtr((name_or_ordinal, self))</span><br><span class="line">AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>原因是openssl1.1.0版本中，废弃了<code>EVP_CIPHER_CTX_cleanup</code>函数改用<code>EVP_CIPHER_CTX_reset</code>替代</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法很简单，找到报错文件<code>/usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py</code>将出错的函数改掉就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py</span><br></pre></td></tr></table></figure>
<p>找到<code>EVP_CIPHER_CTX_cleanup</code>替换为<code>EVP_CIPHER_CTX_reset</code>，一共有两处需要替换</p>
<p>替换后保存退出，执行<code>sslocal -c shadowsocks.json</code>重新启动就ok了</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://kionf.com/2016/12/15/errornote-ss/">https://kionf.com/2016/12/15/errornote-ss/</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu18.4 打开文件中文乱码问题解决</title>
    <url>/2020/12/18/2020/ubuntu18-4-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>本次记录针对ubuntu英文版，打开带有中文字符的文件是，显示乱码问题。不是给ubuntu系统切换到中文版。切换系统语言参考<a href="https://blog.csdn.net/qq_36588424/article/details/109617096">https://blog.csdn.net/qq_36588424/article/details/109617096</a></p>
<h2 id="检查语言环境"><a href="#检查语言环境" class="headerlink" title="检查语言环境"></a>检查语言环境</h2><p>出现乱码的原因其实是字符集问题。首先使用<code>locale</code>查看当前语言环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># locale</span><br><span class="line">LANG=en_US</span><br><span class="line">LANGUAGE=</span><br><span class="line">LC_CTYPE=&quot;en_US&quot;</span><br><span class="line">LC_NUMERIC=&quot;en_US&quot;</span><br><span class="line">LC_TIME=&quot;en_US&quot;</span><br><span class="line">LC_COLLATE=&quot;en_US&quot;</span><br><span class="line">LC_MONETARY=&quot;en_US&quot;</span><br><span class="line">LC_MESSAGES=&quot;en_US&quot;</span><br><span class="line">LC_PAPER=&quot;en_US&quot;</span><br><span class="line">LC_NAME=&quot;en_US&quot;</span><br><span class="line">LC_ADDRESS=&quot;en_US&quot;</span><br><span class="line">LC_TELEPHONE=&quot;en_US&quot;</span><br><span class="line">LC_MEASUREMENT=&quot;en_US&quot;</span><br><span class="line">LC_IDENTIFICATION=&quot;en_US&quot;</span><br><span class="line">LC_ALL=</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="安装utf8字符集"><a href="#安装utf8字符集" class="headerlink" title="安装utf8字符集"></a>安装utf8字符集</h2><p>发现没有<code>utf-8</code>的字符集。需要安装一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locale-gen en_US.UTF-8</span><br></pre></td></tr></table></figure>
<p>查看一下可用字符集，看里面有没有<code>en_US.UTF-8</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># locale -a</span><br><span class="line">C</span><br><span class="line">C.UTF-8</span><br><span class="line">en_US</span><br><span class="line">en_US.iso88591</span><br><span class="line">en_US.utf8</span><br><span class="line">POSIX</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改-etc-profile"><a href="#修改-etc-profile" class="headerlink" title="修改/etc/profile"></a>修改<code>/etc/profile</code></h2><p>用vi打开<code>/etc/profile</code>,最后添加<code>export LC_ALL=en_US.UTF-8</code><br>或者简单点，用下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo &quot;export LC_ALL=en_US.UTF-8&quot; &gt;&gt; /etc/profile</span><br><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/81c1680a583b">https://www.jianshu.com/p/81c1680a583b</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot+nginx websocket配置</title>
    <url>/2020/05/09/2020/springboot+nginx%20websocket%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>websocket用于聊天类场景再好不过了。平时链接websocket需要指定ip和端口，但如果需要用nginx做转发，将请求发送到websocket服务，这时候就需要升级协议了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /member-api/websocket &#123;</span><br><span class="line">                proxy_pass http://localhost:7005;</span><br><span class="line">                proxy_http_version 1.1;</span><br><span class="line">                proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">                proxy_set_header Connection &quot;Upgrade&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是这么简单，指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection &quot;Upgrade&quot;;</span><br></pre></td></tr></table></figure>
<p>让协议升级就可以了</p>
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>springboot</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu18.04编译安装php7.0</title>
    <url>/2020/12/12/2020/ubuntu18-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85php7-0/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>虽然7.0已经停止维护了，但有些老项目也只是过度，后期直接用新项目替换，没有必要在进行升级。所以服务器还是需要用到7.0的运行环境。<br>本来想用apt简单按一下，结果发现apt里面已经没有php7.0了。只能自己源码安装。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装编译安装前，需要先准备一下编译需要的环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc</span><br><span class="line">sudo apt install make</span><br><span class="line">sudo apt install openssl</span><br><span class="line">sudo apt install curl</span><br><span class="line">sudo apt install libbz2-dev</span><br><span class="line">sudo apt install libxml2-dev</span><br><span class="line">sudo apt install libjpeg-dev</span><br><span class="line">sudo apt install libpng-dev</span><br><span class="line">sudo apt install libfreetype6-dev</span><br><span class="line">sudo apt install libzip-dev</span><br><span class="line">sudo apt install libcurl4-openssl-dev</span><br><span class="line">sudo apt install libmcrypt-dev</span><br></pre></td></tr></table></figure>
<p>下载源码包,为了安全起见，当然要去官网下载<code>https://www.php.net/releases/</code>这里有历史版本。<br>找到7.0系列的版本用wget下载即可，或者去php的github clone一下项目也可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /usr/local/src</span><br><span class="line">$ wget https://www.php.net/distributions/php-7.0.32.tar.gz</span><br><span class="line"></span><br><span class="line">$ cd php-7.0.32</span><br><span class="line"></span><br><span class="line">$ ./configure --prefix=/usr/local/php7.0 --with-config-file-path=/usr/local/php7.0/etc --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-mysqli --with-pdo-mysql --with-iconv-dir --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib  --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-mbstring --enable-ftp --with-gd --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap  --with-gettext --disable-fileinfo --enable-maintainer-zts</span><br><span class="line"></span><br><span class="line">$ make</span><br><span class="line"></span><br><span class="line">$ make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以根据自己的需求进行<code>./configure</code>，上面的配置是比较全面的，几乎所有用到的扩展都安装了。如果有些扩展不需要可以使用without或disable排除，比如<code>--without-pear</code></p>
<p>安装完成，需要做一下配置，进入php7.0的安装目录<code>/usr/local/php7.0</code>。复制一下php配置文件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/php7.0</span><br><span class="line">cd  etc</span><br><span class="line">cp php-fpm.conf.default php-fpm.conf</span><br><span class="line">cp php-fpm.d/www.conf.default php-fpm.d/www.conf</span><br></pre></td></tr></table></figure>
<p>看一下<code>php-fpm.d/www.conf</code> 里面找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user = www</span><br><span class="line">group = www</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>给user和group配置成现有的用户、用户组。或者根据配置创建<code>www</code>账号和用户组也可以<br>查找 <code>listen</code>如果没有<code>listen</code>配置，自己添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen = 127.0.0.1:9000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后讲php-fpm运行起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/php7.0/sbin/php-fpm</span><br></pre></td></tr></table></figure>

<h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>因为php listen配置的是监听9000端口，所有nginx配置要是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ \.php &#123;</span><br><span class="line">                if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27; always;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27; always;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, PUT, DELETE, OPTIONS&#x27; always;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Origin, DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type, Accept, authKey, sessionId, business,shop&#x27;;</span><br><span class="line">                    #add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;*&#x27;;</span><br><span class="line">                    add_header &#x27;Access-Control-Max-Age&#x27; 1728000;</span><br><span class="line">                    add_header &#x27;Content-Type&#x27; &#x27;text/plain charset=UTF-8&#x27;;</span><br><span class="line">                    add_header &#x27;Content-Length&#x27; 0;</span><br><span class="line"></span><br><span class="line">                    return 204;</span><br><span class="line">                &#125;</span><br><span class="line">                include snippets/fastcgi-php.conf;</span><br><span class="line"></span><br><span class="line">                # With php7.0-cgi alone:</span><br><span class="line">                fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">        #       # With php7.0-fpm:</span><br><span class="line">        #       fastcgi_pass unix:/run/php/php7.2-fpm.sock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装其他插件"><a href="#安装其他插件" class="headerlink" title="安装其他插件"></a>安装其他插件</h2><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis是常用软件，redis官方为php提供了插件。可以使用pecl安装，也可以自己编译。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/php7.0/bin/pecl install redis</span><br></pre></td></tr></table></figure>
<p>安装完成后会有提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Build process completed successfully</span><br><span class="line">Installing &#x27;/usr/local/php7.0/lib/php/extensions/no-debug-zts-20151012/redis.so&#x27;</span><br><span class="line">install ok: channel://pecl.php.net/redis-5.3.2</span><br><span class="line">configuration option &quot;php_ini&quot; is not set to php.ini location</span><br><span class="line">You should add &quot;extension=redis.so&quot; to php.ini</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是后需要在php.ini里添加<code>extension=redis.so</code>如果没哟php.ini文件，就在php配置目录创建一个。</p>
<p>添加配置后需要重启php-fpm，然后<code>nginx -s reload</code>，redis就生效了。</p>
<h3 id="mcrypt"><a href="#mcrypt" class="headerlink" title="mcrypt"></a>mcrypt</h3><p>这次用编译方式，首先下载源码包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://pecl.php.net/get/mcrypt-1.0.1.tgz</span><br></pre></td></tr></table></figure>
<p>使用phpize处理一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar zxvf mcrypt-1.0.1.tgz</span><br><span class="line">cd mcrypt-1.0.1</span><br><span class="line">/usr/local/php7.0/bin/phpize</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来开始编译，编译需要制定php-config的路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --with-php-config=/usr/local/php7.0/bin/php-config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完成，出现如下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Installing shared extensions:     /usr/local/php7.0/lib/php/extensions/no-debug-zts-20151012/</span><br></pre></td></tr></table></figure>
<p>在php.ini中加入编译的插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extension=mcrypt.so</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装完插件，重启php-fpm和nginx就可以了</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装php最方便的方式</title>
    <url>/2020/12/13/2020/ubuntu%E5%AE%89%E8%A3%85php%E6%9C%80%E6%96%B9%E4%BE%BF%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<ol>
<li>添加ppa源</li>
</ol>
<p>sudo add-apt-repository ppa:ondrej&#x2F;php</p>
<ol start="2">
<li>升级源</li>
</ol>
<p>sudo apt-get update &amp;&amp; sudo apt-get upgrade</p>
<p>接下来就可以安装各种不同版本了</p>
<ol start="3">
<li>sudo apt-get install php7.0 php7.0-mysql libapache2-mod-php7.0 php7.0-mcrypt php7.0-curl</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>微信开发unionid详解</title>
    <url>/2020/09/23/2020/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91unionid%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="unionid概况"><a href="#unionid概况" class="headerlink" title="unionid概况"></a>unionid概况</h2><p>微信开发过程中，经常会遇到，一个企业有多个小程序和公众号，在不同的小程序和公众号中，会有不同的openid。如果想要确定是同一个人，就需要用到unionid机制。</p>
<p>官方关于unionid的说明是这样的</p>
<p>公众号文档的描述</p>
<blockquote>
<p>开发者可通过OpenID来获取用户基本信息。特别需要注意的是，如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号，用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。</p>
</blockquote>
<p>小程序文档的描述</p>
<blockquote>
<p>如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。</p>
</blockquote>
<span id="more"></span>

<h2 id="开放平台"><a href="#开放平台" class="headerlink" title="开放平台"></a>开放平台</h2><p>提到unionid就不得不提微信开放平台了。</p>
<p><a href="https://open.weixin.qq.com/">https://open.weixin.qq.com</a> 微信开放平台，刚开始是为了让开发商，可以支持很多的公众号，而产生的。原因是使用appid和appsecret的方式对于。小程序或公众号的所有者来说太危险，相当于暴露了用户名和秘密。为了安全，出现了开放平台，授权时可以灵活的控制授予哪些权限。开放平台相比appid和appsecret方式还有很多特权。对于开发者是很好的。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>官方的说明比较简单，开发过程中会遇到不少的坑。下面说一下注意事项</p>
<ol>
<li>公众号开发时只有用户关注了公众号，才可以获取到unionid</li>
</ol>
<p>如果用户不关注或取消关注公众号，是无法获取unionid的。</p>
<ol start="2">
<li>必须将公众号或小程序绑定到开放平台才可以获取unionid</li>
</ol>
<p>进入开放平台，点管理中心。可以看到移动应用、网站应用、公众账号、小程序、第三方平台这些菜单。</p>
<p>如果要绑定公众号就，点击<code>公众账号</code>菜单，然后点击<code>绑定公众号</code>，填写公众账号、密码、验证码，点下一步，然后需要管理员扫码。之后就绑定了。</p>
<p>小程序的流程也差不多。</p>
<ol start="3">
<li>一个公众号或小程序只能绑定一个开放平台</li>
</ol>
<p>这与unionid的生成机制有关，unionid是用户与开放平台之间的对应关系，如果绑定多个会造成混乱。</p>
<h3 id="unionid的值为什么不同"><a href="#unionid的值为什么不同" class="headerlink" title="unionid的值为什么不同"></a>unionid的值为什么不同</h3><p>第三方开放平台，开发过程中会遇到，同一个用户，在两个公众号下，获取到的unionid不同的情况。这种情况发送的原因是，两个公众号绑定到了不同的开放平台账号造成的。</p>
<p>不管是小程序还是公众号，一个开放平台的是有绑定限制的。比如小程序<code>相同主体：上限50个，绑定次数不限。不同主体：上限5个，本月还可以绑定5次。</code>，公众号<code>相同主体：上限50个，绑定次数不限。不同主体：上限5个，本月还可以绑定5次。</code><br>所以一般情况下，会让客户自己注册一个开放平台，然后把客户的公众号和小程序绑定上去。</p>
<p>比如<code>客户A</code>注册开放平台是<code>平台A</code>，注册小程序是<code>小程序A</code>，注册公众号是<code>公众号A</code>；<code>客户B</code>注册开放平台是<code>平台B</code>，注册小程序是<code>小程序B</code>，注册公众号是<code>公众号B</code>。</p>
<p>他们各自绑定各自的开放平台。<code>小程序A</code>和<code>公众号A</code>绑定<code>平台A</code>，<code>小程序B</code>和<code>公众号B</code>绑定<code>平台B</code>。</p>
<p>开发过程中会出现同一个微信用户，在<code>公众号A</code>和<code>小程序A</code>获取到的unionid是一样的比如都是；<code>公众号B</code>和<code>小程序B</code>中获取的unionid也是一样的。但是<code>公众号A</code>和<code>公众号B</code>获取的unionid不一样。</p>
<p>造成这样的原因是因为绑定的开放平台不用，每个unionid的产生，其实是用户跟开放平台的唯一对应关系。<code>小程序A</code>和<code>公众号A</code>绑定<code>平台A</code>因此他们的unionid一样，<code>公众号A</code>和<code>公众号B</code>绑定在不同的开放平台所以取到的unionid不一样。</p>
<p>还有一点要注意，开发公司A的开放平台<code>公司A平台</code>，同一个平台下创建多个<code>第三方平台</code>用于开发，这些<code>第三方平台</code>也会取到相同的unionid。</p>
<p>重要的事情说三遍<code>unionid与绑定的平台有关，unionid与绑定的平台有关，unionid与绑定的平台有关</code>，unionid其实是用户和开放平台账户的对应关系。</p>
<blockquote>
<p>有一点值得注意：如果有个开发公司B，在开放平台<code>公司B平台</code>，有公众号A授权的情况下，取到的unionid与<code>公司A平台</code>获取的公众号A的unionid也会一样。这其实也是为了便于微信做大数据 分析，知道一个用户所有行为。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developers.weixin.qq.com/doc/offiaccount/User_Management/Get_users_basic_information_UnionID.html#UinonId">https://developers.weixin.qq.com/doc/offiaccount/User_Management/Get_users_basic_information_UnionID.html#UinonId</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>unionid</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊kafka</title>
    <url>/2020/08/22/2020/%E8%81%8A%E8%81%8Akafka/</url>
    <content><![CDATA[<p>为了便于理解kafka，先了解一下消息队列以及通讯模式。首先先了解两个名词</p>
<ul>
<li>数据生产者 产生数据的程序或服务</li>
<li>数据消费者 处理数据的程序或服务</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>简单的说就是个数据集散地，数据生产方把数据放到消息队列，然后消费方从队列中获得数据进行处理。<br>我们把消息队列比作超市，超市的供货商就相当于数据生产者，超市顾客就是数据消费者了。</p>
<p>使用消息队列可以让我们解决三大问题</p>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>假设没有超市，我们买菜直接从供货商手里买的话，我们如果要买不同的菜就需要联系好多的供货商。每个供货商又要给很多人供货，这是很麻烦的。超市的出现就解决了这个麻烦，所有的供货商只需要把才运送到超市这一个地方，顾客也只需要去超市这一个地方。就可以买到很多菜。<br>数据也是一样的，不同用户的数据都进入消息队列，然后服务，只需要从队里中获取数据进行处理就可以了。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>没有超市的情况下，我们跟供货商买东西，要两个人都有时间才可以，供货商没时间送货，或者消费者没时间在家接货都无法达成交易。但是有了超市，供货商不用等消费者在家，消费者也不用等供货商有时间送货。大家都是随时去超市购买即可。<br>数据也一样，数据生产方随时可以产生数据，而不用担心处理数据的服务是否空闲，服务也不用立即对请求进行应答。如果服务异常退出了，等再次启动后可以消息队列中获取数据进行处理。</p>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>没有超市的情况下，如果我们买了10种菜，供货商同时到了，很有可能你拿不了。方路边？万一丢了怎么办呢。有了超市就可以一次买一点多次购买多方便。<br>数据也一样，最容易出现这种情况的就是秒杀，大量的数据同一时间汇入，这时候很容易让服务崩掉。有了消息队列，咱们就可以轻松化解了，所有的数据先进入消息队列。后台服务从队列中获取数据处理。</p>
<h2 id="通讯模式"><a href="#通讯模式" class="headerlink" title="通讯模式"></a>通讯模式</h2><h3 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h3><p>前面介绍消息队列举的例子中，都是顾客主动去超市购买商品，这种方式，我们称之为点对点方式。这种模式消费者需要主动获取数据，好处是比较灵活。缺点也很明显，数据消费者或许消息不够及时。有可能你去买菜的时候，菜已经卖没了。</p>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>为了让消费者买到好的菜，超市推出了送货上面服务，供货商将菜送来的时候，超市会把菜打包好送到您手里。这样就不会买不到菜了。<br>这种主动送达的方式叫做发布订阅模式，数据发送到消息队列时。消息队列会主动把数据推送给数据消费者。</p>
<h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><p>消息队列软件有很多种，kafka就是其中的一种。它是Linkedin公司开发，现在已经贡献给了apache基金会。kafka的创始人还在kafka的基础上，开发了好多周边软件，用于数据流转处理。如kafka connect等</p>
<p>kafka启动后默认使用9092端口，想这个端口发送信息，kafka就可以收到了。为了便于操作，kafka自带有Producer和Consumer的命令行工具用于简单测试</p>
<p>使用kafka必须先了解一下kafka的几个关键术语。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>Producer即生产者，消息的产生者，它将消息发送到kafka中。安装包内有命令行工具，在java、python、php等语言也都有响应的sdk。使用Producer对象可以将消息发送到kafka服务。发送服务时会指定Topic。</p>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>消息即数据，生产者发送一次数据，会产生一条消息。</p>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>消息主题，可以理解为消息分类。比如订单业务用order，订单服务就可以只接收order topic下的消息进行处理，这是非常方便的。避免了接收无用的消息。</p>
<h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>Topic的分区，可以理解为文件夹，当数据特别多的时候如果把数据再次进行归类存储，可以有效的提高读写效率。比如有一万个文件，放在一个文件夹中查找就比较慢，如果按照哈希分散到a-z的26个文件夹中，那每个文件夹中存储的文件数量就是1&#x2F;26。当我们发现要查找的文件第一个字母是a，就直接去a文件夹下。这样就提高了查找速度。</p>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>kafka实例，可以简单理解为kafka的消息容器。每个kafka集群内的broker都有一个不重复的编号。每台服务器上可以有一到多个kafka实例，为了便于理解，我们假设一台服务器上有一个kafka实例。这样你也可以理解为一个broker等于一台服务器。</p>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>topic的副本，他存放在kafka实例（broker）上。注意一下几点</p>
<ul>
<li>在kafka中默认副本的最大数量是10个</li>
<li>副本的数量不能大于Broker的数量</li>
<li>follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。<br>这样当主分区(Leader Partition)出现故障挂掉的时候，其中一份副本会转正为主分区，让业务可以正常使用</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者，即消息的消费方，是消息的出口。安装包内有命令行工具，在java、python、php等语言也都有响应的sdk。使用Consumer对象可以接收或获取kafka中的数据。</p>
<h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>我们可以将多个消费者组成一个消费者组，一个topic可以被多个消费组消费。但是消费组中多人同时消费一个topic时，每个分区只能有一个人消费。消费组中的消费者数量不要超过这个topic的Partition数量</p>
<h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>咱们有5台服务器，每台服务器一个kafka实例（broker）。<br>这时候我们设置副本数量要小于5（1是主分区，剩余4个borker可用作副本），我们设置为4<br>假设咱们设置分区（Partition）数是10</p>
<p>生产了个order的topic，我们有系统A和系统B都会用到订单数据。</p>
<p>系统A用 group-A消费者的数量不能超过5，如果超过了，会有一个消费这始终借不到数据。group-A中每个消费者都从各自的分区（Partition）中获取数据，他们每个人的数据是不重复的。<br>系统B如果使用group-A，那么它消费的一些数据，系统A会无法消费。因此如果想要两个系统都获得完整的数据。就需要系统B更换分组，比如使用group-B。这样两个系统互不干扰，都可以拿到消息队列中的全部数据。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Commit log 使用说明</title>
    <url>/2019/10/11/2019/Commit%20log%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="什么是git-commit-log"><a href="#什么是git-commit-log" class="headerlink" title="什么是git commit log"></a>什么是git commit log</h2><p><code>git commit log</code>其实就是根据咱们提交的<code>commit message</code>信息进行提取，用来生成更新日志的功能。<br>既然是要生成，那就一定要有一个格式，否则程序很难自动化的处理。<br>目前比较常用的是<a href="http://link.zhihu.com/?target=https://github.com/angular/angular.js/blob/master/DEVELOPERS.md%23-git-commit-guidelines">Angular 团队的规范</a>,他的格式也比较简洁。</p>
<span id="more"></span>

<h2 id="规范说明"><a href="#规范说明" class="headerlink" title="规范说明"></a>规范说明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<p>一个完整的<code>commit message</code>由header、body和footer构成，他们中间用一个空行分割。其中header是必须填写的，body和footer是可选项。</p>
<p>以上面的格式为例：</p>
<ol>
<li>header说明<br><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code>这是header，它包括了type、scope和subject。注意书写<code>commit message</code>时不要忽略括号和冒号，这些符号。</li>
</ol>
<ul>
<li>type是类型,可以是下面类型中的一个<ul>
<li>feat: 新特性</li>
<li>fix: 修改问题</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理.</li>
</ul>
</li>
<li>scope: 用于说明 commit 影响的范围，比如数据层、控制层、视图层、router等等，视项目不同而不同</li>
<li>subject: 是 commit 目的的简短描述，不超过50个字符</li>
</ul>
<blockquote>
<p>如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。</p>
</blockquote>
<ol start="2">
<li><p>body<br>Body 部分是对本次 commit 的详细描述，可以分成多行。</p>
</li>
<li><p>footer<br>Footer 部分只用于两种情况，一种是不兼容变动，另一种是解决bug，关闭issue。</p>
<ul>
<li>不兼容变动<br>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。</li>
<li>关闭 Issue<br>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。关闭一个issue可以<code>Closes #234</code>，也可以关闭多个issue<code>Closes #123, #245, #992</code></li>
</ul>
</li>
<li><p>Revert<br>如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revert: feat(pencil): add &#x27;graphiteWidth&#x27; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>
<p>Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。</p>
<p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。</p>
</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>新增功能实例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feat(address):新增地址列表接口  </span><br><span class="line"></span><br><span class="line">涉及文件如下</span><br><span class="line">AddressControl.java 新增地址模块控制器       </span><br><span class="line">AddressService.java 新增地址模块Service</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE：                       </span><br><span class="line">-与前一个版本相比移除了不需要自字段XXX </span><br><span class="line">+增加了新字段XXX</span><br></pre></td></tr></table></figure></li>
<li>bug修复实例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fix(user):修复了添加用户不验证用户名唯一性的问题   </span><br><span class="line"></span><br><span class="line">修复bug涉及改动文件如下</span><br><span class="line">UserModel.java 模型中增加了属性验证     </span><br><span class="line">UserService.java 修改过了添加用户逻辑 </span><br><span class="line"></span><br><span class="line">Closes #234 </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="生成change-log"><a href="#生成change-log" class="headerlink" title="生成change log"></a>生成change log</h2><p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。生成文档一般包含3部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">New features</span><br><span class="line">Bug fixes</span><br><span class="line">Breaking changes.</span><br></pre></td></tr></table></figure>
<p>首先我们需要安装一个生成工具<code>npm install -g conventional-changelog-cli</code>，</p>
<blockquote>
<p>网上说用<code>npm install -g conventional-changelog-cli</code>，但不知道为什么安装后提示找不到命令</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">cd my-project</span><br><span class="line">touch CHANGELOG.md</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w</span><br></pre></td></tr></table></figure>
<p>这样就可以看到change log了，log会打印到屏幕上，同时也会写入到<code>CHANGELOG.md</code>中。</p>
<p>上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。</p>
<p>如果你想生成所有发布的 Change log，要改为运行下面的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure>
<p>为了方便使用，可以将其写入package.json的scripts字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后，直接运行<code>npm run changelog</code>命令即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a><br><a href="https://github.com/conventional-changelog-archived-repos/validate-commit-msg">https://github.com/conventional-changelog-archived-repos/validate-commit-msg</a><br><a href="https://github.com/conventional-changelog-archived-repos/conventional-changelog-cli">https://github.com/conventional-changelog-archived-repos/conventional-changelog-cli</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git commit</tag>
        <tag>change log</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ssh登录超时问题</title>
    <url>/2020/09/30/2020/%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>加上<code>-o ServerAliveInterval=60</code>参数就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=60 root@192.168.1.1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>解决深度终端链接远程后假死问题</title>
    <url>/2020/02/12/2020/%E8%A7%A3%E5%86%B3%E6%B7%B1%E5%BA%A6%E7%BB%88%E7%AB%AF%E9%93%BE%E6%8E%A5%E8%BF%9C%E7%A8%8B%E5%90%8E%E5%81%87%E6%AD%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这是最近才出现的问题，忽然发现，深度终端链接远程服务器后，过一会就假死了。还以为是不小心安了ctrl+s，于是用ctrl+q也无法解开。依然不能输入任何内容。链接状态是保持的，但就是假死了。</p>
<p>在网上搜索了一下找到了解决办法。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以修改配置文件, 在<code>~/.bash_profile</code> 或者<code>~/.bashrc</code>的配置文件里面加上下面的参数了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stty -ixon</span><br></pre></td></tr></table></figure>
<p>保持退出，执行下面的命令让配置生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source  .bashrc</span><br></pre></td></tr></table></figure>
<p>这样就不会出现假死了。</p>
<p>还有一种方式，链接ssh之前增加一个<code>-o ServerAliveInterval=60</code>参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=60 root@192.168.0.2</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现假死主要是，由于一段时间不活动，终端进行了休眠。但是我们没法唤醒造成的。终端有一个软件流控制(XON&#x2F;XOFF flow control)的功能，具体就是当client(terminal emulator), 也就是常用的终端模拟器无法接受更多的数据的时, 终端会发送一个 <code>XOFF</code> 信号 告诉发送数据端暂停发送, 直到收到<code>XON</code>信号，其中发送的 <code>XOFF</code> 是告诉内核的 tty 驱动将正在发送数据的进程设置为休眠状态, 直到 tty 驱动发送 <code>XON</code> 告诉内核恢复进程, 就好像它从来没有停过一样。</p>
<p>这就是为什么增加一个 <code>stty -ixon</code>可以解决问题的原因</p>
<p>默认情况下，Ctrl-s会启用终端的滚动锁定, 此时禁用终端模拟器的滚动功能 (通过发送 <code>XOFF</code> 信号暂停软件的输出 )，终端软件没有任何输出，造成假死的现象，一般情况都是无意识按下了ctrl+s快捷键而已。相应的，Ctrl-q 会禁用滚动锁定, 恢复终端滚动 (通过发送 <code>XON</code> 信号来恢复软件的输出). </p>
<p>linux下终端ctrl+z命令会将当前任务切换到后台执行，就无法看到了，可以使用fg命令恢复至前台</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/guochaoxxl/p/10428991.html">https://www.cnblogs.com/guochaoxxl/p/10428991.html</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次postgresql迁移经历</title>
    <url>/2020/09/29/2020/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1postgresql%E8%BF%81%E7%A7%BB%E7%B2%BE%E5%8A%9B/</url>
    <content><![CDATA[<p>数据库服务器硬盘满了，需要将数据迁移到另一台数据库，做一下记录</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>去postgresql官网<a href="https://www.postgresql.org/download/%EF%BC%8C%E9%80%89%E6%8B%A9%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AFubuntu%E3%80%82">https://www.postgresql.org/download/，选择操作系统，我这里选择的是ubuntu。</a><br>然后根据说明进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Create the file repository configuration:</span><br><span class="line">sudo sh -c &#x27;echo &quot;deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main&quot; &gt; /etc/apt/sources.list.d/pgdg.list&#x27;</span><br><span class="line"></span><br><span class="line"># Import the repository signing key:</span><br><span class="line">wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"># Update the package lists:</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"># Install the latest version of PostgreSQL.</span><br><span class="line"># If you want a specific version, use &#x27;postgresql-12&#x27; or similar instead of &#x27;postgresql&#x27;:</span><br><span class="line">sudo apt-get -y install postgresql</span><br></pre></td></tr></table></figure>
<p>值得注意的是，安装时一定要选择与老数据库相同的版本</p>
<p>安装完成后，就可以会自动添加一个postgres的系统用户，该用户没有密码如果想要密码可以自行设置</p>
<span id="more"></span>

<h2 id="登录postgresql，配置密码"><a href="#登录postgresql，配置密码" class="headerlink" title="登录postgresql，配置密码"></a>登录postgresql，配置密码</h2><p>刚安装完，一定要使用<code>postgres</code>用户才可以登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo su - postgres</span><br><span class="line">$ psql</span><br><span class="line">psql (9.6.19)</span><br><span class="line">SSL 连接（协议：TLSv1.2，密码：ECDHE-RSA-AES256-GCM-SHA384，密钥位：256，压缩：关闭)</span><br><span class="line">输入 &quot;help&quot; 来获取帮助信息.</span><br><span class="line"></span><br><span class="line">postgres=# </span><br></pre></td></tr></table></figure>
<p>出现<code>postgres=#</code>标示已经登录到数据库了。非常简单。</p>
<p><code>psql</code>命令其实是相当于<code>psql -U postgres -h localhost</code>，因为<code>psql</code>如果不指定用户会使用与系统账户相同的数据库账号。<br>一定要注意哦，系统中的<code>postgres</code>和数据库的<code>postgres</code>虽然名字一样，但不是一回事一个属于系统，一个数据数据库。<br>接下来给数据库的<code>postgres</code>账号设置密码，这样我们就可以在不切换系统<code>postgres</code>账号的情况下登录了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# alter user postgres with password &#x27;123456&#x27;</span><br></pre></td></tr></table></figure>
<p>这样就设置好了密码。</p>
<h2 id="配置外网访问"><a href="#配置外网访问" class="headerlink" title="配置外网访问"></a>配置外网访问</h2><p>默认postgresql是不允许外网访问的，我们需要修改两个文件。</p>
<ol>
<li>pg_hba.conf：配置数据库的访问权限</li>
<li>postgresql.conf：配置数据库服务的相关参数</li>
</ol>
<p>首先我们退出数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# \q</span><br></pre></td></tr></table></figure>
<p>然后切换回root账号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure>
<p>接下来修改配置文件，修改<code>pg_hba.conf</code>，增加一条<code>host  all  all  0.0.0.0/0   md5</code>规则</p>
<p>修改<code>postgresql.conf</code> 找到<code>#listen_addresses=’localhost’</code>，修改成<code>listen_addresses=’*’</code></p>
<p>修改完成重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service postgres restart</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在其他电脑上用<code>psql -h serverip -U postgres</code>登录数据库管理了</p>
<h2 id="修改数据存储位置"><a href="#修改数据存储位置" class="headerlink" title="修改数据存储位置"></a>修改数据存储位置</h2><ol>
<li><p>首先需要停止服务执行<code>service postgresql stop</code></p>
</li>
<li><p>将原来的数据库目录复制新目录<br>打开<code>postgresql.conf</code>文件找到<code>data_directory</code>看一下当前数据库存放目录</p>
<p>将目录复制到想保持的地方，不可以使用cp那样会缺少属性，无法启动数据库，需要用<code>rsync</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -av /var/lib/postgresql/9.6/main /mnt/main</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  <code>/var/lib/postgresql/9.6/main</code>是<code>data_directory</code>中个默认的设置，将其修改为新目录<code>/mnt/main</code><br>3. 重启服务<code>service postgresql</code></p>
<p>这样数据存储位置就生效了</p>
<h2 id="导入老数据"><a href="#导入老数据" class="headerlink" title="导入老数据"></a>导入老数据</h2><p>执行命令<code>psql -h localhost -U postgres 数据库名 &lt; 备份文件</code> 导入数据</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>超好用的抓包工具mitmproxy</title>
    <url>/2020/10/22/2020/%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7mitmproxy/</url>
    <content><![CDATA[<p>mitmproxy是一个非常好用的代理工具</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>最快速的安装莫过于执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install mitmproxy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于mitmproxy是基于python开发的，所以安装mitmproxy的同时，也会自动安装上python3。</p>
<p>如果本地已经有了python3.6以上的版本，可以用pip进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install mitmproxy</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>要启动 mitmproxy 用 mitmproxy、mitmdump、mitmweb 这三个命令中的任意一个即可，这三个命令功能一致，且都可以加载自定义脚本，唯一的区别是交互界面的不同。<br>mitmproxy默认监听端口是8080</p>
<ul>
<li><p>mitmproxy 命令启动后，会提供一个命令行界面，用户可以实时看到发生的请求，并通过命令过滤请求，查看请求数据。</p>
</li>
<li><p>mitmweb 命令启动后，会提供一个 web 界面，用户可以实时看到发生的请求，并通过 GUI 交互来过滤请求，查看请求数据。</p>
</li>
<li><p>mitmdump 命令启动后——你应该猜到了，没有界面，程序默默运行，所以 mitmdump 无法提供过滤请求、查看数据的功能，只能结合自定义脚本，默默工作</p>
</li>
</ul>
<h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>比如想要对手机内容进行抓包。<br>要确保电脑和手机在一个wifi网络内，以小米手机为例，长安wifi，进入wifi详情，设置代理，选择手动，主机名设置为电脑的ip，端口号设置为8080（mitmproxy默认监听端口）。点击右上角的对号。保存网络设置就可以了。<br>电脑执行mitmproxy或mitmweb命令。就可以看到手机的每一次网络请求了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>使用 mitmproxy + python 做拦截代理：<a href="https://blog.wolfogre.com/posts/usage-of-mitmproxy/">https://blog.wolfogre.com/posts/usage-of-mitmproxy/</a><br>mitmproxy 官方文档：<a href="https://docs.mitmproxy.org/stable/">https://docs.mitmproxy.org/stable/</a><br>mitmproxy 脚本示例：<a href="https://github.com/mitmproxy/mitmproxy/tree/master/examples">https://github.com/mitmproxy/mitmproxy/tree/master/examples</a><br>维基百科 - 代理服务器：<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">https://zh.wikipedia.org/wiki/代理服务器</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mitmproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>让nginx支持flv文件播放</title>
    <url>/2020/03/25/2020/%E8%AE%A9nginx%E6%94%AF%E6%8C%81flv%E6%96%87%E4%BB%B6%E6%92%AD%E6%94%BE/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近做小程序直播，为了简单测试需要用到<code>live-player</code>播放一个flv文件。服务器上用的nginx。把flv文件放到目录下访问，居然无法播放。查看了一下配置才发现，nginx不支持flv，需要响应的插件。</p>
<h2 id="初次安装"><a href="#初次安装" class="headerlink" title="初次安装"></a>初次安装</h2><p>如果是编译安装的非常简单，只需要在<code>configure</code>时添加<code>--with-http_flv_module</code>就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./configure  --with-http_flv_module </span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>专业就安装完成了。</p>
<h2 id="对已安装的nginx，添加模块"><a href="#对已安装的nginx，添加模块" class="headerlink" title="对已安装的nginx，添加模块"></a>对已安装的nginx，添加模块</h2><p>如果已经安装过nginx，比如使用apt或yum安装过了。该怎么办呢？</p>
<span id="more"></span>

<h3 id="1-首先去nginx官网下载一个相同版本的nginx源码包"><a href="#1-首先去nginx官网下载一个相同版本的nginx源码包" class="headerlink" title="1. 首先去nginx官网下载一个相同版本的nginx源码包"></a>1. 首先去nginx官网下载一个相同版本的nginx源码包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nginx -v</span><br><span class="line">nginx version: nginx/1.10.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意是小写的<code>v</code>查看nginx版本，然后去官网下载<code>http://nginx.org/en/download.html</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.10.3.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压源码包,进入目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar zxvf nginx-1.10.3.tar.gz</span><br><span class="line">cd nginx-1.10.3</span><br></pre></td></tr></table></figure>

<h3 id="2-用与当前nginx编译参数的基础上进行编译"><a href="#2-用与当前nginx编译参数的基础上进行编译" class="headerlink" title="2. 用与当前nginx编译参数的基础上进行编译"></a>2. 用与当前nginx编译参数的基础上进行编译</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nginx -V</span><br><span class="line">nginx version: nginx/1.13.12</span><br><span class="line">built with OpenSSL 1.1.0h  27 Mar 2018</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --with-cc-opt=&#x27;-g -O2 -fdebug-prefix-map=/build/nginx-THAKdv/nginx-1.13.12=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2&#x27; --with-ld-opt=&#x27;-Wl,-z,relro -Wl,-z,now -fPIC&#x27; --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --modules-path=/usr/lib/nginx/modules --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_v2_module --with-http_dav_module --with-http_slice_module --with-threads --with-http_addition_module --with-http_geoip_module=dynamic --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_xslt_module=dynamic --with-stream=dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-mail=dynamic --with-mail_ssl_module --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-auth-pam --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-dav-ext --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-echo --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-upstream-fair --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-subs-filter</span><br></pre></td></tr></table></figure>
<p>注意是大写的<code>V</code>，<code>configure arguments:</code>后面就是当前nginx的编译参数，接下来在此基础上添加<code>--with-http_flv_module</code>参数进行编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./configure --with-cc-opt=&#x27;-g -O2 -fdebug-prefix-map=/build/nginx-THAKdv/nginx-1.13.12=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2&#x27; --with-ld-opt=&#x27;-Wl,-z,relro -Wl,-z,now -fPIC&#x27; --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --modules-path=/usr/lib/nginx/modules --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_v2_module --with-http_dav_module --with-http_slice_module --with-threads --with-http_addition_module --with-http_geoip_module=dynamic --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_xslt_module=dynamic --with-stream=dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-mail=dynamic --with-mail_ssl_module --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-auth-pam --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-dav-ext --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-echo --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-upstream-fair --add-dynamic-module=/build/nginx-THAKdv/nginx-1.13.12/debian/modules/http-subs-filter --with-http_flv_module</span><br></pre></td></tr></table></figure>
<p>最后加入了<code>--with-http_flv_module</code>参数，编译过程中可能会报错，大都是依赖错误，比如缺少gd库，如果是ubuntu，安装时库的命名一般是lib开头。比如GD库，用<code>apt install libgd-dev</code>。具体问题具体分析。</p>
<p>config处理完成执行<code>make</code>进行编译，注意一定不要执行<code>make install</code>，会覆盖原有程序的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>等待编译完成，进行最后一步也是最重要的工作。将编译好的nginx复制到当前nginx所在目录下，进行替换。</p>
<h3 id="3-替换编译文件"><a href="#3-替换编译文件" class="headerlink" title="3. 替换编译文件"></a>3. 替换编译文件</h3><p>替换nginx 可执行文件前，我们做一下备份。<br>重新编译后的nginx 可执行文件在 objs 目录下，我们只需要将 nginx 文件替换即可。<br>如果通过apt命令安装的nginx，那么nginx文件在<code>/usr/sbin/nginx</code>。如果是通过手动编译，可以查看<code>--prefix</code>参数指定的目录，在里面找到<code>sbin</code>目录，里面就是我们要替换的nginx。<br>这里以apt安装为例。<br>停止nginx服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop nginx.service</span><br></pre></td></tr></table></figure>
<p>备份老nginx，复制新编译的nginx进行替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo cp /usr/sbin/nginx /usr/sbin/nginx.bak</span><br><span class="line">$ cp ./objs/nginx /usr/sbin/</span><br></pre></td></tr></table></figure>
<p>重启nginx服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start nginx.service</span><br></pre></td></tr></table></figure>
<p>大工告成。</p>
<h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><p>nginx安装完了，接下来配置虚拟主机支持flv就可以了，很简单。在需要配置的虚拟主机<code>server</code>里添加一下flv配置就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">  ...</span><br><span class="line">   location ~ \.flv$ &#123;</span><br><span class="line">	  flv;</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/zan110120/article/details/95178449">https://blog.csdn.net/zan110120/article/details/95178449</a><br><a href="https://blog.csdn.net/smallnetvisitor/article/details/84714952">https://blog.csdn.net/smallnetvisitor/article/details/84714952</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>flv</tag>
      </tags>
  </entry>
  <entry>
    <title>GIT批量删除远程标签</title>
    <url>/2019/05/30/2019/GIT%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h2 id="查看远程所有标签"><a href="#查看远程所有标签" class="headerlink" title="查看远程所有标签"></a>查看远程所有标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git ls-remote --tags</span><br><span class="line">From git@github0123:jeremy0123/fetch.git</span><br><span class="line">30f4e5cdfef2539b5e156a607f365fb457f309a4        refs/tags/v0.1</span><br><span class="line">0efbfd03ed4b09647ef8a32db9c0a075f7d7dbeb        refs/tags/v0.2</span><br><span class="line">6944954ffa18df994365e53e96d3826a3953890b        refs/tags/v0.2^&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>注意：refs/tags/v0.2^&#123;&#125;表示v0.2是含附注的标签。</code><br>另外，参数–tags可以简化为-t；–heads会获取远程仓库的分支信息。如果没有任何参数，将获取所有的分支和标签信息。</p>
<span id="more"></span>

<h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete tag v0.1</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/v0.1</span><br></pre></td></tr></table></figure>
<h2 id="删除远程所有标签"><a href="#删除远程所有标签" class="headerlink" title="删除远程所有标签"></a>删除远程所有标签</h2><p>先获取远程所有标签，然后用<code>awk</code>获取所有标签名，再用<code>sed</code>去掉带有<code>^&#123;&#125;</code>的标签，最后执行用<code>git push</code>删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git ls-remote --tags | awk &#x27;/(.*)(\s+)(.*)$/ &#123;print &quot;:&quot; $2&#125;&#x27; | sed &#x27;/&#125;$/&#x27;d |xargs git push origin</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>tag</tag>
      </tags>
  </entry>
  <entry>
    <title>docker环境下php使用指南</title>
    <url>/2019/05/15/2019/docker%E7%8E%AF%E5%A2%83%E4%B8%8Bphp%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>最近由于业务原因，需要将 php7.0 升级到 7.2。升级要考虑一下几点<br>要满足以下需求</p>
<ol>
<li>php7.0 和 7.2 要共存，以免升级 7.2 以后出现问题，及时切换回来。</li>
<li>升级操作要简单，服务器数量比较多，原生方式安装太过复杂，操作步骤太多，就算携程 shell 脚本，维护起来也比较麻烦</li>
<li>nginx 保持原样，只对项目相关的配置文件做简单调整即可。如果 nginx 变更日志处理等模块都收到牵连。</li>
</ol>
<p>考虑到上面的因素，用 docker 显然是非常符合的。于是就开启了踩坑之旅。<br>主要遇到了两个问题，一个是<code>502</code>，还有一个是<code>File not found</code>。下面进行分析</p>
<span id="more"></span>

<h2 id="502问题解决"><a href="#502问题解决" class="headerlink" title="502问题解决"></a>502问题解决</h2><p>502一看就是nginx跟php的通讯出现了问题。检查原因</p>
<ol>
<li>docker是否正常启动</li>
<li>是都对端口做了映射<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker启动命令</span><br><span class="line">docker run -p 9000:9000 -d --name myphp -v /var/www/html/:/var/www/html/ --privileged=true -d php:7.2-fpm</span><br></pre></td></tr></table></figure>
先用<code>docker container ls</code>查看是否已经启动容器，如果列表中没有，说明启动失败了<br>如果容器正常启动，则检查一下端口是否正确。命令中<code>-p 9000:9000</code>说明本地端口已经映射到了docker的9000端口。检查nginx中的配置。<br>原来是代理错了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">  include snippets/fastcgi-php.conf;</span><br><span class="line">  fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
修改<code>fastcgi_pass</code>为端口形式，改为如下配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">  include snippets/fastcgi-php.conf;</span><br><span class="line">  fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行<code>nginx -s reload</code>重启成功。这回502问题消失了。</li>
</ol>
<h2 id="File-not-found-问题解决"><a href="#File-not-found-问题解决" class="headerlink" title="File not found 问题解决"></a>File not found 问题解决</h2><p>出现File not found 返回码是404，分析原因</p>
<ol>
<li>文件路径不对</li>
<li>文件没有权限</li>
</ol>
<p>首先检查nginx中<code>root</code>的配置发现目录是对的，这就排除了nginx报404的可能。然后分析文件权限，发现也是可读的。文件权限正常。<br>那就只有一种可能了，php-fpm没有找到文件。<br>nginx和php的组合，是现在很普遍的方式，他的执行过程是这样的</p>
<ol>
<li>nginx接到请求，转发到php-fpm</li>
<li>php-fpm接收到数据，启动php，执行php代码</li>
</ol>
<p>既然nginx设置和权限都没问题，那就说明这个file not found是php报的错，查看docker的log发现真的有错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project3-php_1     | 172.17.0.5 -  29/Mar/2016:13:29:12 +0000 &quot;GET /index.php&quot; 404</span><br></pre></td></tr></table></figure>
<p>php居然找的是根目录下的index.php。这说明docker的卷映射的不对。修改执行命令的<code>-v</code>参数，重新启动镜像。重启nginx果然问题解决了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 9000:9000 -d --name myphp -v /var/www/html/:/var/www/html/ --privileged=true -d php:7.2-fpm</span><br></pre></td></tr></table></figure>
<p>其中<code>-p 9000:9000</code>和<code>-v /var/www/html/:/var/www/html/</code>是关键，这两个一定要注意。</p>
<ol>
<li><p>-p 宿主机端口:docker端口<br>因为nginx是在宿主机上的程序，并不能直接访问docker中的端口，只能发送给宿主机9000端口。<br><code>-p 9000:9000</code>参数会让宿主机把来自9000端口的数据，发送给docker的9000端口。<br>这样就实现了和docker通信的过程</p>
</li>
<li><p>-v 宿主机路径:docker工作路径<br>注意这里一定要用绝对地址，配置好了卷映射，宿主机路径一定要和nginx虚拟主机root的配置一致。docker才可以读取宿主机的文件。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php-fpm</tag>
        <tag>php-cli</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox v5.2.12 Ubuntu18.04 宿主机和虚拟主机互通，都可上网配置方式</title>
    <url>/2019/04/02/2019/VirtualBox-v5-2-12-Ubuntu18-04-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E4%BA%92%E9%80%9A%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%B8%8A%E7%BD%91%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><p>点击管理，全局设置；<br>选择网络，里面只有 NAT 网络；<br>点击添加，列表新增 NatNetwork，点击确定。</p>
<h2 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h2><p>点击管理，选择主机网络管理；<br>选择创建，列表新增 vboxnet0，只要这一个就够了；<br>选中点击 vboxnet0，点击手动配置网卡；<br>点击 IPv4 地址，输入配置的网关 IP，如：192.168.56.1；<br>如果不想使用 DHCP，取消启用 DHCP，点击应用。</p>
<h2 id="给虚拟机添加网卡"><a href="#给虚拟机添加网卡" class="headerlink" title="给虚拟机添加网卡"></a>给虚拟机添加网卡</h2><p>右键点击一个虚拟主机，选择设置；<br>选择网络；<br>选中点击网卡 1，勾选启用网络连接；<br>连接方式选择网络地址转换(NAT)，界面可以空着；<br>选中点击网卡 2，勾选启用网络连接；<br>连接方式选择仅主机(Host-Only)网络，界面名称为 vboxnet0，点击确认。</p>
<span id="more"></span>

<h2 id="设置虚拟机网络"><a href="#设置虚拟机网络" class="headerlink" title="设置虚拟机网络"></a>设置虚拟机网络</h2><p>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/network/interfaces</span><br></pre></td></tr></table></figure>

<p>如果第二步中启用了 DHCP，可以这样设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto enp0s3</span><br><span class="line">iface enp0s3 inet dhcp</span><br><span class="line"></span><br><span class="line">auto enp0s8</span><br><span class="line">iface enp0s8 inet dhcp</span><br></pre></td></tr></table></figure>

<p>如果第二步中取消了 DHCP 则这样配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto enp0s3</span><br><span class="line">iface enp0s3 inet dhcp</span><br><span class="line"># 为第二块网卡配置静态ip</span><br><span class="line">auto enp0s8</span><br><span class="line">iface enp0s8 inet static</span><br><span class="line">address 192.168.56.102</span><br><span class="line">netmask 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>注意，有可能网卡名称不是 enp0s8，如果要查看网卡可以执行<code>ls /sys/class/net</code>进行查看</p>
<h2 id="重启虚拟机测试"><a href="#重启虚拟机测试" class="headerlink" title="重启虚拟机测试"></a>重启虚拟机测试</h2><p>注意这里要重启虚拟主机<br>虚拟主机重启后，先执行<code>ifconfig</code>会看到如下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255</span><br><span class="line">        inet6 fe80::a00:27ff:fecb:1016  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 08:00:27:cb:10:16  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 14  bytes 3390 (3.3 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 27  bytes 3372 (3.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">enp0s8: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.56.102  netmask 255.255.255.0  broadcast 192.168.56.255</span><br><span class="line">        inet6 fe80::a00:27ff:fe6f:4edf  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 08:00:27:6f:4e:df  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 56  bytes 6310 (6.3 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 75  bytes 10073 (10.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 88  bytes 6692 (6.6 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 88  bytes 6692 (6.6 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个<code>enp0s8</code>就是我们的 Host-Only 网卡，<code>inet</code>就是网卡的 ip 地址，这是显示的是<code>192.168.56.102</code>。在宿主机执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 192.168.56.102</span><br></pre></td></tr></table></figure>

<p>发现 ping 通了。<br>查看一下宿主机的 ip，在虚拟机中<code>ping</code>也可以 ping 通。这样宿主机和虚拟主机的双向通讯就没有问题了。而且宿主机和虚拟机都可以访问外网。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>互通</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab使用详解</title>
    <url>/2019/01/24/2019/crontab%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>网上有很多关于crontab的介绍，但是没有一份很全面的，例子也不少，但是没有详细解释具体的意义。看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#每隔1个小时执行一次  ls</span><br><span class="line">0 */1 * * * ls</span><br><span class="line"></span><br><span class="line">#每隔2个小时执行一次 ls</span><br><span class="line">0 */2 * * * ls</span><br><span class="line"></span><br><span class="line">#每隔3个小时执行一次 ls</span><br><span class="line">0 */3 * * * ls</span><br><span class="line"></span><br><span class="line">#每隔4个小时执行一次 ls</span><br><span class="line">0 */4 * * * ls</span><br><span class="line"></span><br><span class="line">#每隔10天执行一次 ls</span><br><span class="line">0 0 */10 * * ls</span><br><span class="line"></span><br><span class="line">#每天1点执行 ls</span><br><span class="line">0 1 * * * ls</span><br></pre></td></tr></table></figure>
<p>接下来就详细说明一下crontab的使用，和每个参数的意义</p>
<span id="more"></span>
<h2 id="使用crontab"><a href="#使用crontab" class="headerlink" title="使用crontab"></a>使用crontab</h2><p>修改计划任务可以用<code>crontab -e</code>命令</p>
<blockquote>
<p>crontab -e</p>
</blockquote>
<p>查看已有计划任务可以使用<code>crontab -l</code>命令</p>
<blockquote>
<p>crontab -l</p>
</blockquote>
<h2 id="参数的含义"><a href="#参数的含义" class="headerlink" title="参数的含义"></a>参数的含义</h2><p><img src="/assets/images/posts/crontab.png" alt="crontab示意图"></p>
<p>每个参数我们可以使用 *  、1 、*&#x2F;1 、1,2、1-3这四种形式</p>
<blockquote>
<p>星号（ * ）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（ , ）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（ - ）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（ &#x2F; ）：可以用正斜线指定时间的间隔频率，例如“0-23&#x2F;2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*&#x2F;10，如果用在minute字段，表示每十分钟执行一次。</p>
</blockquote>
<h2 id="实例和纠错"><a href="#实例和纠错" class="headerlink" title="实例和纠错"></a>实例和纠错</h2><p>网上流传着许多的实例但其中一些是错误的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每一小时重启smb </span><br><span class="line">* */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<p>表面上看起来是正确的，第二个参数采用了 *&#x2F;1 表示每小时一次，但是看前面的分钟参数却是 * ，那就表示每分钟一次。整个任务的意义就成了，每隔小时每分钟一次，都每分钟一次了，小时还有什么意义呢？正确的写法应该是什么呢？应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每小时的第0分钟重启</span><br><span class="line">0 */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<p>差别就在于指定了分钟，但是这样会有一个新的问题，比如当前时间是09:01，那这个任务会在10:00的时候被执行，要等将近一小时啊，好痛苦。如果我们希望立刻执行应该怎么做呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每小时重启一次</span><br><span class="line">*/60 * * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<p>这才是正确的写法，每隔60分钟执行一次命令，并且是立刻执行。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每星期六的晚上11:00 pm重启smb </span><br><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"># 晚上11点到早上7点之间，每隔一小时重启smb</span><br><span class="line">*/60 23-7 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"># 每月的4号与每周一到周三的11点重启smb </span><br><span class="line">0 11 4 * mon-wed /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"># 一月一号的4点重启smb</span><br><span class="line">0 4 1 jan * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<h2 id="crond服务"><a href="#crond服务" class="headerlink" title="crond服务"></a>crond服务</h2><p>设置了crontab为什么没有立刻执行呢？如果想立刻生效，最好是重启一下cron服务，常用命令如下</p>
<blockquote>
<p>service cron start    &#x2F;&#x2F;启动服务<br>service cron stop     &#x2F;&#x2F;关闭服务<br>service cron restart  &#x2F;&#x2F;重启服务<br>service cron reload   &#x2F;&#x2F;重新载入配置</p>
</blockquote>
<p>参考资料<br><a href="http://man.linuxde.net/crontab">http://man.linuxde.net/crontab</a><br><a href="https://blog.csdn.net/liu0808/article/details/80668705">https://blog.csdn.net/liu0808/article/details/80668705</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>Supervisord管理进程常用命令</title>
    <url>/2019/04/28/2019/Supervisord%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Supervisord安装完成后有两个可用的命令行supervisor和supervisorctl，命令使用解释如下：</p>
<p><strong>supervisord</strong>: 初始启动Supervisord，启动、管理配置中设置的进程。<br><strong>supervisorctl stop programxxx</strong>: 停止某一个进程(programxxx)，programxxx为[program:chatdemon]里配置的值，这个示例就是chatdemon。<br><strong>supervisorctl start programxxx</strong>: 启动某个进程<br><strong>supervisorctl restart programxxx</strong>: 重启某个进程<br><strong>supervisorctl stop groupworker</strong>: 重启所有属于名为groupworker这个分组的进程(start,restart同理)<br><strong>supervisorctl stop all</strong>: 停止全部进程，注：start、restart、stop都不会载入最新的配置文件。<br><strong>supervisorctl reload</strong>: 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程。<br><strong>supervisorctl update</strong>: 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启。</p>
<blockquote>
<p>注意：显示用stop停止掉的进程，用reload或者update都不会自动重启。</p>
</blockquote>
<p>原文<a href="https://feilong.me/2011/03/monitor-processes-with-supervisord">https://feilong.me/2011/03/monitor-processes-with-supervisord</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>系统运维</tag>
        <tag>supervisord</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch学习笔记 - 安装</title>
    <url>/2019/03/14/2019/elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>最近用到了es，于是从网上找资料，但是好多都过时了，比如type在elasticsearch 6.0开始已经不推荐使用了。联合查询6.x使用的是join类型的字段，也不在支持type之间的联合查询。问什么要取消type呢？官方给出的理由是</p>
<blockquote>
<p>①，而在我们elasticsearch中同一 Index 下，同名 Field 类型必须相同，即使不同的 Type；<br>②， 同一 Index 下，TypeA 的 Field 会占用 TypeB 的资源（互相消耗资源），会形成一种稀疏存储的情况。尤其是 doc value ，为什么这么说呢？doc value为了性能考虑会保留一部分的磁盘空间，这意味着 TypeB 可能不需要这个字段的 doc_value 而 TypeA 需要，那么 TypeB 就被白白占用了一部分没有半点用处的资源；<br>③，Score 评分机制是 index-wide 的，不同的type之间评分也会造成干扰。<br>④，索引元数据本身是放在主节点中维护的，CP 设计。意味着涉及到大量字段变更及元数据变更的操作，都会导致该 Index 被堵塞或假死。我们应该对这样的 Index 做隔离，避免影响到其他 Index 正常的增删改查。甚至当涉及到字段变更十分频繁且无法预定义 schema 的场景时，是否要使用 ES 都应该慎思熟虑了！</p>
</blockquote>
<p>出现这种情况主要是在elasticsearch早期时候提出的一些概念，当时为了便于推广，跟关系型数据库作了如下比喻：</p>
<table>
<thead>
<tr>
<th>myql</th>
<th>elasticsearch</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>index</td>
</tr>
<tr>
<td>table</td>
<td>type</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
</tr>
</tbody></table>
<p>很多学习elasticsearch的人估计都看过这个比喻，但其实这是错误的。elasticsearch是基于 Lucene开发的，而在 Lucene中是没有table概念的，有的只是文档和字段。</p>
<span id="more"></span>

<p>言归正传开始今天的正题，如何安装elasticsearch。</p>
<h2 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h2><p>elasticsearch是使用java语言开发的，所以运行需要安装jdk。</p>
<ol>
<li>下载<br>先到 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> 下载jdk然后安装。<br>我用的压缩包安装，下载<code>dk-8u201-linux-x64.tar.gz</code></li>
<li>安装<br>将下载的压缩包上传到服务器的<code>/opt</code>目录下，然后执行一下命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tar zxvf dk-8u201-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
解压后，会出现<code>dk-8u201-linux-x64</code>文件夹，至于压缩包，如果不想要了可以删除</li>
<li>设置环境变量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>
在底部添加以下内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#java</span><br><span class="line">JAVA_HOME=/opt/jdk-10.0.2</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export JRE_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure>
让配置立刻生效<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
执行 <code>java -version</code> 如果看到java版本提示，表示安装成功了。</li>
</ol>
<blockquote>
<p>注意，这里有个坑，ubuntu服务器切换用户后环境变量会丢失。如果你是服务器环境，请参考<a href="https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8">https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8</a> 进行安装</p>
</blockquote>
<h2 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h2><p>安装非常简单，执行一下命令就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.3.tar.gz</span><br><span class="line">tar -xvf elasticsearch-6.4.3.tar.gz</span><br><span class="line">cd elasticsearch-6.4.3/bin</span><br><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure>
<p>这样elasticsearch就安装完成并且运行起来了</p>
<blockquote>
<p>注意，elasticsearch要去不能用root用户运行，如果你是root，可以用如下方法解决</p>
<ol>
<li>在执行elasticSearch时加上参数-Des.insecure.allow.root&#x3D;true。</li>
<li>用vi打开elasicsearch执行文件，在变量ES_JAVA_OPTS使用前添加以下命令 ES_JAVA_OPTS&#x3D;”-Des.insecure.allow.root&#x3D;true”</li>
<li>su 切换到其他账号，运行elasticsearch</li>
</ol>
</blockquote>
<p>参考资料<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.4/getting-started-install.html">elasticsearch官方安装说明</a><br><a href="https://blog.csdn.net/lahand/article/details/78954112">root运行elasticsearch</a><br><a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">阮老师elasticsearch笔记</a><br><a href="https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8">jdk安装</a><br><a href="https://elasticsearch.cn/article/337">elasticsearch6.0只允许一个type</a></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elasticsearch学习笔记</tag>
        <tag>es</tag>
        <tag>安装es</tag>
      </tags>
  </entry>
  <entry>
    <title>git reset命令详解</title>
    <url>/2019/03/06/2019/git-reset%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>git reset命令，非常牛的一个命令，这个命令可以让你时光穿梭回到过去。用在自己分支上很好用，但是千万不要在公共分支上使用。以免造成历史混乱，破坏历史可是重罪，别看那些穿越小说混的风生水起，那都是骗人的。</p>
<p>用git reset之前先要了解几个概念</p>
<ul>
<li><p>HEAD<br>这是当前分支版本顶端的别名，也就是在当前分支你最近的一个提交，也就是本地仓库，即你的commit记录</p>
</li>
<li><p>Index<br>index也被称为staging area，即add的记录</p>
</li>
<li><p>Working Copy<br>working copy代表你正在工作的那个文件</p>
</li>
</ul>
<span id="more"></span>

<h2 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h2><p>先执行git log查看当前的记录，这里是我预先做了几次commit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit fd9b11185a41cf5cfe187be61dc43c06dd7b5420</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Fri Feb 24 15:23:55 2017 +0800</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">commit 0aa75d4355211a8b1943d1c8d5b4904e18053bcf</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Fri Feb 24 15:23:37 2017 +0800</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">commit 2bdd42d126d269688be33759f96e4015a85e720b</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Fri Feb 24 15:23:04 2017 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当前工作区是干净的，下面执行以下命令</p>
<h3 id="–soft"><a href="#–soft" class="headerlink" title="–soft"></a>–soft</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shooke@shooke-pc:/var/www/gittest$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">shooke@shooke-pc:/var/www/gittest$ git reset --soft HEAD~1</span><br><span class="line">shooke@shooke-pc:/var/www/gittest$ git log</span><br><span class="line">commit 0aa75d4355211a8b1943d1c8d5b4904e18053bcf</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Fri Feb 24 15:23:37 2017 +0800</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">commit 2bdd42d126d269688be33759f96e4015a85e720b</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Fri Feb 24 15:23:04 2017 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">shooke@shooke-pc:/var/www/gittest$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line"></span><br><span class="line">	修改：     a.txt</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现使用git reset –soft后我们的commit少了一条，a.txt是已经add过的状态<br>也就是说–soft只是撤销了commit。<strong>但是a.txt的内容是没有改变的。</strong>我们用公式标示一下</p>
<blockquote>
<p><code>HEAD</code> !&#x3D; <code>index</code> &#x3D; <code>Working Copy</code><br><strong>只撤销了commit ，保留了index（add过）和工作区</strong></p>
</blockquote>
<h3 id="–mixed"><a href="#–mixed" class="headerlink" title="–mixed"></a>–mixed</h3><p>我们恢复到3条记录的状态，继续看下面的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shooke@shooke-pc:/var/www/gittest$ git reset --mixed HEAD~1</span><br><span class="line">重置后取消暂存的变更：</span><br><span class="line">M	a.txt</span><br><span class="line">shooke@shooke-pc:/var/www/gittest$ git log</span><br><span class="line">commit 0aa75d4355211a8b1943d1c8d5b4904e18053bcf</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Fri Feb 24 15:23:37 2017 +0800</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">commit 2bdd42d126d269688be33759f96e4015a85e720b</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Fri Feb 24 15:23:04 2017 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">shooke@shooke-pc:/var/www/gittest$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">	修改：     a.txt</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现git提示我们需要add，也就是说暂存区发生了修改，<strong>但是a.txt 的内容没有改变</strong><br>我们再用公式标示一下</p>
<blockquote>
<p><code>HEAD</code> &#x3D; <code>index</code> ！&#x3D; <code>Working Copy</code><br><strong>撤销了commit 、index，工作区不变</strong></p>
</blockquote>
<h3 id="–hard"><a href="#–hard" class="headerlink" title="–hard"></a>–hard</h3><p>我们恢复到3条记录的状态，继续看下面的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shooke@shooke-pc:/var/www/gittest$ git reset --hard HEAD~1</span><br><span class="line">HEAD 现在位于 0aa75d4 2</span><br><span class="line">shooke@shooke-pc:/var/www/gittest$ git log</span><br><span class="line">commit 0aa75d4355211a8b1943d1c8d5b4904e18053bcf</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Fri Feb 24 15:23:37 2017 +0800</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">commit 2bdd42d126d269688be33759f96e4015a85e720b</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Fri Feb 24 15:23:04 2017 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">shooke@shooke-pc:/var/www/gittest$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这一次没有a.txt有修改。也就是说工作区的文件与暂存去、本地仓库是一致的。打开a.txt发现里面的内容变成了2，也就是说<strong>a.txt内容也跟着回退到了上次commit时的代码</strong>。用公式表示</p>
<blockquote>
<p><code>HEAD</code> &#x3D; <code>index</code> &#x3D; <code>Working Copy</code><br><strong>commit 、index和工作区文件都回退改变</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git reset</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch学习笔记 - 集群相关术语</title>
    <url>/2019/03/15/2019/elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E9%9B%86%E7%BE%A4%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>Cluster：集群。<br>顾名思义就是好多es服务器，拜了把子成了兄弟，在一起搞事情，他们讲义气不背叛，一个有难八方支援。比如你有8台服务器，其中一台挂了，剩余的兄弟会立刻顶上。客户让然可以正常使用你的服务，从而实现<code>高可用性</code>。</p>
</li>
<li><p>Node：节点。<br>集群中的每台服务器称之为一个节点。每个节点都是一个兄弟。既然拜了把子，那就有个长幼顺序（节点类型），这个看下面的节点类型小节，先看分片。</p>
</li>
<li><p>Shard：分片。<br>一只烤全羊，一个人肯定吃不了，怎么办呢？大家分着吃啊。所以就有了分片，大量的数据汇聚过来，一个节点可能由于内存或磁盘处理能力不足，那就把数据切成一小块一小块的（这就是分片），好几个兄弟一起处理。每个分片放到不同的服务器上。 这样处理起来就快了。<br>有肉一起吃，敌人来了当然也要一起扛。当有查询过来的时候，ES会把查询发送给每个相关的分片，并将结果组合在一起，然后返回给用户。</p>
</li>
<li><p>Replia：副本。<br>分着吃羊肉，羊是吃完了，但每个人分到的不一样啊，有人吃羊腿，有人吃羊尾巴，显然这样长期下去也是不行的。怎么办呢，再来一只，吃羊腿的再吃羊尾巴，吃羊尾巴的再吃羊腿，这样就公平了。每个人都能说出整只羊各个部位是什么味道。<br>同样的道理，数据分片，放在了不同的节点上，如果一台服务器挂掉了，那岂不是数据就丢失了，这种事是不允许发生的，因此就有了副本。每个切片复制一份，发送给其他节点。这样保证每个节点有完整的数据。集群中有一台宕机了也不影响使用。</p>
</li>
</ol>
<span id="more"></span>
<h2 id="健康状态"><a href="#健康状态" class="headerlink" title="健康状态"></a>健康状态</h2><p>针对一个索引，Elasticsearch 中其实有专门的衡量索引健康状况的标志，分为三个等级：</p>
<ol>
<li>green，绿色。这代表所有的主分片和副本分片都已分配。你的集群是 100% 可用的。</li>
<li>yellow，黄色。所有的主分片已经分片了，但至少还有一个副本是缺失的。不会有数据丢失，所以搜索结果依然是完整的。不过，你的高可用性在某种程度上被弱化。如果更多的分片消失，你就会丢数据了。所以可把 yellow 想象成一个需要及时调查的警告。</li>
<li>red，红色。至少一个主分片以及它的全部副本都在缺失中。这意味着你在缺少数据：搜索只能返回部分数据，而分配到这个分片上的写入请求会返回一个异常。</li>
</ol>
<p>如果你只有一台主机的话，其实索引的健康状况也是 yellow，因为一台主机，集群没有其他的主机可以防止副本，所以说，这就是一个不健康的状态，因此集群也是十分有必要的。</p>
<h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><ol>
<li>主节点：即 Master 节点。主节点的主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。稳定的主节点对集群的健康是非常重要的。默认情况下任何一个集群中的节点都有可能被选为主节点。索引数据和搜索查询等操作会占用大量的cpu，内存，io资源，为了确保一个集群的稳定，分离主节点和数据节点是一个比较好的选择。虽然主节点也可以协调节点，路由搜索和从客户端新增数据到数据节点，但最好不要使用这些专用的主节点。一个重要的原则是，尽可能做尽量少的工作。</li>
<li>数据节点：即 Data 节点。数据节点主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等。数据节点对 CPU、内存、IO 要求较高，在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。</li>
<li>负载均衡节点：也称作 Client 节点，也称作客户端节点。当一个节点既不配置为主节点，也不配置为数据节点时，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，他协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接路由请求。</li>
<li>预处理节点：也称作 Ingest 节点，在索引数据之前可以先对数据做预处理操作，所有节点其实默认都是支持 Ingest 操作的，也可以专门将某个节点配置为 Ingest 节点。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/post/5bad9520f265da0afe62ed95">https://juejin.im/post/5bad9520f265da0afe62ed95</a><br><a href="https://cloud.tencent.com/developer/article/1066239">https://cloud.tencent.com/developer/article/1066239</a></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>elasticsearch学习笔记</tag>
        <tag>es</tag>
        <tag>elasticsearch集群</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch模糊查询</title>
    <url>/2019/01/23/2019/elasticsearch%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>like %李四% 可以使用以下语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">        &quot;nickname&quot;: &#123;&quot;query&quot;:&quot;李明&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;wildcard&quot;: &#123;</span><br><span class="line">        &quot;nickname.keyword&quot;: &quot;*李明*&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>git保存密码</title>
    <url>/2019/03/06/2019/git%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>git每次提交都输入密码，非常麻烦，让它记住密码就好了。一劳永逸的做法是永久保存，这样每次都不用输入密码。但是，这样会有安全问题，如果电脑忘了关机，任何人都可以对其进行操作。最好是让密码有个时效性，当超过了指定时间，密码自动失效。</p>
<span id="more"></span>



<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>下面是两种设置方式</p>
<ul>
<li>永久保存<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper cache</span><br></pre></td></tr></table></figure></li>
<li>指定保存时间<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper &quot;cache --timeout=3600&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper winstore</span><br></pre></td></tr></table></figure>
<p>或者修改配置文件加入下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[credential]</span><br><span class="line">    helper = winstore</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中文文件名乱码解决方法</title>
    <url>/2019/12/17/2019/git%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	Untitled-1</span><br><span class="line">	&quot;git\347\256\200\344\273\213&quot;</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实<code>&quot;git\347\256\200\344\273\213&quot;</code>是个中文名的文件<code>git简介</code>,中文部分成了乱码，解决方法很简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure>
<p>这样，不对0x80以上的字符进行quote，解决git status&#x2F;commit时中文文件名乱码</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>js实现防抖和节流</title>
    <url>/2019/11/15/2019/js%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>防抖和节流是避免过度处理的有效手段。目的就是为了解决一些事件频繁的触发问题。</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>先说一下防抖，当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p>
<blockquote>
<p>通俗易懂点就是，领导安排任务，你得等领导全部说完了再去做，不能说一个就跑去做了，你得等领导说完。</p>
</blockquote>
<p>举个很典型的例子，搜索提示是个很典型的使用场景。每次输入框的内容发生更改就会发送一个请求，这其实是没有必要的。<br>理想的方式应该是当用户不在输入时，在发送请求。怎么确定用户停止输入呢？我们定义一个等待时间，比如500ms。当用户停止输入500ms后发送一个请求。<br>500ms内如果在不停的输入内容，那我们就重新重新计时。</p>
<span id="more"></span>

<p>简单例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 防抖  定时器</span><br><span class="line">let timer;</span><br><span class="line"></span><br><span class="line">// 监听input事件</span><br><span class="line">this.$refs.search.$el.addEventListener(&quot;input&quot;, e =&gt; &#123;</span><br><span class="line">  console.log(&#x27;不防抖&#x27;)</span><br><span class="line">	if (timer) &#123;</span><br><span class="line">		//清空timer</span><br><span class="line">		clearTimeout(timer);</span><br><span class="line">	&#125;</span><br><span class="line">	timer = setTimeout(() =&gt; &#123;</span><br><span class="line">		console.log(&#x27;防抖&#x27;)	//使用防抖	</span><br><span class="line">	&#125;, 75);		//75mm为最佳</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>进行一下封装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line"></span><br><span class="line">    var timeout, result;</span><br><span class="line"></span><br><span class="line">    var debounced = function () &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            // 如果已经执行过，不再执行</span><br><span class="line">            var callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                result = func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的借用了<code>冯羽</code>的代码<a href="https://juejin.im/post/5931561fa22b9d0058c5b87d#heading-3">https://juejin.im/post/5931561fa22b9d0058c5b87d#heading-3</a></p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>与防抖不同，节流是用来控制节奏的，他不会象防抖那样，一直无限期的后延。而是执行一个时间段内的最后一次指令。</p>
<blockquote>
<p>通俗易懂点就是，老板给你安排任务，要求一周完成。但是在做的过程中需求老是变化，你就不行抛弃以前的工作，只按最新需求做，到了交付日期，按照最终需求交付。</p>
</blockquote>
<p>比如滚动事件，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</p>
<p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var throttle = function(func, delay) &#123;</span><br><span class="line">     var timer = null;</span><br><span class="line">     var startTime = Date.now();</span><br><span class="line">     return function() &#123;</span><br><span class="line">             var curTime = Date.now();</span><br><span class="line">             var remaining = delay - (curTime - startTime);</span><br><span class="line">             var context = this;</span><br><span class="line">             var args = arguments;</span><br><span class="line">             clearTimeout(timer);</span><br><span class="line">              if (remaining &lt;= 0) &#123;</span><br><span class="line">                    func.apply(context, args);</span><br><span class="line">                    startTime = Date.now();</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                    timer = setTimeout(func, remaining);</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">function handle() &#123;</span><br><span class="line">      console.log(Math.random());</span><br><span class="line">&#125;</span><br><span class="line"> window.addEventListener(&#x27;scroll&#x27;, throttle(handle, 1000));</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4">https://juejin.im/entry/5b1d2d54f265da6e2545bfa4</a><br><a href="https://juejin.im/post/5dccb36de51d45105d563105?utm_source=gold_browser_extension#heading-4">https://juejin.im/post/5dccb36de51d45105d563105?utm_source=gold_browser_extension#heading-4</a><br><a href="https://juejin.im/post/5b8de829f265da43623c4261#heading-4">https://juejin.im/post/5b8de829f265da43623c4261#heading-4</a><br><a href="https://juejin.im/entry/5937cc8cb123db0064496405">https://juejin.im/entry/5937cc8cb123db0064496405</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>git远程删除分支后，本地git branch -a 依然能看到的解决办法</title>
    <url>/2019/01/29/2019/git%E8%BF%9C%E7%A8%8B%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF%E5%90%8E%EF%BC%8C%E6%9C%AC%E5%9C%B0git-branch-a-%E4%BE%9D%E7%84%B6%E8%83%BD%E7%9C%8B%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>git远程删除分支后，本地<code>git branch -a</code> 依然能看到的解决办法很简单，使用<code>git remote prune origin</code>就可以解决了。下面详细说明</p>
<span id="more"></span>
<p>使用<code>git branch -a</code>命令可以查看所有本地分支和远程分支（<code>git branch -r</code> 可以只查看远程分支）<br>发现很多在远程仓库已经删除的分支在本地依然可以看到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  dev</span><br><span class="line">  master</span><br><span class="line">* tb</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/my-feature #已经被远程删除的分支</span><br></pre></td></tr></table></figure>
<p>但是如果使用git push -d origin my-feature,就会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: unable to delete &#x27;my-feature&#x27;: remote ref does not exist</span><br></pre></td></tr></table></figure>
<p>使用命令 <code>git remote show origin</code>，可以查看remote地址，远程分支，还有本地分支与之相对应关系等信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 远程 origin</span><br><span class="line">  获取地址：http://gitee.com/dm/dmp-api.git</span><br><span class="line">  推送地址：http://gitee.com/dm/dmp-api.git</span><br><span class="line">  HEAD 分支：master</span><br><span class="line">  远程分支：</span><br><span class="line">    dev                                      已跟踪</span><br><span class="line">    master                                   已跟踪</span><br><span class="line">    tb                                       已跟踪</span><br><span class="line">    refs/remotes/origin/my-feature           过时（使用 &#x27;git remote prune&#x27; 来移除）</span><br></pre></td></tr></table></figure>
<p>此时我们可以看到那些远程仓库已经不存在的分支，根据提示，使用 <code>git remote prune origin</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修剪 origin</span><br><span class="line">URL：http://gitee.com/dm/dmp-api.git</span><br><span class="line"> * [已删除] origin/my-feature</span><br></pre></td></tr></table></figure>
<p>这时我们运行<code>git branch -a</code>就不会看到远程已经别删除的分支了</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux使用apt方式安装mysql5.7</title>
    <url>/2019/03/13/2019/linux%E4%BD%BF%E7%94%A8apt%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85mysql5-7/</url>
    <content><![CDATA[<p>安装3步曲：</p>
<ol>
<li>使用apt-get安装</li>
<li>设置root密码和验证方式</li>
<li>重启服务</li>
</ol>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>废话少说，开始安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br></pre></td></tr></table></figure>

<h2 id="设置root密码和验证方式"><a href="#设置root密码和验证方式" class="headerlink" title="设置root密码和验证方式"></a>设置root密码和验证方式</h2><p>查看下&#x2F;etc&#x2F;mysql&#x2F;debain.cnf，内容如下</p>
<blockquote>
<h1 id="Automatically-generated-for-Debian-scripts-DO-NOT-TOUCH"><a href="#Automatically-generated-for-Debian-scripts-DO-NOT-TOUCH" class="headerlink" title="Automatically generated for Debian scripts. DO NOT TOUCH!"></a>Automatically generated for Debian scripts. DO NOT TOUCH!</h1><p>[client]<br>host     &#x3D; localhost<br>user     &#x3D; debian-sys-maint<br>password &#x3D; bqDQ42VIUk9zTFFR<br>socket   &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock<br>[mysql_upgrade]<br>host     &#x3D; localhost<br>user     &#x3D; debian-sys-maint<br>password &#x3D; bqDQ42VIUk9zTFFR<br>socket   &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</p>
</blockquote>
<p>用里面的debian-sys-maint用户登录数据库，密码就是password对应的bqDQ42VIUk9zTFFR</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u debian-sys-maint -p</span><br></pre></td></tr></table></figure>
<p>输入密码，进入mysql，执行一下命令设置root密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update mysql.user set authentication_string=PASSWORD(&#x27;newPwd&#x27;), plugin=&#x27;mysql_native_password&#x27; where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure>
<p><code>注意，authentication_string是密码 ，plugin是验证方式，这两个一定要同时改。从mysql5.7开始root的默认验证方式是auth_socket</code></p>
<h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>
<p>可以用mysql -uroot -p登录了</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux安装java环境</title>
    <url>/2019/04/03/2019/linux%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="下载jdk"><a href="#下载jdk" class="headerlink" title="下载jdk"></a>下载jdk</h2><p>可以到<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html%E4%B8%8B%E8%BD%BD">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html下载</a><br>JDK 8u201 是稳定版本<br>JDK 8u202 是开发版本，包含了8u21的功能和一些其他功能，有可能会有bug<br>找到<code>Java SE Development Kit 8u201</code>点击该栏目下的<code>Accept License Agreement</code>单选项<br>在下面的列表中找到需要的版本，右键复制链接，在terminal里面用<code>wget</code>命令下载，下面用的是<code>jdk-8u201-linux-x64</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz?AuthParam=1554274626_8750d27ae1e72e03c48aa9f516d713c3</span><br></pre></td></tr></table></figure>
<h2 id="解压程序包并移动到-opt目录"><a href="#解压程序包并移动到-opt目录" class="headerlink" title="解压程序包并移动到&#x2F;opt目录"></a>解压程序包并移动到&#x2F;opt目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先改个名字，要不然看着别扭</span><br><span class="line">mv jdk-8u201-linux-x64.tar.gz?AuthParam=1554274626_8750d27ae1e72e03c48aa9f516d713c3 jdk-8u201-linux-x64.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar zxvf jdk-8u201-linux-x64.tar.gz</span><br><span class="line"># 解压后会出现jdk1.8.0_201文件夹，将其移动到/opt目录</span><br><span class="line">sudo mv jdk1.8.0_201 /opt</span><br></pre></td></tr></table></figure>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi ~/.profile</span><br></pre></td></tr></table></figure>
<p>在最后加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#java</span><br><span class="line">export JAVA_HOME=/opt/jdk1.8.0_201 #jdk的存放目录</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>
<p>最后让配置生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure>
<p>运行<code>java --version</code>看是否生效，如果出现java版本信息标示生效了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java version &quot;1.8.0_201&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从配置</title>
    <url>/2019/02/21/2019/mysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>本教程配置是mysql5.7 不同的版本配置方式有差异，仅供参考</p>
<h2 id="Master的配置"><a href="#Master的配置" class="headerlink" title="Master的配置"></a>Master的配置</h2><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf（配置文件具体位置根据）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=2</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">binlog-ignore-db=cluster</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-do-db=test</span><br></pre></td></tr></table></figure>
<p>这里的server-id用于标识唯一的数据库，在从库必须设置为不同的值。</p>
<p>binlog-ignore-db：表示同步的时候忽略的数据库</p>
<p>binlog-do-db：指定需要同步的数据库</p>
<p>配置完成后重启mysql服务</p>
<span id="more"></span>

<h3 id="增加同步用户"><a href="#增加同步用户" class="headerlink" title="增加同步用户"></a>增加同步用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加用户</span><br><span class="line">mysql&gt; create user &#x27;repl&#x27;@&#x27;172.16.99.44&#x27; identified by &#x27;RepL@)18&#x27;;</span><br><span class="line"># 给用户全局同步权限</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#x27;repl&#x27;@&#x27;172.16.99.44&#x27;;</span><br><span class="line"># 给用户操作主库的所有权限</span><br><span class="line">mysql&gt; GRANT ALL ON `test`.* TO `test`@`%`</span><br><span class="line"># 刷新权限，让权限生效</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<p>值得注意的一点是上面3条命令一条也不能少，如果只给了全局权限，不分配数据库权限也是无法同步的。<br>全局权限要根据实际情况给，如果你是用python，获取binlog，那还需要给定REPLICATION CLIENT才可以，否则无法链接数据库。有时候也需要file权限，否则无法读取binlog文件，从库无法同步。</p>
<h3 id="看配置是否生效"><a href="#看配置是否生效" class="headerlink" title="看配置是否生效"></a>看配置是否生效</h3><p>重启mysql，然后登录mysql，执行如下命令看配置是否生效，如果显示了主库信息标示生效了，如果没有则表示，配置没成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure>
<p>注意一下file和position，在配置从库时会用到。File是同步会使用到的binlog文件，Position是同步的时候也要用到的。</p>
<h2 id="Slave的配置"><a href="#Slave的配置" class="headerlink" title="Slave的配置"></a>Slave的配置</h2><h3 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h3><p>修改&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf（配置文件具体位置根据）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=3</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">binlog-ignore-db=cluster</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">replicate-do-db=test</span><br><span class="line">replicate-ignore-db=mysql</span><br><span class="line">log-slave-updates</span><br><span class="line">slave-skip-errors=all</span><br><span class="line">slave-net-timeout=60 </span><br></pre></td></tr></table></figure>
<p>server-id一定不要和主库相同<br>replicate-do-db是要同步的数据库，一定要设置正确</p>
<p>配置完成，重启mysql服务</p>
<h3 id="配置主从关联"><a href="#配置主从关联" class="headerlink" title="配置主从关联"></a>配置主从关联</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave;</span><br><span class="line">mysql&gt; change master to master_host=&#x27;192.168.0.68&#x27;,master_user=&#x27;RepL&#x27;,master_password=&#x27;RepL@)18&#x27;,master_log_file=&#x27;mysql-bin.000004&#x27;, master_log_pos=28125;</span><br><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure>
<p>注意：上面的master_log_file是在Master中show master status显示的File，</p>
<p>而master_log_pos是在Master中show master status显示的Position。</p>
<p>然后可以通过show slave status查看配置信息。</p>
<p>如果没有同步成功，请查看show slave status中的position和file是否和master中的对应了。</p>
<p>查看从库状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status \G;</span><br></pre></td></tr></table></figure>
<p>观察这两个值，Slave_IO_Running: Yes 和Slave_SQL_Running: Yes，如果都是yes，说明运行正常。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql权限说明</title>
    <url>/2019/03/06/2019/mysql%E6%9D%83%E9%99%90%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>关于mysql的权限简单的理解就是mysql允许你做你权利以内的事情，不可以越界。比如只允许你执行select操作，那么你就不能执行update操作。只允许你从某台机器上连接mysql，那么你就不能从除那台机器以外的其他机器连接mysql。</p>
<p>那么Mysql的权限是如何实现的呢？这就要说到mysql的两阶段验证，下面详细介绍：<br>第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、某个IP、某个IP段、以及任何地方等，只允许你从配置的指定地方登陆。<br>第二阶段：如果你能连接，Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。比如你要更新某个表、或者查询某个表，Mysql会查看你对哪个表或者某个列是否有权限。再比如，你要运行某个存储过程，Mysql会检查你对存储过程是否有执行权限等。</p>
<span id="more"></span>
<h2 id="MySQL权限简单分类"><a href="#MySQL权限简单分类" class="headerlink" title="MySQL权限简单分类"></a>MySQL权限简单分类</h2><p>数据权限分为：库、表和字段三种级别<br>管理权限主要是管理员要使用到的权限，包括：数据库创建，临时表创建、主从部署、进程管理等<br>程序权限主要是触发器、存储过程、函数等权限。</p>
<table>
<thead>
<tr>
<th>权限分布</th>
<th>可设置的权限</th>
</tr>
</thead>
<tbody><tr>
<td>表权限</td>
<td>‘Select’, ‘Insert’, ‘Update’, ‘Delete’, ‘Create’, ‘Drop’, ‘Grant’, ‘References’, ‘Index’, ‘Alter’</td>
</tr>
<tr>
<td>列权限</td>
<td>‘Select’, ‘Insert’, ‘Update’, ‘References’</td>
</tr>
<tr>
<td>过程权限</td>
<td>‘Execute’, ‘Alter Routine’, ‘Grant’</td>
</tr>
</tbody></table>
<h2 id="MySQL用户权限层级"><a href="#MySQL用户权限层级" class="headerlink" title="MySQL用户权限层级"></a>MySQL用户权限层级</h2><ul>
<li><p>全局层级：全局权限适用于一个给定MySQL Server中的所有数据库，这些权限存储在mysql.user表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL ON *.* TO &#x27;user&#x27;@&#x27;host&#x27;;  # *.* 表示数据库库的所有库和表，对应权限存储在mysql.user表中</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库层级：数据库权限适用于一个给定数据库中的所有目标，这些权限存储在mysql.db表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL ON mydb.* TO &#x27;user&#x27;@&#x27;host&#x27;;  #mydb.* 表示mysql数据库下的所有表，对应权限存储在mysql.db表中</span><br></pre></td></tr></table></figure>
</li>
<li><p>表层级：表权限适用于一个给定表中的所有列，这些权限存储在mysql.tables_priv表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL ON mydb.mytable TO &#x27;user&#x27;@&#x27;host&#x27;;  #mydb.mytable 表示mysql数据库下的mytable表，对应权限存储在mysql.tables_priv表</span><br></pre></td></tr></table></figure>
</li>
<li><p>列层级：列权限使用于一个给定表中的单一列，这些权限存储在mysql.columns_priv表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL (col1， col2， col3)  ON mydb.mytable TO &#x27;user&#x27;@&#x27;host&#x27;; #mydb.mytable 表示mysql数据库下的mytable表， col1, col2,  col3表示mytable表中的列名</span><br></pre></td></tr></table></figure>
</li>
<li><p>子程序层级：CREATE ROUTINE、ALTER ROUTINE、EXECUTE和GRANT权限适用于已存储的子程序。这些权限可以被授予为全局层级和数据库层级。而且，除了CREATE ROUTINE外，这些权限可以被授予子程序层级，并存储在mysql.procs_priv表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT EXECUTE ON PROCEDURE mydb.myproc TO &#x27;user&#x27;@&#x27;host&#x27;; #mydb.mytable 表示mysql数据库下的mytable表，PROCEDUR表示存储过程</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Mysql权限总览"><a href="#Mysql权限总览" class="headerlink" title="Mysql权限总览"></a>Mysql权限总览</h2><table>
<thead>
<tr>
<th><strong>权限</strong></th>
<th><strong>权限级别</strong></th>
<th><strong>权限说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CREATE</td>
<td>数据库、表或索引</td>
<td>创建数据库、表或索引权限</td>
</tr>
<tr>
<td>DROP</td>
<td>数据库或表</td>
<td>删除数据库或表权限</td>
</tr>
<tr>
<td>GRANT OPTION</td>
<td>数据库、表或保存的程序</td>
<td>赋予权限选项</td>
</tr>
<tr>
<td>REFERENCES</td>
<td>数据库或表</td>
<td></td>
</tr>
<tr>
<td>ALTER</td>
<td>表</td>
<td>更改表，比如添加字段、索引等</td>
</tr>
<tr>
<td>DELETE</td>
<td>表</td>
<td>删除数据权限</td>
</tr>
<tr>
<td>INDEX</td>
<td>表</td>
<td>索引权限</td>
</tr>
<tr>
<td>INSERT</td>
<td>表</td>
<td>插入权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>表</td>
<td>查询权限</td>
</tr>
<tr>
<td>UPDATE</td>
<td>表</td>
<td>更新权限</td>
</tr>
<tr>
<td>CREATE VIEW</td>
<td>视图</td>
<td>创建视图权限</td>
</tr>
<tr>
<td>SHOW VIEW</td>
<td>视图</td>
<td>查看视图权限</td>
</tr>
<tr>
<td>ALTER ROUTINE</td>
<td>存储过程</td>
<td>更改存储过程权限</td>
</tr>
<tr>
<td>CREATE ROUTINE</td>
<td>存储过程</td>
<td>创建存储过程权限</td>
</tr>
<tr>
<td>EXECUTE</td>
<td>存储过程</td>
<td>执行存储过程权限</td>
</tr>
<tr>
<td>FILE</td>
<td>服务器主机上的文件访问</td>
<td>文件访问权限</td>
</tr>
<tr>
<td>CREATE TEMPORARY TABLES</td>
<td>服务器管理</td>
<td>创建临时表权限</td>
</tr>
<tr>
<td>LOCK TABLES</td>
<td>服务器管理</td>
<td>锁表权限</td>
</tr>
<tr>
<td>CREATE USER</td>
<td>服务器管理</td>
<td>创建用户权限</td>
</tr>
<tr>
<td>PROCESS</td>
<td>服务器管理</td>
<td>查看进程权限</td>
</tr>
<tr>
<td>RELOAD</td>
<td>服务器管理</td>
<td>执行flush-hosts, flush-logs, flush-privileges, flush-status, flush-tables, flush-threads, refresh, reload等命令的权限</td>
</tr>
<tr>
<td>REPLICATION CLIENT</td>
<td>服务器管理</td>
<td>复制权限</td>
</tr>
<tr>
<td>REPLICATION SLAVE</td>
<td>服务器管理</td>
<td>复制权限</td>
</tr>
<tr>
<td>SHOW DATABASES</td>
<td>服务器管理</td>
<td>查看数据库权限</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>服务器管理</td>
<td>关闭数据库权限</td>
</tr>
<tr>
<td>SUPER</td>
<td>服务器管理</td>
<td>执行kill线程权限</td>
</tr>
</tbody></table>
<p>参考资料<a href="https://yq.aliyun.com/articles/640817#">https://yq.aliyun.com/articles/640817#</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>pipenv与pyenv、pyenv-virtualenv的关系和使用</title>
    <url>/2019/06/20/2019/pipenv%E4%B8%8Epyenv%E3%80%81pyenv-virtualenv%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="为什么要有版本管理"><a href="#为什么要有版本管理" class="headerlink" title="为什么要有版本管理"></a>为什么要有版本管理</h2><p>我们举个例子：</p>
<ol>
<li>项目一要求用python 2.x</li>
<li>项目二要去python 3.x</li>
</ol>
<p>如果服务器上要运行这两个项目，就需要安装两个版本。如果项目更多，需要的版本也越多，我们就需要有版本管理的概念。</p>
<h2 id="为什么要有虚拟版本"><a href="#为什么要有虚拟版本" class="headerlink" title="为什么要有虚拟版本"></a>为什么要有虚拟版本</h2><p>上面我们看到，版本管理解决了，不同项目对python版本的需求。如果我们服务器上有增加了一个项目，情况如下，如果解决呢</p>
<ol>
<li>项目一要求用python 2.x</li>
<li>项目二要去python 3.x，要求导入的requests包是1.x</li>
<li>项目三要去python 3.x，要去导入的requests包是2.x</li>
</ol>
<p>我们看到项目二和项目三要去的是同样的版本，但是依赖的包是不同版本的，我们无法在一个版本上，同一个包安装不同的版本。这样容易造成混乱。因此就需要虚拟环境了。虚拟环境就是在所需的版本上，创建一个副本，在副本里进行依赖包的管理，这样不同的项目用自己的副本，就不会相互干扰。</p>
<span id="more"></span>

<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ol>
<li><strong>pyenv</strong> 用来管理python版本，比如系统中有一个2.x的版本，安装pyenv后可以，使用pyenv安装其他版本的python，让系统可以同时支持多个版本。而且不影响系统版本。</li>
<li><strong>pyenv-virtualenv</strong> 用来创建虚拟环境，让不同的项目拥有自己独立的运行环境，避免相互干扰。</li>
<li><strong>pipenv</strong> 它有两个功能，一个是管理依赖（替代pip管理工具）。二是可以创建虚拟环境(使用方式与pyenv-virtualenv有所差别)。</li>
</ol>
<p>简单点说就是，安装<code>pyenv</code>后，再安装<code>pipenv</code>。就可以满足日常的开发需求。如果对于虚拟环境的要求比较高，可以安装一下<code>pyenv-virtualenv</code>。后面具体讲解一下他们的功能。根据实际需求做出选择即可。</p>
<h2 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h2><ol>
<li>安装pyenv和pipenv，基本可以满足日常开发需求，可以使用pipenv去管理依赖包，和虚拟环境</li>
<li>安装pyenv、pipenv和pyenv-virtualenv，三个都安装的情况下，我们可以使用pipenv管理依赖包，用pyenv-virtualenv来管理虚拟环境，pyenv配合pyenv-virtualenv切换版本，使用起来比单独使用pipenv或pyenv-virtualenv，都方便许多。</li>
</ol>
<h2 id="pyenv使用"><a href="#pyenv使用" class="headerlink" title="pyenv使用"></a>pyenv使用</h2><h3 id="pyenv安装"><a href="#pyenv安装" class="headerlink" title="pyenv安装"></a>pyenv安装</h3><p>pyenv不支持windows，只支持mac和linux。官方提供了一个安装脚本，安装起来非常简单，它会自动安装<code>pyenv</code>和<code>pyenv-virtualenv</code></p>
<ol>
<li>执行以下命令开始安装<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure></li>
<li>安装完成后需要配置环境变量，根据提示处理即可。<br>一般情况是在 ~&#x2F;.bashrc 里添加如下代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="pyenv卸载"><a href="#pyenv卸载" class="headerlink" title="pyenv卸载"></a>pyenv卸载</h3><p>pyenv安装后会在用户家目录创建一个<code>.pyenv</code>的文件夹。如果要卸载，直接删除这个文件夹，然后将<code>~/.bashrc</code>中，安装时添加的3行代码删除，就可以了。<br>删除<code>.pyenv</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf $(pyenv root)</span><br><span class="line"># 或</span><br><span class="line"># rm -rf ~/.pyenv</span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><p>版本管理<br><code>pyenv versions</code> 查看本机已有版本<br><code>pyenv install -l</code> 查看可安装的版本<br><code>pyenv install 2.7.3</code> 安装指定的版本<br><code>pyenv uninstall 2.7.3</code> 卸载指定的版本</p>
</li>
<li><p>切换版本，分为3种，按优先级排序:shell local global</p>
</li>
</ol>
<p><code>pyenv shell 2.7.3</code> 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。这个版本的优先级比 local 和 global 都要高。<code>–unset</code> 参数可以用于取消当前 shell 设定的版本 <code>pyenv shell --unset</code>。<br><code>pyenv local 2.7.3</code> 设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。这种方式，每次进入目录，执行python命令运行脚本时，会自动使用设置的版本。而且不会影响全局环境<br><code>pyenv global 2.7.3</code>  设置全局的 Python 版本，通过将版本号写入 <del>&#x2F;.pyenv&#x2F;version 文件的方式。这种方式会营销全局环境，要谨慎使用<br><code>pyenv rehash</code> 创建垫片路径（为所有已安装的可执行文件创建 shims，如：</del>&#x2F;.pyenv&#x2F;versions&#x2F;*&#x2F;bin&#x2F;*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）</p>
<ol start="3">
<li>虚拟环境管理</li>
</ol>
<p><code>pyenv virtualenv 2.7.10 env-2.7.10</code> 创建虚拟环境，若不指定 python 版本，会默认使用当前环境 python 版本。如果指定 Python 版本，则一定要是已经安装过的版本，否则会出错。环境的真实目录位于 ~&#x2F;.pyenv&#x2F;versions 下<br><code>pyenv virtualenvs</code> 列出当前虚拟环境<br><code>pyenv activate env-name</code>   激活虚拟环境<br><code>pyenv deactivate</code> 退出虚拟环境，回到系统环境<br><code>pyenv uninstall my-virtual-env</code> 删除虚拟环境，或者直接删除目录<code>rm -rf ~/.pyenv/versions/env-name</code></p>
<blockquote>
<p>小技巧<br>pyenv切换版本，也可以使用虚拟环境，比如可以使用<code>pyenv local env-name</code>，来达到当前目录使用虚拟环境的目的。相比<code>pyenv activate env-name</code>更加方便，每次进入目录自动切换版本。</p>
</blockquote>
<h2 id="pipenv使用"><a href="#pipenv使用" class="headerlink" title="pipenv使用"></a>pipenv使用</h2><h3 id="pipenv安装"><a href="#pipenv安装" class="headerlink" title="pipenv安装"></a>pipenv安装</h3><p>使用pip安装即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pipenv</span><br></pre></td></tr></table></figure>
<p>想要shell 自动补齐，Linux or Mac 环境下，bash下如果能自动命令补全岂不是更好？请把如下语句追加到.bashrc或者.zshrc即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval &quot;$(pipenv --completion)&quot;</span><br></pre></td></tr></table></figure>
<h3 id="pipenv常用命令"><a href="#pipenv常用命令" class="headerlink" title="pipenv常用命令"></a>pipenv常用命令</h3><p><code>pipenv --python 3.6</code> 创建虚拟环境,pipenv 会自动扫描系统寻找合适的版本信息，如果找不到的话，同时又安装了 pyenv 的话，则会自动调用 pyenv 下载对应版本的 python， 否则会报错。<br><code>pipenv shell</code>      进入虚拟环境<br><code>pipenv install urllib3</code>    安装虚拟环境或者第三方库,也可以指定版本<code>pipenv install urllib3==1.22</code><br><code>pipenv uninstall urllib3</code>  卸载一个库，全部卸载使用<code>pipenv uninstall --all</code><br><code>pipenv update urllib3</code>     更新指定包，不带参数<code>pipenv update</code>会卸载当前所有的包，并安装它们的最新版本<br><code>pipenv --where</code> 查看项目根目录<br><code>pipenv --venv</code> 查看虚拟环境目录<br><code>pipenv run</code>        在虚拟环境中运行命令<br><code>pipenv check</code>      检查安全漏洞<br><code>pipenv graph</code>      显示当前依赖关系图信息<br><code>pipenv lock</code>       锁定并生成Pipfile.lock文件<br><code>pipenv open</code>       在编辑器中查看一个库</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/pyenv/pyenv">https://github.com/pyenv/pyenv</a><br><a href="https://github.com/pyenv/pyenv-installer">https://github.com/pyenv/pyenv-installer</a><br><a href="https://github.com/pypa/pipenv">https://github.com/pypa/pipenv</a><br><a href="https://segmentfault.com/a/1190000015389565">https://segmentfault.com/a/1190000015389565</a><br><a href="https://www.xncoding.com/2016/05/09/python/pyenv.html">https://www.xncoding.com/2016/05/09/python/pyenv.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pipenv</tag>
        <tag>pyenv</tag>
        <tag>pyenv-virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>nohup命令说明</title>
    <url>/2019/03/06/2019/nohup%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>nohup是Linux的一个常用命令，当你想要在退出账户或者关闭终端后进程仍在运行时，就可以使用nohup命令。nohup就是不挂断的意思（no hang up）。</p>
<p>nohup的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup command &gt;&gt; file 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>如果不将 nohup 命令的输出重定向，输出将附加到当前目录的 nohup.out 文件中，否则就是自己指定的文件。</p>
<span id="more"></span>

<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup ls / &gt;&gt; /var/logs/ls.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>上面的命令分6部分</p>
<ul>
<li><p>nohup<br>无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。<br>如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME&#x2F;nohup.out 文件中。<br>如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。</p>
<p> 退出状态：该命令返回下列出口值：</p>
</li>
</ul>
<p> 　　<br>　　126 可以查找但不能调用 Command 参数指定的命令。 　　<br>　　127 nohup 命令发生错误或不能查找由 Command 参数指定的命令。 　　<br>　　否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。</p>
<ul>
<li><p>ls &#x2F;<br>这部分位执行命令，可以是任何要执行的命令</p>
</li>
<li><blockquote>
<blockquote>
</blockquote>
<p>输出定向，<code>&gt;&gt;</code>表示追加写入 <code>&gt;</code>表示覆盖写入</p>
</blockquote>
</li>
<li><p>&#x2F;var&#x2F;logs&#x2F;ls.out<br>这部分是输出文件，当指定了这个参数，nohup将不在输出到nohup.out,而是输出到指定的ls.out</p>
</li>
<li><p>2&gt;&amp;1<br>将错误输出定向到标准输出，这样无论什么样的输出，都会输出到ls.out<br>linux中的输出类型如下：</p>
<blockquote>
<p>0 表示stdin标准输入<br>1 表示stdout标准输出<br>2 表示stderr标准错误</p>
</blockquote>
</li>
<li><p>&amp;<br>最后的&amp;，表示让命令在后台运行。一般nohup和&amp;两个一起用</p>
</li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>使用nohup执行命令后，会有一个提示，敲回车确认。然后输入exit退出服务器，这样服务器还会继续执行命令。如果直接关闭终端软件，很可能造成命令被终止。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>系统运维</tag>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title>post传输详解以及axios、php代码实例</title>
    <url>/2019/01/22/2019/post%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8Aaxios%E3%80%81php%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>HTTP&#x2F;1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。</p>
<span id="more"></span>

<p>HTTP&#x2F;1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。</p>
<p>我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP&#x2F;IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure>
<p>协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p>
<p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。</p>
<h2 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h2><p>这应该是最常见的 POST 提交数据的方式了。浏览器的原生 <form> 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line"></span><br><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</span><br></pre></td></tr></table></figure>
<p>首先，Content-Type 被指定为 application&#x2F;x-www-form-urlencoded；其次，提交的数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。<br>时下流行的axios可以用如下方式实现这种类型的传输：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Qs from &#x27;qs&#x27;;</span><br><span class="line">import Axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">let axios = Axios.create(&#123;</span><br><span class="line">  baseURL: baseUrl,</span><br><span class="line">  transformRequest: [function (data) &#123;</span><br><span class="line">    data = Qs.stringify(data);</span><br><span class="line">    return data;</span><br><span class="line">  &#125;],</span><br><span class="line">  headers: &#123;&#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">axios.post(&quot;url&quot;,&#123;&quot;key&quot;:&quot;value&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>服务端比如php可以这样接收</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_POST[&#x27;key&#x27;];</span><br></pre></td></tr></table></figure>

<h2 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h2><p>这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <form> 表单的 enctype 等于 multipart&#x2F;form-data。直接来看一个请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">title</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure>
<p>这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart&#x2F;form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。关于 multipart&#x2F;form-data 的详细定义，请前往 <a href="http://www.ietf.org/rfc/rfc1867.txt">rfc1867</a> 查看。</p>
<p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p>
<p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <form> 表单也只支持<a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4">这两种方式</a>（通过 <form> 元素的 enctype 属性指定，默认为 application&#x2F;x-www-form-urlencoded。其实 enctype 还支持 text&#x2F;plain，不过用得非常少）。</p>
<p>随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</p>
<h2 id="application-json"><a href="#application-json" class="headerlink" title="application&#x2F;json"></a>application&#x2F;json</h2><p>application&#x2F;json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p>
<p>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。<br>最终发送的请求是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: application/json;charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</span><br></pre></td></tr></table></figure>
<p>这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application&#x2F;json 时，从 php:&#x2F;&#x2F;input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。<br>时下流行的axios可以用如下方式实现这种类型的传输：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Qs from &#x27;qs&#x27;;</span><br><span class="line">import Axios from &#x27;axios&#x27;;</span><br><span class="line"></span><br><span class="line">let axios = Axios.create(&#123;</span><br><span class="line">  baseURL: baseUrl,</span><br><span class="line">  headers: &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">axios.post(&quot;url&quot;,&#123;&quot;key&quot;:&quot;value&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>服务端比如php可以这样接收</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$data = json_decode(file_get_contents(&quot;php://input&quot;));</span><br><span class="line">print_r($data);</span><br></pre></td></tr></table></figure>

<p>当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。如有需要，可以参考<a href="http://victorblog.com/2012/12/20/make-angularjs-http-service-behave-like-jquery-ajax/">这篇文章</a>。</p>
<h2 id="text-xml"><a href="#text-xml" class="headerlink" title="text&#x2F;xml"></a>text&#x2F;xml</h2><p>我的博客之前提到过 XML-RPC（XML Remote Procedure Call）。它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</span><br><span class="line">    &lt;params&gt;</span><br><span class="line">        &lt;param&gt;</span><br><span class="line">            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;</span><br><span class="line">        &lt;/param&gt;</span><br><span class="line">    &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure>
<p>XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 XML-RPC Api，搜索引擎的 ping 服务等等。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。</p>
<p>参考<a href="https://imququ.com/post/four-ways-to-post-data-in-http.html">https://imququ.com/post/four-ways-to-post-data-in-http.html</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>http</tag>
        <tag>post</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>shadowsocks-deepin pac模式失效问题解决方案</title>
    <url>/2019/06/24/2019/shadowsocks-deepin-pac%E6%A8%A1%E5%BC%8F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>今天发现无法访问google了，登上服务器看了下没有链接。查看了下本机shadowsocks-deepin是正常启动的。<br>再看代理模式是pac。改成全局模式居然可以正常访问google了。问题原因就发生在pac上了。<br>试着访问了一下<code>http://file.lolimay.cn/autoproxy.pac</code>果然无法访问了。<br>在网上找了一个新的pac配置修改上，真的可以了。目前有效地址<code>https://prudent-travels.000webhostapp.com/pac.php?a=SOCKS5&amp;b=127.0.0.1:1080</code>。</p>
<p>我用的<code>deepin</code>系统其他系统的修改方式可能有差别。具体操作如下：</p>
<span id="more"></span>

<ol>
<li>找到<code>shadowsocks-deepin</code>的配置文件<code>/home/shooke/.config/pikachu/shadowsocks-deepin/gui-config.json</code></li>
<li>将<code>&quot;pacUrl&quot;: &quot;http://file.lolimay.cn/autoproxy.pac&quot;</code>修改为<code>&quot;pacUrl&quot;: &quot;https://prudent-travels.000webhostapp.com/pac.php?a=SOCKS5&amp;b=127.0.0.1:1080&quot;</code></li>
<li>右键小飞机图标-》系统代理模式-》pac模式</li>
</ol>
<p>如果你的小飞机没有bug，应该可以正常访问google了，我的有问题，不知道为什么每次设置，都会编程<code>http://file.lolimay.cn/autoproxy.pac</code>，可能是作者忘了读取配置，将pac写死到了代码里。代码是没法改了，自己再配置一下代理就可以了。<br><strong>每次重启都需要执行下面的步骤</strong></p>
<ol start="4">
<li>打开控制中心-》网络-》系统代理-》自动，将配置URL改为<code>https://prudent-travels.000webhostapp.com/pac.php?a=SOCKS5&amp;b=127.0.0.1:1080</code></li>
</ol>
<p>这样就可以正常访问google了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>shadowsocks-deepin</tag>
        <tag>pac</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>require.context使用说明</title>
    <url>/2019/07/05/2019/require-context%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>require.context是Webpack中用来管理依赖的一个函数，使用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require.context(directory, useSubdirectories = false, regExp = /^\.\//)</span><br></pre></td></tr></table></figure>
<p>第一个参数表示相对的文件目录，<br>第二个参数表示是否包括子目录中的文件，<br>第三个参数表示引入的文件匹配的正则表达式。</p>
<span id="more"></span>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>require.context的返回值是一个函数对象，他提供了一个<code>keys()</code>方法，用来返回遍历到的文件或目录。<br>它自身可以作为函数使用，接收一个文件路径（必须是require.context遍历过的），用来获取文件返回的对象。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── routes</span><br><span class="line">│   ├── overview.js</span><br><span class="line">│   └── settings.js</span><br><span class="line">└── index.js</span><br></pre></td></tr></table></figure>
<p><code>routes/overview.js</code>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    path: &#x27;/overview&#x27;,</span><br><span class="line">    name: &#x27;/overview&#x27;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;查看列表&#x27;,</span><br><span class="line">      auth: true</span><br><span class="line">    &#125;,</span><br><span class="line">    component: _import(&#x27;overview&#x27;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>routes/settings.js</code>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    path: &#x27;/settings&#x27;,</span><br><span class="line">    name: &#x27;/settings&#x27;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;配置&#x27;,</span><br><span class="line">      auth: true</span><br><span class="line">    &#125;,</span><br><span class="line">    component: _import(&#x27;settings&#x27;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>index.js</code>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 返回的files是个函数对象</span><br><span class="line">const files = require.context(&#x27;./routes&#x27;, false, /\.js$/)</span><br><span class="line">let routes = []</span><br><span class="line">// 使用keys()方法获取文件，循环处理每个文件</span><br><span class="line">files.keys().forEach(key =&gt; &#123;  </span><br><span class="line">    // 使用files(key)获取文件对象</span><br><span class="line">    for (let r of files(key)) &#123;</span><br><span class="line">      routes.push(r)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://asyncoder.com/2018/07/07/Webpack%E4%B8%AD%E7%9A%84require.context%E5%A6%99%E7%94%A8/">https://asyncoder.com/2018/07/07/Webpack%E4%B8%AD%E7%9A%84require.context%E5%A6%99%E7%94%A8/</a><br><a href="https://www.jianshu.com/p/78f7b19932cb">https://www.jianshu.com/p/78f7b19932cb</a><br><a href="https://segmentfault.com/a/1190000017160862">https://segmentfault.com/a/1190000017160862</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>python字节和字符串相互转换</title>
    <url>/2019/03/06/2019/python%E5%AD%97%E8%8A%82%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ul>
<li><p>byte 字符串<br>byte_str &#x3D; b”byte example”</p>
</li>
<li><p>str 字符串<br>str_str &#x3D; “str example”</p>
</li>
</ul>
<h2 id="str-to-bytes-字符串转字节"><a href="#str-to-bytes-字符串转字节" class="headerlink" title="str to bytes 字符串转字节"></a>str to bytes 字符串转字节</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes(str_str, encoding=&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str_str.encode()</span><br></pre></td></tr></table></figure>

<h2 id="bytes-to-str-字节转字符串"><a href="#bytes-to-str-字节转字符串" class="headerlink" title="bytes to str  字节转字符串"></a>bytes to str  字节转字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str(byte_str, encoding=&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte_str.decode()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python 字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>su 与 su - 的区别</title>
    <url>/2019/04/24/2019/su-%E4%B8%8E-su-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">su - root</span><br></pre></td></tr></table></figure>

<p>两条命令输入密码后（这里输入的是 root 的密码而不是当前用户的密码），会切换到 root。</p>
<h2 id="su-root"><a href="#su-root" class="headerlink" title="su root"></a>su root</h2><p>只会切换账号，但 shell 还是原有用户的，目录不会切换，环境变量也不会还，与使用 sudo 执行命令差不多。</p>
<h2 id="su-root-1"><a href="#su-root-1" class="headerlink" title="su - root"></a>su - root</h2><p>会彻底切换账户，目录会切换到&#x2F;root 目录，并且环境变量也是 root 的。相当于使用 root 做了登录</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>su</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh提速</title>
    <url>/2019/12/28/2019/ssh%E6%8F%90%E9%80%9F/</url>
    <content><![CDATA[<p>最近ssh链接超慢，但是ping发现网速还是很快的。记录一下解决方法<br>修改<code>/etc/ssh/sshd_config</code>两个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UseDNS no</span><br><span class="line">GSSAPIAuthentication no</span><br></pre></td></tr></table></figure>
<p>保存后重启ssh服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh使用详解</title>
    <url>/2019/06/06/2019/ssh%E4%BD%BF%E7%94%A8%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<p>ssh命令非常强大，除了登录，还可以实现端口转发，达到代理的作用。</p>
<span id="more"></span>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -p 22 root@192.168.56.102</span><br></pre></td></tr></table></figure>
<p>上面的功能是登录一台服务器，<code>-p</code>参数指定端口，ssh默认端口是22，所以上面的命令可以简化为<code>ssh root@192.168.56.102</code></p>
<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; tar czv src | ssh user@host &#x27;tar xz&#x27;</span><br></pre></td></tr></table></figure>
<p>将本地目录打包后，在远程主机解压。相当于将本地目录复制到远程主机。也可以是用<code>scp</code>命令去实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user@host &#x27;tar cz src&#x27; | tar xzv</span><br></pre></td></tr></table></figure>
<p>将远程主机目录打包后，在本地解压。相当于将远程主机目录下载到本地。也可以使用<code>scp</code>命令去实现</p>
<h2 id="绑定本地端口"><a href="#绑定本地端口" class="headerlink" title="绑定本地端口"></a>绑定本地端口</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -D 8080 user@host</span><br></pre></td></tr></table></figure>
<p>上面的命令可以，让本地8080端口的数据，发送到远程服务器。</p>
<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>上面是个最简单的转发，把本地的请求发往指定服务器，但很多时候网络比较复杂。我们可以使用本地端口转发，或者远程端口转发的方式。</p>
<h3 id="1-本地端口转发"><a href="#1-本地端口转发" class="headerlink" title="1. 本地端口转发"></a>1. 本地端口转发</h3><p>将本地的某个端口绑定，将通过该端口的数据发送到指定的远程主机。<br>命令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L 本地端口:目标主机:目标主机端口 中转主机</span><br></pre></td></tr></table></figure>
<p>如host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。<br>在host1执行一下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L 2121:host2:21 host3</span><br></pre></td></tr></table></figure>
<p>命令分为3部分</p>
<ol>
<li>ssh:指令名称</li>
<li>-L 2121:host2:21: <code>-L</code>是命令参数，它接收3个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。</li>
<li>host3：中转主机，host1中发生在2121端口的数据，都会发送到host3，然后由host3进行转发</li>
</ol>
<blockquote>
<p>数据流向：host1:2121-&gt;host3-&gt;host2:21</p>
</blockquote>
<p>经过上面的设置，只要链接host1的2121端口，就等于链接到了host2的21端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># host1</span><br><span class="line">ftp localhost:2121</span><br></pre></td></tr></table></figure>
<p>“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”</p>
<p>思考一个问题如果执行下面的命令，会是什么效果呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L 5900:localhost:5900 host3</span><br></pre></td></tr></table></figure>
<p>答案是，访问本机5900端口，会被转发到host3的5900端口。这里的<code>localhost</code>是已<code>中转主机</code>host3的身份来确定的，host3的localhost当然还是host3了。</p>
<h3 id="2-远程端口转发"><a href="#2-远程端口转发" class="headerlink" title="2. 远程端口转发"></a>2. 远程端口转发</h3><p>远程端口转发，和本地端口转发正好相反，他会把远程主机的端口绑定，将通过该端口的数据发送到指定主机。</p>
<blockquote>
<p>远程端口转发和本地端口转发的区别：<br>远程端口转发是让自己接管远程主机的数据，好比，小明给小芳打电话说，以后你上班做我的车，我送你去。<br>本地端口转发是主动将自己的数据发送给中转主机，好比，小芳给小明打电话，以后我做你的车去上班。</p>
</blockquote>
<p>命令的使用基本一致，只是参数不同，原来的<code>-L</code>换成了<code>-R</code>。<br>命令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -R 远程主机端口:目标主机:目标主机端口 远程主机</span><br></pre></td></tr></table></figure>
<p>还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？</p>
<p>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。</p>
<p>我们在host3执行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># host3</span><br><span class="line">ssh -R 2121:host2:21 host1</span><br></pre></td></tr></table></figure>
<p>命令分为3部分</p>
<ol>
<li>ssh:指令名称</li>
<li>-R 2121:host2:21: <code>-R</code>是命令参数，它接收3个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。</li>
</ol>
<blockquote>
<p>数据流向：host1:2121-&gt;host3-&gt;host2:21</p>
</blockquote>
<p>在host1上执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#host1</span><br><span class="line">ftp localhost:2121</span><br></pre></td></tr></table></figure>
<p>这样host1就可以链接host2了，因为host3将host1的数据转发给了host2.</p>
<h2 id="ssh参数介绍"><a href="#ssh参数介绍" class="headerlink" title="ssh参数介绍"></a>ssh参数介绍</h2><p>常用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -C -f -N -g -L listen_port:DST_Host:DST_port user@Tunnel_Host</span><br><span class="line">ssh -C -f -N -g -R listen_port:DST_Host:DST_port user@Tunnel_Host</span><br><span class="line">ssh -C -f -N -g -D listen_port user@Tunnel_Host</span><br></pre></td></tr></table></figure>
<ol>
<li><p>-f Fork into background after authentication.<br>后台认证用户&#x2F;密码，通常和-N连用，不用登录到远程主机。</p>
</li>
<li><p>-L port:host:hostport<br>将本地机(客户机)的某个端口转发到远端指定机器的指定端口. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 同时远程主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有 root 才能转发特权端口. IPv6 地址用另一种格式说明: port&#x2F;host&#x2F;hostport</p>
</li>
<li><p>-R port:host:hostport<br>将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口. 工作原理是这样的, 远程主机上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转向出去, 同时本地主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有用 root 登录远程主机才能转发特权端口. IPv6 地址用另一种格式说明: port&#x2F;host&#x2F;hostport</p>
</li>
<li><p>-D port<br>指定一个本地机器 “动态的’’ 应用程序端口转发. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 根据应用程序的协议可以判断出远程主机将和哪里连接. 目前支持 SOCKS4 协议, 将充当 SOCKS4 服务器. 只有 root 才能转发特权端口. 可以在配置文件中指定动态端口的转发.</p>
</li>
<li><p>-C Enable compression.<br>压缩数据传输。</p>
</li>
<li><p>-N Do not execute a shell or command.<br>不执行脚本或命令，通常与-f连用。</p>
</li>
<li><p>-g Allow remote hosts to connect to forwarded ports.<br>在-L&#x2F;-R&#x2F;-D参数中，允许远程主机连接到建立的转发的端口，如果不加这个参数，只允许本地主机建立连接。注：这个参数我在实践中似乎始终不起作用。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a><br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html</a><br><a href="http://chenweiguang.blogspot.com/2009/03/ssh.html">http://chenweiguang.blogspot.com/2009/03/ssh.html</a><br><a href="https://blog.csdn.net/left_la/article/details/41519843">https://blog.csdn.net/left_la/article/details/41519843</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>系统运维</tag>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime text 3安装插件</title>
    <url>/2019/05/17/2019/sublime-text-3%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>sublime相比其他编辑器最大的优点就是占用内存小。一直用idea和vscode。好久没用sublime了，今天安装了一下新版本3.2.1，想要用它开发vue。安装插件的过程中踩了几个小坑。</p>
<h2 id="安装package-control"><a href="#安装package-control" class="headerlink" title="安装package control"></a>安装package control</h2><p>使用网上说的，控制台安装方式，按<code>ctrl + \</code> &#96;，输入下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib.request,os; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#x27;wb&#x27;).write(urllib.request.urlopen( &#x27;http://sublime.wbond.net/&#x27; + pf.replace(&#x27; &#x27;,&#x27;%20&#x27;)).read())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>结果发现由于网络问题，根本无法安装。于是手动下载插件包。</p>
<h2 id="手动安装package-control"><a href="#手动安装package-control" class="headerlink" title="手动安装package control"></a>手动安装package control</h2><ol>
<li>去<a href="https://github.com/wbond/package_control/tree/3.3.0%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6">https://github.com/wbond/package_control/tree/3.3.0下载插件</a></li>
<li>把下载好的zip包解压，重命名为Package Control</li>
<li>打开Sublime3，菜单-&gt;Preferences-&gt;Browse Packages…然后复制Package Control文件夹到该目录</li>
<li>重启Sublime3,如果菜单-&gt;Preferences有Package Setting和Package Control就说明安装成功。</li>
<li>Ctrl+Shift+p输入install选中Install Package回车就可以安装插件。</li>
</ol>
<blockquote>
<p>注意去github下载插件一定要选择稳定版，第一次下载了最新的测试版居然报了这个错误：<code>plugin_host has exited unexpectedly,plugin functionality won&#39;t be available until Sublime Text has been restaarted</code></p>
</blockquote>
<h2 id="解决被墙问题"><a href="#解决被墙问题" class="headerlink" title="解决被墙问题"></a>解决被墙问题</h2><p>我在使用的过程中发现无法获取package列表，估计是被墙了，解决方法是<br>Preferences-&gt;Packges Settings-&gt;Package Control-&gt;Setting User<br>在里面加入一下配置就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;channels&quot;: [</span><br><span class="line">		&quot;http://cst.stu.126.net/u/json/cms/channel_v3.json&quot;</span><br><span class="line">	],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果文件已经有了配置，去掉外围的<code>&#123;&#125;</code>即可</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>使用快捷键 <code>Ctl+Shift+P</code>，再选择 <code>Package Control: Install Package</code>。sublime会加载插件列表，左下角有提示，等待加载完毕，回填出新的输入框，搜索需要的插件下载即可。<br>安装过程也会在左下角显示，耐心等等插件安装完毕，一般很快就能安装完</p>
<h3 id="安装vue高亮插件"><a href="#安装vue高亮插件" class="headerlink" title="安装vue高亮插件"></a>安装vue高亮插件</h3><p>使用快捷键 <code>Ctl+Shift+P</code>，再选择 <code>Package Control: Install Package</code>。<br>等一会sublime下载完插件列表，会出现一个新的输入框，这时候输入<code>Vue Syntax Highlight</code>敲回车。就安装上了。</p>
<h3 id="安装eslint插件"><a href="#安装eslint插件" class="headerlink" title="安装eslint插件"></a>安装eslint插件</h3><p>使用快捷键 <code>Ctl+Shift+P</code>，再选择 <code>Package Control: Install Package</code>。<br>等一会sublime下载完插件列表，会出现一个新的输入框，这时候输入<code>SublimeLinter-contrib-eslint</code>敲回车。就安装上了。</p>
<h3 id="安装代码格式化插件CodeFormatter"><a href="#安装代码格式化插件CodeFormatter" class="headerlink" title="安装代码格式化插件CodeFormatter"></a>安装代码格式化插件CodeFormatter</h3><p>使用快捷键 <code>Ctl+Shift+P</code>，再选择 <code>Package Control: Install Package</code>。<br>等一会sublime下载完插件列表，会出现一个新的输入框，这时候输入<code>CodeFormatter</code>敲回车。就安装上了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>sublime</tag>
        <tag>sublime text 3</tag>
        <tag>package_control</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu更新php</title>
    <url>/2019/05/10/2019/ubuntu%E6%9B%B4%E6%96%B0php/</url>
    <content><![CDATA[<p>服务器以前安装的 php7.0，最近开发任务中有部分插件，从 composer 安装提示需要 php7.2 的版本，才可以安装。<br>但是服务器的源里面没有 php7.2，最新的也就 7.0。添加 ppa 搞了一下。记录下步骤</p>
<h2 id="安装-ppa-管理器"><a href="#安装-ppa-管理器" class="headerlink" title="安装 ppa 管理器"></a>安装 ppa 管理器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install software-properties-common</span><br></pre></td></tr></table></figure>

<p>如果已经安装了，可以省略这一步，如果不安装，在执行<code>add-apt-repository</code>命令时会提示<code>sudo: add-apt-repository: command not found</code></p>
<h2 id="添加-ppa-源，并更新源"><a href="#添加-ppa-源，并更新源" class="headerlink" title="添加 ppa 源，并更新源"></a>添加 ppa 源，并更新源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h2 id="升级-php"><a href="#升级-php" class="headerlink" title="升级 php"></a>升级 php</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt remove php7.0</span><br><span class="line">sudo apt-get install php7.2</span><br></pre></td></tr></table></figure>
<p>这样php7.2就安装上了。如果你希望保留老的版本，可以不执行<code>sudo apt remove php7.0</code>。<br>如果希望连同系统一起升级可以执行下面的命令，会连同系统和其他软件一起升级到最新版，只有php会升级到指定的7.2版本。（不建议使用下面的命令）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade php7.2</span><br></pre></td></tr></table></figure>

<h2 id="扩展处理"><a href="#扩展处理" class="headerlink" title="扩展处理"></a>扩展处理</h2><p>升级了<code>php7.2</code>，还需要安装一下7.2的扩展比如mbstring，gd等执行如下命令安装就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php7.2-gd</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>ubuntu</tag>
        <tag>系统运维</tag>
      </tags>
  </entry>
  <entry>
    <title>telnet使用简介</title>
    <url>/2019/07/31/2019/telnet%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="端口开通-链接正常"><a href="#端口开通-链接正常" class="headerlink" title="端口开通,链接正常"></a>端口开通,链接正常</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.100 62715</span><br><span class="line">Trying 192.168.1.100...</span><br><span class="line">Connected to 192.168.1.100.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br></pre></td></tr></table></figure>
<p>链接成功，根据提示<code>Escape character is &#39;^]&#39;</code>.可知退出字符为<code>&#39;^]&#39;</code>（CTRL+]）。此时输入其它字符不能使其退出，CTRL+C都不行。输入CTRL+]后会自动执行，进入命令模式，屏幕上出现<code>telnet&gt;</code>字样。需要输入<code>quit</code>才可退出<br><code>Escape character</code>提示是自定义的，使用参数<code>-e</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet -e p 192.168.1.100 62715   #使用p字符</span><br><span class="line">Telnet escape character is &#x27;p&#x27;.</span><br><span class="line">Trying 192.168.1.100...</span><br><span class="line">Connected to 192.168.1.100.</span><br><span class="line">Escape character is &#x27;p&#x27;.</span><br></pre></td></tr></table></figure>
<p>输入<code>p</code>,会出现<code>telnet&gt;</code>字样，输入<code>quit</code>可退出</p>
<span id="more"></span>

<h2 id="端口不通，无法链接"><a href="#端口不通，无法链接" class="headerlink" title="端口不通，无法链接"></a>端口不通，无法链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.100 62715</span><br><span class="line">Trying 192.168.1.100...</span><br><span class="line">telnet: connect to address 192.168.1.100: Connection refused</span><br></pre></td></tr></table></figure>

<h2 id="链接后，自动退出"><a href="#链接后，自动退出" class="headerlink" title="链接后，自动退出"></a>链接后，自动退出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;&quot; | telnet 192.168.1.100 62715</span><br></pre></td></tr></table></figure>
<p>已成功连通端口并自动退出，显示如下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trying 192.168.1.100...</span><br><span class="line">Connected to 192.168.1.100.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">Connection closed by foreign host.  </span><br></pre></td></tr></table></figure>
<p>如果端口未开放显示如下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trying 192.168.1.100...</span><br><span class="line">telnet: connect to address 192.168.1.100: Connection refused</span><br></pre></td></tr></table></figure>

<h2 id="连接后，延时退出"><a href="#连接后，延时退出" class="headerlink" title="连接后，延时退出"></a>连接后，延时退出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep 2 | telnet 192.168.1.100 62715</span><br></pre></td></tr></table></figure>
<p>sleep 2使得telnet输出结果后，停留2秒后退出命令模式。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.linuxidc.com/Linux/2017-06/145164.htm">http://www.linuxidc.com/Linux/2017-06/145164.htm</a><br><a href="https://www.linuxprobe.com/chapter-09.html">https://www.linuxprobe.com/chapter-09.html</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>系统运维</tag>
        <tag>telnet</tag>
      </tags>
  </entry>
  <entry>
    <title>url添加参数</title>
    <url>/2019/07/17/2019/url%E6%B7%BB%E5%8A%A0%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>微信开发过程中经常用到获取openid后地址跳转，但是要保持原地址的所有参数，再添加上openid参数。函数很简单，也很实用，记录一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function urlAddParam($url, $params)</span><br><span class="line">    &#123;</span><br><span class="line">        $urlParse = parse_url($url);</span><br><span class="line"></span><br><span class="line">        // url协议</span><br><span class="line">        $scheme = empty($urlParse[&#x27;scheme&#x27;]) ? &#x27;&#x27; : $urlParse[&#x27;scheme&#x27;] . &#x27;://&#x27;;</span><br><span class="line">        // host</span><br><span class="line">        $host = empty($urlParse[&#x27;host&#x27;]) ? &#x27;&#x27; : $urlParse[&#x27;host&#x27;];</span><br><span class="line">        // 端口</span><br><span class="line">        $port = empty($urlParse[&#x27;port&#x27;]) ? &#x27;&#x27; : &#x27;:&#x27; . $urlParse[&#x27;port&#x27;];</span><br><span class="line">        // 执行文件</span><br><span class="line">        $path = empty($urlParse[&#x27;path&#x27;]) ? &#x27;&#x27; : $urlParse[&#x27;path&#x27;];</span><br><span class="line">        // 请求参数</span><br><span class="line">        $queryStr = $urlParse[&#x27;query&#x27;] ?? &#x27;&#x27;;</span><br><span class="line">        parse_str($queryStr, $queryArr);</span><br><span class="line">        $queryArr = array_merge($queryArr, $params);</span><br><span class="line">        $query = http_build_query($queryArr);</span><br><span class="line">        $query = empty($query) ? &#x27;&#x27; : &#x27;?&#x27; . $query;</span><br><span class="line">        // 锚点链接</span><br><span class="line">        $fragment = empty($urlParse[&#x27;fragment&#x27;]) ? &#x27;&#x27; : &#x27;#&#x27; . $urlParse[&#x27;fragment&#x27;];</span><br><span class="line"></span><br><span class="line">        return $scheme . $host . $port . $path . $query . $fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    echo urlAddParam(&#x27;https://gitee.com/shooke/codes/new&#x27;, [&#x27;openid&#x27;=&gt;&#x27;sdfsdfoihnwoixchow==&#x27;]);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>代码块</tag>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 保存自动按eslint格式化</title>
    <url>/2019/03/27/2019/vscode-%E4%BF%9D%E5%AD%98%E8%87%AA%E5%8A%A8%E6%8C%89eslint%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>三步走：</p>
<ol>
<li>安装 vuter，eslint，Prettier-code fromatter<br>vuter 是 vue 高高亮插件，安装后 vscode 就可以识别<code>.vue</code>文件了</li>
<li>配置 vscode 首选项<br>选择 file 》Preferences 》Settings 打开配置。然后选择 User Settings，点击右上角的<code>&#123;&#125;</code>按钮，进入文本编辑状态</li>
<li>配置内容</li>
</ol>
<span id="more"></span>

<p>将下面的内容复制到配置里就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;workbench.editor.enablePreview&quot;: false, //打开文件不覆盖</span><br><span class="line">  &quot;search.followSymlinks&quot;: false, //关闭rg.exe进程</span><br><span class="line">  &quot;editor.minimap.enabled&quot;: false, //关闭快速预览</span><br><span class="line">  &quot;files.autoSave&quot;: &quot;afterDelay&quot;, //打开自动保存</span><br><span class="line">  &quot;editor.lineNumbers&quot;: &quot;on&quot;, //开启行数提示</span><br><span class="line">  &quot;editor.quickSuggestions&quot;: &#123;</span><br><span class="line">    //开启自动显示建议</span><br><span class="line">    &quot;other&quot;: true,</span><br><span class="line">    &quot;comments&quot;: true,</span><br><span class="line">    &quot;strings&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;editor.tabSize&quot;: 2, //制表符符号eslint</span><br><span class="line">  &quot;editor.formatOnSave&quot;: true, //每次保存自动格式化</span><br><span class="line">  &quot;eslint.autoFixOnSave&quot;: true, // 每次保存的时候将代码按eslint格式进行修复</span><br><span class="line">  &quot;prettier.eslintIntegration&quot;: true, //让prettier使用eslint的代码格式进行校验</span><br><span class="line">  &quot;prettier.semi&quot;: false, //去掉代码结尾的分号</span><br><span class="line">  &quot;prettier.singleQuote&quot;: true, //使用带引号替代双引号</span><br><span class="line">  &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, //让函数(名)和后面的括号之间加个空格</span><br><span class="line">  &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;, //格式化.vue中html</span><br><span class="line">  &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;, //让vue中的js按编辑器自带的ts格式进行格式化</span><br><span class="line">  &quot;vetur.format.defaultFormatterOptions&quot;: &#123;</span><br><span class="line">    &quot;js-beautify-html&quot;: &#123;</span><br><span class="line">      &quot;wrap_attributes&quot;: &quot;force-aligned&quot; //属性强制折行对齐</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslint.validate&quot;: [</span><br><span class="line">    //开启对.vue文件中错误的检查</span><br><span class="line">    &quot;javascript&quot;,</span><br><span class="line">    &quot;javascriptreact&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;language&quot;: &quot;html&quot;,</span><br><span class="line">      &quot;autoFix&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;language&quot;: &quot;vue&quot;,</span><br><span class="line">      &quot;autoFix&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>vscode</tag>
        <tag>vue</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode打造php开发环境</title>
    <url>/2019/06/20/2019/vscode%E6%89%93%E9%80%A0php%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><p>借助于 PHP DocBlocker 插件，可以快速地在类名、变量名、方法&#x2F;函数名 上方添加注释。</p>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>借助于 PHP Intelephense 插件，可以实现代码智能提示。<br>安装后选择 file-&gt;preferences-&gt;settings 选择右上角<code>&#123;&#125;</code>进入配置模式，添加<code>&quot;php.executablePath&quot;: &quot;/usr/bin/php&quot;</code>，配置上php的路径</p>
<h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><p>借助于 php-cs-fixer 插件，可以方便地按照某一规则格式化代码，让你时刻保持代码可读性和风格统一。</p>
<span id="more"></span>

<h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><p>借助于 XDebug 插件，可以实现代码调试。</p>
<h2 id="修改历史"><a href="#修改历史" class="headerlink" title="修改历史"></a>修改历史</h2><p>借助于 Git Lens 插件，可以方便地查看每行代码的修改历史。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>开发工具</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3预渲染处理</title>
    <url>/2019/07/13/2019/vue-cli3%E9%A2%84%E6%B8%B2%E6%9F%93%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>vue模块化开发很方便，但也有问题，那就是seo。解决seo问题有两种方案，一种是ssr(服务端渲染)，还有一种是预渲染，只针对部分需要seo的页面进行渲染即可。</p>
<span id="more"></span>
<h2 id="预渲染配置步骤"><a href="#预渲染配置步骤" class="headerlink" title="预渲染配置步骤"></a>预渲染配置步骤</h2><ol>
<li>安装预渲染插件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install prerender-spa-plugin --save-dev</span><br></pre></td></tr></table></figure></li>
<li>配置vue.config.js中的webpack设置，因为预渲染就是基于webpack打包的过程中实现的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这三项一定要有，因为下面configureWebpack中用到了</span><br><span class="line">const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;);</span><br><span class="line">const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 预渲染关键配置</span><br><span class="line">  configureWebpack: () =&gt; &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27;) return;</span><br><span class="line">    return &#123;</span><br><span class="line">      plugins: [</span><br><span class="line">        new PrerenderSPAPlugin(&#123;</span><br><span class="line">          // 生成文件的路径，也可以与webpakc打包的一致。</span><br><span class="line">          // 下面这句话非常重要！！！</span><br><span class="line">          // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。</span><br><span class="line">          staticDir: path.join(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  </span><br><span class="line">          // 对应自己的路由文件，如果有参数需要写具体参数，比如/a/:id需要写/a/123456</span><br><span class="line">          routes: [&#x27;/&#x27;, &#x27;/about&#x27;],</span><br><span class="line">  </span><br><span class="line">          // 这个很重要，如果没有配置这段，也不会进行预编译</span><br><span class="line">          renderer: new Renderer(&#123;</span><br><span class="line">            inject: &#123;</span><br><span class="line">              foo: &#x27;bar&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            headless: false,</span><br><span class="line">            // 在 main.js 中 document.dispatchEvent(new Event(&#x27;render-event&#x27;))，两者的事件名称要对应上。</span><br><span class="line">            renderAfterDocumentEvent: &#x27;render-event&#x27;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改<code>mian.js</code>，上面配置中有个<code>renderAfterDocumentEvent</code>设置了一个事件，如果<code>main.js</code>需要在<code>mounted</code>时监听事件，否则不会执行预渲染<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: (h) =&gt; h(App),</span><br><span class="line">  // 添加mounted，不然不会执行预编译</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    document.dispatchEvent(new Event(&#x27;render-event&#x27;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure></li>
<li>执行<code>npm run build</code>进行编译。在编译的过程中会弹出一个浏览器窗口对每个预编译的页面进行展示，不要关闭它，等渲染完毕，它会自动关闭的。</li>
</ol>
<h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p><a href="https://gitee.com/shooke/vue-demo/tree/master/vue-demo-prerender">https://gitee.com/shooke/vue-demo/tree/master/vue-demo-prerender</a></p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>vue-cli2预渲染请看<a href="https://juejin.im/post/5b8ba25751882542f25a6cc8">https://juejin.im/post/5b8ba25751882542f25a6cc8</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>vue</tag>
        <tag>vue-cli</tag>
        <tag>预渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex getters不更新的奇怪现象解决方案</title>
    <url>/2019/05/23/2019/vuex-getters%E4%B8%8D%E6%9B%B4%E6%96%B0%E7%9A%84%E5%A5%87%E6%80%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>今天写代码的时候遇到一个很奇怪的问题，getter里面取到的值怎么都不是最新的。<br>调用setAuth清空后，从vue开发工具(vue-Devtools)中查看，<code>state.auth</code>已经正常被设置成了空值。但是<code>getters</code>或<code>mapGetters</code>取到的还是更新前的值。</p>
<span id="more"></span>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import Vuex from &quot;vuex&quot;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    auth: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getAuth(state) &#123;</span><br><span class="line">      let localuser = window.localStorage.getItem(&quot;auth&quot;);</span><br><span class="line">      if (localuser) &#123;</span><br><span class="line">        return localuser;</span><br><span class="line">      &#125;</span><br><span class="line">      return state.auth;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setAuth(state, value) &#123;</span><br><span class="line">      window.localStorage.setItem(&quot;auth&quot;, value);</span><br><span class="line">      state.auth = value;</span><br><span class="line">      // Vue.set(state, &quot;auth&quot;, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>网上查了资料，有人说是无法跟踪<code>state</code>，让使用<code>Vue.set(state, &quot;auth&quot;, value)</code>，就是上面注释掉的代码。但其实也是无效的。<br>最后终于找到了解决方法，那就是在getters的方法里面一定要返回<code>state.auth</code>,绝对不能返回其他值。最终修改后是下面的样子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import Vuex from &quot;vuex&quot;;</span><br><span class="line">import state from &quot;./state&quot;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getAuth(state) &#123;</span><br><span class="line">      let localuser = window.localStorage.getItem(&quot;auth&quot;);</span><br><span class="line">      if (localuser) &#123;</span><br><span class="line">        state.auth = localuser;</span><br><span class="line">      &#125;</span><br><span class="line">      return state.auth;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setAuth(state, value) &#123;</span><br><span class="line">      window.localStorage.setItem(&quot;auth&quot;, value);</span><br><span class="line">      state.auth = value;</span><br><span class="line">      // Vue.set(state, &quot;auth&quot;, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
        <tag>getters</tag>
      </tags>
  </entry>
  <entry>
    <title>vue下使用ueditor，文件直传七牛踩坑记录</title>
    <url>/2019/07/08/2019/vue%E4%B8%8B%E4%BD%BF%E7%94%A8ueditor%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9B%B4%E4%BC%A0%E4%B8%83%E7%89%9B%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近的项目中，需要一个牛X点的文本编辑器。于是选择了ueditor。百度出品，功能完善。<br>前端框架使用了d2admin,选择它的理由很简单，许多的常用工具做了封装。<br>项目要求文件上传要绕过后端程序，前端直接传文件到七牛CDN。</p>
<span id="more"></span>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>执行<code>npm i vue-ueditor-wrap</code>安装<code>vue-ueditor-wrap</code>插件</li>
<li>修改<code>main.js</code>,添加如下代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import VueUeditorWrap from &#x27;vue-ueditor-wrap&#x27;</span><br><span class="line">Vue.component(&#x27;vue-ueditor-wrap&#x27;, VueUeditorWrap)</span><br></pre></td></tr></table></figure></li>
<li>创建一个组件封装一下，方便项目中使用，复制一下官方实例的<code>src/components/d2-ueditor</code>目录到对应的目录</li>
<li>设置ueditor的目录，修改<code>src/components/d2-ueditor/ueditor.config.js</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // ueditor文件的目录</span><br><span class="line">  UEDITOR_HOME_URL: &#x27;/lib/ueditor-qn/&#x27;,</span><br><span class="line">  // 编辑器不自动被内容撑高</span><br><span class="line">  autoHeightEnabled: false,</span><br><span class="line">  // 初始容器高度</span><br><span class="line">  initialFrameHeight: 240,</span><br><span class="line">  // 初始容器宽度</span><br><span class="line">  initialFrameWidth: &#x27;100%&#x27;,</span><br><span class="line">  // 关闭自动保存</span><br><span class="line">  enableAutoSave: false,</span><br><span class="line">  // 文件上传处理</span><br><span class="line">  serverUrl: &#x27;http://localhost/php/controller.php&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
UEDITOR_HOME_URL的路径是相对于根目录的，比如上面的配置就是，放在<code>public/lib/ueditor-qn</code>下</li>
<li>下载ueditor文件放到，第4步设置的目录下。因为要用到七牛，所以这里就不用官方的版本了，改用七牛版本的ueditor。<br>去这里下载就可以了<a href="https://github.com/widuu/qiniu_ueditor_1.4.3%E3%80%82%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E5%B0%86%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E5%88%B0%60public/lib/ueditor-qn%60%E7%9B%AE%E5%BD%95%E4%B8%8B%E3%80%82">https://github.com/widuu/qiniu_ueditor_1.4.3。下载完成后将文件拷贝到`public/lib/ueditor-qn`目录下。</a><br>将php文件夹里的内容，复制到一个可访问的目录，要确保用上面<code>serverUrl</code>配置的地址可以访问到</li>
</ol>
<h2 id="坑点记录"><a href="#坑点记录" class="headerlink" title="坑点记录"></a>坑点记录</h2><ol>
<li>七牛版的ueditor有个bug，需要修改一下。<code>php/config.json</code>文件的第17行，使用了<code>//</code>注释，语法错误了应该使用<code>/**/</code>修改一下</li>
<li><code>dialogs/image/image.js</code> <code>dialogs/attachment/attachment.js</code> <code>dialogs/video/video.js</code>这三个文件ajax处理有问题，<code>uploadBeforeSend</code>事件获取token的时候，如果前后端跨域了，就有问题。<br>搜索<code>dataType : isJsonp ? &#39;jsonp&#39;:&#39;json&#39;</code><br>jquery的ajax处理如果是jsonp方式，async设置就失效了，会自动变成true，使得ajax请求变成了异步处理。这样会造成上传是找不到token。项目中前后端存在跨域时，这个地方直接改成<code>dataType : &#39;json&#39;</code>就可以了。</li>
<li>上传接口有身份验证，处理的方式和第2条一样，在<code>uploadBeforeSend</code>阶段增加需要身份验证的header信息就可以了。</li>
<li>前后端跨域问题，给<code>php/controller.php</code>添加跨域处理<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 星号是允许所有主机，方法和头信息，可以根据实际情况进行修改</span><br><span class="line">header(&#x27;Access-Control-Allow-Origin:*&#x27;);</span><br><span class="line">header(&#x27;Access-Control-Allow-Methods:*&#x27;);  </span><br><span class="line">header(&#x27;Access-Control-Allow-Headers:*&#x27;); </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/widuu/qiniu_ueditor_1.4.3">https://github.com/widuu/qiniu_ueditor_1.4.3</a><br><a href="https://doc.d2admin.fairyever.com/zh/sys-components/ueditor.html">https://doc.d2admin.fairyever.com/zh/sys-components/ueditor.html</a><br><a href="https://github.com/d2-projects/d2-admin">https://github.com/d2-projects/d2-admin</a><br><a href="https://github.com/HaoChuan9421/vue-ueditor-wrap">https://github.com/HaoChuan9421/vue-ueditor-wrap</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>vue</tag>
        <tag>d2admin</tag>
        <tag>ueditor</tag>
        <tag>七牛</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中使用neditor</title>
    <url>/2019/09/03/2019/vue%E4%B8%AD%E4%BD%BF%E7%94%A8neditor/</url>
    <content><![CDATA[<p>neditor是从ueditor改写过来了，做了不少优化，我最喜欢的就是去掉了服务端附件配置请求。还有一个有点就是，可以很方便的对接七牛cdn或oss。<br>如果是简单的使用可以用<code>vue-neditor-wrap</code>,复杂场景下会有bug，所以自己写了个组件，将必要的js引入放到了index.html中。下面是使用注意事项，追后有本示例的源码。</p>
<span id="more"></span>

<h2 id="将neditor放到项目中"><a href="#将neditor放到项目中" class="headerlink" title="将neditor放到项目中"></a>将neditor放到项目中</h2><p>这里将neditor放到&#x2F;public下</p>
<h2 id="配合public-index-html添加neditor引用"><a href="#配合public-index-html添加neditor引用" class="headerlink" title="配合public&#x2F;index.html添加neditor引用"></a>配合public&#x2F;index.html添加neditor引用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%= BASE_URL %&gt;lib/neditor/neditor.config.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%= BASE_URL %&gt;lib/neditor/neditor.all.min.js&quot;&gt; &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="创建一个模块初始化neditor"><a href="#创建一个模块初始化neditor" class="headerlink" title="创建一个模块初始化neditor"></a>创建一个模块初始化neditor</h2><p>components&#x2F;neditor&#x2F;index.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;script :id=&quot;id&quot; :name=&quot;name&quot; type=&quot;text/plain&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import config from &#x27;./ueditor.config&#x27;</span><br><span class="line">// 一个简单的事件订阅发布的实现,取代原始Event对象,提升IE下的兼容性</span><br><span class="line">class LoadEvent &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.listeners = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  on (eventName, callback) &#123;</span><br><span class="line">    this.listeners[eventName] === undefined</span><br><span class="line">      ? (this.listeners[eventName] = [])</span><br><span class="line">      : &#x27;&#x27;</span><br><span class="line">    this.listeners[eventName].push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  emit (eventName) &#123;</span><br><span class="line">    this.listeners[eventName] &amp;&amp;</span><br><span class="line">      this.listeners[eventName].forEach(callback =&gt; callback())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;VueNeditorWrap&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      id:</span><br><span class="line">        &#x27;editor&#x27; +</span><br><span class="line">        Math.random()</span><br><span class="line">          .toString()</span><br><span class="line">          .slice(-10),</span><br><span class="line">      editor: null,</span><br><span class="line">      isReady: false, // 实例是否已经ready</span><br><span class="line">      readyValue: &#x27;&#x27;, // ready之后给编辑器设置的值</span><br><span class="line">      defaultConfig: &#123;</span><br><span class="line">        UEDITOR_HOME_URL: &#x27;./public/NEditor/&#x27;,</span><br><span class="line">        enableAutoSave: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    config: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    init: &#123;</span><br><span class="line">      type: Function,</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return () =&gt; &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    destroy: Boolean,</span><br><span class="line">    name: String</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    mixedConfig () &#123;</span><br><span class="line">      return Object.assign(&#123;&#125;, this.defaultConfig, config)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 添加自定义按钮</span><br><span class="line">    registerButton: (&#123; name, icon, tip, handler, UE = window.UE &#125;) =&gt; &#123;</span><br><span class="line">      UE.registerUI(name, (editor, name) =&gt; &#123;</span><br><span class="line">        editor.registerCommand(name, &#123;</span><br><span class="line">          execCommand: () =&gt; &#123;</span><br><span class="line">            handler(editor, name)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        const btn = new UE.ui.Button(&#123;</span><br><span class="line">          name,</span><br><span class="line">          title: tip,</span><br><span class="line">          cssRules: `background-image: url($&#123;icon&#125;) !important;background-size: cover;`,</span><br><span class="line">          onclick () &#123;</span><br><span class="line">            editor.execCommand(name)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        editor.addListener(&#x27;selectionchange&#x27;, () =&gt; &#123;</span><br><span class="line">          const state = editor.queryCommandState(name)</span><br><span class="line">          if (state === -1) &#123;</span><br><span class="line">            btn.setDisabled(true)</span><br><span class="line">            btn.setChecked(false)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            btn.setDisabled(false)</span><br><span class="line">            btn.setChecked(state)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        return btn</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 实例化编辑器之前-JS依赖检测</span><br><span class="line">    _beforeInitEditor (value) &#123;</span><br><span class="line">      // console.log(&#x27;_beforeInitEditor&#x27;, value + &#x27;--&#x27;)</span><br><span class="line">      // 准确判断ueditor.config.js和ueditor.all.js是否均已加载 仅加载完ueditor.config.js时UE对象和UEDITOR_CONFIG对象也存在,仅加载完ueditor.all.js时UEDITOR_CONFIG对象也存在,但为空对象</span><br><span class="line">      !!window.UE &amp;&amp;</span><br><span class="line">      !!window.UEDITOR_CONFIG &amp;&amp;</span><br><span class="line">      Object.keys(window.UEDITOR_CONFIG).length !== 0 &amp;&amp;</span><br><span class="line">      !!window.UE.getEditor</span><br><span class="line">        ? this._initEditor(value)</span><br><span class="line">        : this._loadScripts().then(() =&gt; this._initEditor(value))</span><br><span class="line">    &#125;,</span><br><span class="line">    // 实例化编辑器</span><br><span class="line">    _initEditor (value) &#123;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.init()</span><br><span class="line">        this.editor = window.UE.getEditor(this.id, this.mixedConfig)</span><br><span class="line">        this.readyValue = value</span><br><span class="line">        this.editor.addListener(&#x27;ready&#x27;, () =&gt; &#123;</span><br><span class="line">          this.isReady = true</span><br><span class="line">          this.$emit(&#x27;ready&#x27;, this.editor)</span><br><span class="line">          this.editor.setContent(this.readyValue)</span><br><span class="line">          this.editor.addListener(&#x27;contentChange&#x27;, () =&gt; &#123;</span><br><span class="line">            // console.log(&#x27;input&#x27;, this.editor.getContent())</span><br><span class="line">            this.$emit(&#x27;input&#x27;, this.editor.getContent())</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 动态添加JS依赖</span><br><span class="line">    _loadScripts () &#123;</span><br><span class="line">      // 确保多个实例同时渲染时不会重复创建SCRIPT标签</span><br><span class="line">      if (window.loadEnv) &#123;</span><br><span class="line">        return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          window.loadEnv.on(&#x27;scriptsLoaded&#x27;, function () &#123;</span><br><span class="line">            resolve()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        window.loadEnv = new LoadEvent()</span><br><span class="line">        return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          // 如果在其他地方只引用ueditor.all.min.js，在加载ueditor.config.js之后仍需要重新加载ueditor.all.min.js，所以必须确保ueditor.config.js已加载</span><br><span class="line">          // this._loadService().then(() =&gt; this._loadConfig()).then(() =&gt; this._loadCore()).then(() =&gt; &#123;</span><br><span class="line">          //   window.loadEnv.emit(&quot;scriptsLoaded&quot;);</span><br><span class="line">          //   resolve();</span><br><span class="line">          // &#125;);</span><br><span class="line">          const that = this</span><br><span class="line">          that._loadParse().then(() =&gt; that._loadConfig()).then(() =&gt; that._loadCore()).then(() =&gt; that._loadService()).then(() =&gt; &#123;</span><br><span class="line">            window.loadEnv.emit(&#x27;scriptsLoaded&#x27;)</span><br><span class="line">            resolve()</span><br><span class="line">          &#125;).catch(err =&gt; &#123;</span><br><span class="line">            console.error(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    _loadConfig () &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        if (</span><br><span class="line">          !!window.UE &amp;&amp;</span><br><span class="line">          !!window.UEDITOR_CONFIG &amp;&amp;</span><br><span class="line">          Object.keys(window.UEDITOR_CONFIG).length !== 0</span><br><span class="line">        ) &#123;</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    _loadService () &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let coreScript = document.createElement(&#x27;script&#x27;)</span><br><span class="line">        coreScript.type = &#x27;text/javascript&#x27;</span><br><span class="line">        coreScript.src = this.mixedConfig.UEDITOR_HOME_URL + &#x27;neditor.service.js&#x27;</span><br><span class="line">        document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(coreScript)</span><br><span class="line">        coreScript.onload = function () &#123;</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    _loadParse () &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let coreScript = document.createElement(&#x27;script&#x27;)</span><br><span class="line">        coreScript.type = &#x27;text/javascript&#x27;</span><br><span class="line">        coreScript.src =</span><br><span class="line">          this.mixedConfig.UEDITOR_HOME_URL + &#x27;neditor.parse.min.js&#x27;</span><br><span class="line">        document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(coreScript)</span><br><span class="line">        coreScript.onload = function () &#123;</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    _loadCore () &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 设置内容</span><br><span class="line">    _setContent (value) &#123;</span><br><span class="line">      if (this.isReady) &#123;</span><br><span class="line">        // console.log(&#x27;setContentisReady&#x27;, value)</span><br><span class="line">        value === this.editor.getContent() || this.editor.setContent(value)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // console.log(&#x27;noisReady&#x27;, value)</span><br><span class="line">        this.readyValue = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    if (this.destroy &amp;&amp; this.editor &amp;&amp; this.editor.destroy) &#123;</span><br><span class="line">      this.editor.destroy()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // v-model语法糖实现</span><br><span class="line">  watch: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      handler (value) &#123;</span><br><span class="line">        // console.log(&#x27;vvv===&#x27;, value)</span><br><span class="line">        this.editor ? this._setContent(value) : this._beforeInitEditor(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>components&#x2F;neditor&#x2F;neditor.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  UEDITOR_HOME_URL: process.env.BASE_URL + &#x27;neditor/&#x27;,</span><br><span class="line">  // 编辑器不自动被内容撑高</span><br><span class="line">  autoHeightEnabled: false,</span><br><span class="line">  // 初始容器高度</span><br><span class="line">  initialFrameHeight: 350,</span><br><span class="line">  // 初始容器宽度</span><br><span class="line">  initialFrameWidth: &#x27;100%&#x27;,</span><br><span class="line">  catchRemoteImageEnable: false,</span><br><span class="line">  imageMaxSize: 10248000, // 上传大小限制，单位B</span><br><span class="line">  zIndex: 9999,</span><br><span class="line">  // 关闭自动保存</span><br><span class="line">  enableAutoSave: false,</span><br><span class="line">  // serverUrl: &#x27;http://localhost/php/controller.php&#x27;</span><br><span class="line">  serverUrl: &#x27;&#x27;,</span><br><span class="line"></span><br><span class="line">  imageUploadService: function (context, editor) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      /** </span><br><span class="line">       * 触发fileQueued事件时执行</span><br><span class="line">       * 当文件被加入队列以后触发，用来设置上传相关的数据 (比如: url和自定义参数)</span><br><span class="line">       * @param &#123;Object&#125; file 当前选择的文件对象</span><br><span class="line">       */</span><br><span class="line">      setUploadData: function (file) &#123;</span><br><span class="line">        return file;</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 触发uploadBeforeSend事件时执行</span><br><span class="line">       * 在文件上传之前触发，用来添加附带参数</span><br><span class="line">       * @param &#123;Object&#125; object 当前上传对象</span><br><span class="line">       * @param &#123;Object&#125; data 默认的上传参数，可以扩展此对象来控制上传参数</span><br><span class="line">       * @param &#123;Object&#125; headers 可以扩展此对象来控制上传头部</span><br><span class="line">       * @returns 上传参数对象</span><br><span class="line">       */</span><br><span class="line">      setFormData: function (object, data, headers) &#123;</span><br><span class="line">        return data;</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 触发startUpload事件时执行</span><br><span class="line">       * 当开始上传流程时触发，用来设置Uploader配置项</span><br><span class="line">       * @param &#123;Object&#125; uploader</span><br><span class="line">       * @returns uploader</span><br><span class="line">       */</span><br><span class="line">      setUploaderOptions: function (uploader) &#123;</span><br><span class="line">        return uploader;</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 触发uploadSuccess事件时执行</span><br><span class="line">       * 当文件上传成功时触发，可以在这里修改上传接口返回的response对象</span><br><span class="line">       * @param &#123;Object&#125; res 上传接口返回的response</span><br><span class="line">       * @returns &#123;Boolean&#125; 上传接口返回的response成功状态条件 (比如: res.code == 200)</span><br><span class="line">       */</span><br><span class="line">      getResponseSuccess: function (res) &#123;</span><br><span class="line">        return res.code == 200;</span><br><span class="line">      &#125;,</span><br><span class="line">      /* 指定上传接口返回的response中图片路径的字段，默认为 url</span><br><span class="line">       * 如果图片路径字段不是res的属性，可以写成 对象.属性 的方式，例如：data.url </span><br><span class="line">       * */</span><br><span class="line">      imageSrcField: &#x27;url&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 视频上传service</span><br><span class="line">   * @param &#123;Object&#125; context UploadVideo对象 视频上传上下文</span><br><span class="line">   * @param &#123;Object&#125; editor  编辑器对象</span><br><span class="line">   * @returns videoUploadService 对象</span><br><span class="line">   */</span><br><span class="line">  videoUploadService: function (context, editor) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      /** </span><br><span class="line">       * 触发fileQueued事件时执行</span><br><span class="line">       * 当文件被加入队列以后触发，用来设置上传相关的数据 (比如: url和自定义参数)</span><br><span class="line">       * @param &#123;Object&#125; file 当前选择的文件对象</span><br><span class="line">       */</span><br><span class="line">      setUploadData: function (file) &#123;</span><br><span class="line">        return file;</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 触发uploadBeforeSend事件时执行</span><br><span class="line">       * 在文件上传之前触发，用来添加附带参数</span><br><span class="line">       * @param &#123;Object&#125; object 当前上传对象</span><br><span class="line">       * @param &#123;Object&#125; data 默认的上传参数，可以扩展此对象来控制上传参数</span><br><span class="line">       * @param &#123;Object&#125; headers 可以扩展此对象来控制上传头部</span><br><span class="line">       * @returns 上传参数对象</span><br><span class="line">       */</span><br><span class="line">      setFormData: function (object, data, headers) &#123;</span><br><span class="line">        return data;</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 触发startUpload事件时执行</span><br><span class="line">       * 当开始上传流程时触发，用来设置Uploader配置项</span><br><span class="line">       * @param &#123;Object&#125; uploader</span><br><span class="line">       * @returns uploader</span><br><span class="line">       */</span><br><span class="line">      setUploaderOptions: function (uploader) &#123;</span><br><span class="line">        return uploader;</span><br><span class="line">      &#125;,</span><br><span class="line">      /**</span><br><span class="line">       * 触发uploadSuccess事件时执行</span><br><span class="line">       * 当文件上传成功时触发，可以在这里修改上传接口返回的response对象</span><br><span class="line">       * @param &#123;Object&#125; res 上传接口返回的response</span><br><span class="line">       * @returns &#123;Boolean&#125; 上传接口返回的response成功状态条件 (比如: res.code == 200)</span><br><span class="line">       */</span><br><span class="line">      getResponseSuccess: function (res) &#123;</span><br><span class="line">        return res.code == 200;</span><br><span class="line">      &#125;,</span><br><span class="line">      /* 指定上传接口返回的response中视频路径的字段，默认为 url</span><br><span class="line">       * 如果视频路径字段不是res的属性，可以写成 对象.属性 的方式，例如：data.url </span><br><span class="line">       * */</span><br><span class="line">      videoSrcField: &#x27;url&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="在使用组件的地方调用即可"><a href="#在使用组件的地方调用即可" class="headerlink" title="在使用组件的地方调用即可"></a>在使用组件的地方调用即可</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;Neditor v-model=&quot;content&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// @ is an alias to /src</span><br><span class="line">import Neditor from &#x27;@/components/neditor/index.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;home&#x27;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content: &#x27;hello&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Neditor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="实例源码"><a href="#实例源码" class="headerlink" title="实例源码"></a>实例源码</h2><p><a href="https://gitee.com/shooke/vue-demo/tree/master/neditor">https://gitee.com/shooke/vue-demo/tree/master/neditor</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/caiya/vue-neditor-wrap">https://github.com/caiya/vue-neditor-wrap</a><br><a href="https://github.com/notadd/neditor">https://github.com/notadd/neditor</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ueditor</tag>
        <tag>neditor</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件之插槽</title>
    <url>/2019/05/09/2019/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<p>这篇文章的写作时间是 vue2.6 发布后，因此适用于 2.6 以后的版本<br>插槽是 vue 组件中很重要的一环，他解决了组件内容自定义的问题。以及父子组件变量传递的问题（作用域插槽）。<br>在 2.6 以后的版本中，具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)，它取代了 slot 和 slot-scope 。这两个老的已经进入废弃期，为了保持平滑升级，目前还可以使用，但是不推荐使用。后期会被移除。</p>
<span id="more"></span>

<h2 id="简单插槽使用"><a href="#简单插槽使用" class="headerlink" title="简单插槽使用"></a>简单插槽使用</h2><p><code>v-slot.vue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;v-slot&quot;&gt;</span><br><span class="line">    &lt;span&gt;我是简单v-solt：&lt;/span&gt;</span><br><span class="line">    &lt;slot&gt;你现在看到的是默认内容&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;v-slot&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在其他组件中使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;v-slot&gt;&lt;/v-slot&gt;</span><br><span class="line">&lt;v-slot&gt;现在看到的是自定义内容&lt;/v-slot&gt;</span><br></pre></td></tr></table></figure>

<h2 id="具名插槽使用"><a href="#具名插槽使用" class="headerlink" title="具名插槽使用"></a>具名插槽使用</h2><p><code>v-slot-name.vue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;v-slot&quot;&gt;</span><br><span class="line">    &lt;span&gt;我是具名v-solt-name：&lt;/span&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;slot name=&quot;header&quot;&gt;header默认&lt;/slot&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">      &lt;slot&gt;默认main&lt;/slot&gt;</span><br><span class="line">    &lt;/main&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;v-slot-name&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在其他模块中使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;新的使用方式 使用v-slot:插槽名称&lt;/h2&gt;</span><br><span class="line">    &lt;v-slot-name&gt;</span><br><span class="line">      &lt;template v-slot:header&gt;</span><br><span class="line">        自定义header</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;p&gt;没有指定v-slot名称，自定义main&lt;/p&gt;</span><br><span class="line">    &lt;/v-slot-name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;老的使用方式 使用slot=&quot;插槽名称&quot;&lt;/h2&gt;</span><br><span class="line">    &lt;v-slot-name&gt;</span><br><span class="line">      &lt;template slot=&quot;header&quot;&gt;</span><br><span class="line">        自定义header</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;p&gt;没有指定v-slot名称，自定义main&lt;/p&gt;</span><br><span class="line">    &lt;/v-slot-name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;v-slot-name&gt;</span><br><span class="line">      &lt;template v-slot:header&gt;</span><br><span class="line">        自定义header</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:default&gt;</span><br><span class="line">        指定了default，看到自定义的main</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/v-slot-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="作用于插槽使用"><a href="#作用于插槽使用" class="headerlink" title="作用于插槽使用"></a>作用于插槽使用</h2><p><code>v-slot-scope.vue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;v-slot&quot;&gt;</span><br><span class="line">    &lt;p&gt;我是作用域插槽&lt;/p&gt;</span><br><span class="line">    &lt;slot v-bind:user=&quot;user&quot;&gt;</span><br><span class="line">      &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;v-slot&quot;,</span><br><span class="line">  props: [&quot;user&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在其他模块中调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;作用域插槽&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;新的使用方式 使用v-slot:插槽名称=&quot;组件全局变量&quot;&lt;/h2&gt;</span><br><span class="line">    &lt;v-slot-scope :user=&quot;user&quot;&gt;</span><br><span class="line">      &lt;template v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">        这是指定插槽名称的写法</span><br><span class="line">        &#123;&#123; slotProps.user.name &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/v-slot-scope&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;老的使用方式 使用slot=&quot;插槽名称&quot; slot-scope=&quot;组件全局变量&quot;&lt;/h2&gt;</span><br><span class="line">    &lt;v-slot-scope :user=&quot;user&quot;&gt;</span><br><span class="line">      &lt;template slot=&quot;default&quot; slot-scope=&quot;slotProps&quot;&gt;</span><br><span class="line">        这是指定插槽名称的写法</span><br><span class="line">        &#123;&#123; slotProps.user.name &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/v-slot-scope&gt;</span><br><span class="line"></span><br><span class="line">    &lt;v-slot-scope :user=&quot;user&quot; v-slot=&quot;slotProps&quot;&gt;</span><br><span class="line">      这是新语法中的，独占插槽的写法，省去了default插槽名称，和template标签</span><br><span class="line">      &#123;&#123; slotProps.user.name &#125;&#125;</span><br><span class="line">    &lt;/v-slot-scope&gt;</span><br></pre></td></tr></table></figure>
<h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p><a href="https://gitee.com/shooke/vue-demo/tree/master/vue-demo-slot">https://gitee.com/shooke/vue-demo/tree/master/vue-demo-slot</a></p>
<p>具体参考文件如下<br>vuedemo&#x2F;src&#x2F;views&#x2F;slot.vue 使用组件的视图文件<br>vuedemo&#x2F;src&#x2F;components&#x2F;v-slot-name.vue 具名插槽组件<br>vuedemo&#x2F;src&#x2F;components&#x2F;v-slot-scope.vue 作用域插槽组件<br>vuedemo&#x2F;src&#x2F;components&#x2F;v-slot.vue 普通域插槽组件</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件</tag>
        <tag>插槽</tag>
        <tag>Slots</tag>
      </tags>
  </entry>
  <entry>
    <title>vue自定义组件v-model绑定数据的实现方法</title>
    <url>/2019/07/19/2019/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6v-model%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>父组件调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;list v-model=&quot;data&quot; :multiple=&quot;true&quot;&gt;&lt;/list&gt;</span><br></pre></td></tr></table></figure>

<p>子组件<code>list.vue</code>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-select v-model=&quot;val&quot; v-bind=&quot;$attrs&quot; placeholder=&quot;请选择&quot;&gt;</span><br><span class="line">    &lt;el-option</span><br><span class="line">      v-for=&quot;item in list&quot;</span><br><span class="line">      :key=&quot;item.id&quot;</span><br><span class="line">      :label=&quot;item.name&quot;</span><br><span class="line">      :value=&quot;item.id&quot;&gt;</span><br><span class="line">    &lt;/el-option&gt;</span><br><span class="line">  &lt;/el-select&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; getColumnList &#125; from &#x27;@/api/column.js&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#x27;value&#x27;,</span><br><span class="line">    event: &#x27;change&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: null</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [&#123;id:&#x27;1&#x27;,name:&#x27;张三&#x27;&#125;,&#123;id:&#x27;2&#x27;,name:&#x27;李四&#x27;&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    val: &#123;</span><br><span class="line">      get () &#123;</span><br><span class="line">        return this.value</span><br><span class="line">      &#125;,</span><br><span class="line">      set (newval) &#123;</span><br><span class="line">        this.$emit(&#x27;change&#x27;, newval)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>实现v-model注意一下几点即可</p>
<ol>
<li>model.event定义的事件名称是什么，$emit的时候出发的名称要一致。比如上面的事件名称叫<code>change</code>，这个可以随便取名字</li>
<li>model.props的值是什么，父组件使用v-model时，值就会给谁。上面的例子中值会传给<code>value</code></li>
</ol>
<p>注意以上两点就可以了，至于什么时机把值传递给父组件，取决于什么时候用<code>$emit</code>触发<code>model.event</code>设置的事件。比如上面使用了计算属性的方法。当<code>val</code>发生改变时，就把新的值返回。当然了，除了使用计算属性，也可以使用<code>watch</code>实现。</p>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p><code>inheritAttrs</code>是默认值<code>true</code>时，所有的属性都会绑定到组件的<code>props</code>中，这为我们的组件开发提供了方便，但是有时候我们希望属性继续往下传递，就比较麻烦，这时候用<code>inheritAttrs: false</code>就方便多了。</p>
<p><code>inheritAttrs: false</code>配合<code>$attrs</code>可以实现灵活的属性处理。<code>inheritAttrs: false</code>可以让父组件传递进来的(props之外的)属性收集到<code>$attrs</code>中，使用<code>v-bind=&quot;$attrs&quot;</code>就可以将这些属性绑定到特定的组件或html元素上了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>vue</tag>
        <tag>自定义组件</tag>
        <tag>v-model</tag>
      </tags>
  </entry>
  <entry>
    <title>使用vue cli 3项目打包到指定目录</title>
    <url>/2019/08/22/2019/%E4%BD%BF%E7%94%A8vue-cli-3%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>日常打包执行<code>npm run build</code>会将代码打包至<code>dist</code>目录下，各种js引入，均已网站根目录为依据。我们想要把项目作为子目录访问时就需要做些配置了。</p>
<span id="more"></span>
<h2 id="1-设置打包路径"><a href="#1-设置打包路径" class="headerlink" title="1 设置打包路径"></a>1 设置打包路径</h2><p>vue.config.js文件中配置<code>publicPath</code>属性，这样在打包后<code>dist</code>中<code>index.html</code>中所有的文件引入都会加上配置的前缀。打包完成后我们将dist重命名成<code>targetPath</code>(设置的地址)，然后将文件夹上传到网站根目录即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/targetPath/&#x27; : &#x27;/&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-设置路由基础路径"><a href="#2-设置路由基础路径" class="headerlink" title="2 设置路由基础路径"></a>2 设置路由基础路径</h2><p>在路由配置文件中设置<code>base</code>选项，如果不设置，到时候会出现找不到模块的情况。<code>process.env.BASE_URL</code>是一个vue cli中内置的变量，他的值就是vue.config.js中配置的<code>publicPath</code>的值。如果不想用这个变量，也可以自己定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: &#x27;history&#x27;,</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="3-配置服务器"><a href="#3-配置服务器" class="headerlink" title="3 配置服务器"></a>3 配置服务器</h2><p>如果项目的路由模式采用了<code>history</code>模式，则需要配置一下web服务器。<br>这里以nginx为例，上面设置的目录是<code>targetPath</code>我们应该做如下配置。注意一定要加上<code>targetPath</code>,否则会出现404错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  ...</span><br><span class="line">  location /targetPath &#123;</span><br><span class="line">    try_files $uri $uri/ /targetPath/index.html;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>publicPath参数说明：<a href="https://cli.vuejs.org/zh/config/#publicpath">https://cli.vuejs.org/zh/config/#publicpath</a><br>vue cli环境变量说明：<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%A7%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">https://cli.vuejs.org/zh/guide/mode-and-env.html#在客户端侧代码中使用环境变量</a><br>vue router路由base参数说明：<a href="https://router.vuejs.org/zh/api/#base">https://router.vuejs.org/zh/api/#base</a><br>服务器配置说明：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90">https://router.vuejs.org/zh/guide/essentials/history-mode.html#后端配置例子</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue cli</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin修改git提示语言</title>
    <url>/2019/12/17/2019/%E4%BF%AE%E6%94%B9git%E6%8F%90%E7%A4%BA%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>deepin系统很好用，汉化也很彻底，安装git后。提示都是中文。不过不太习惯。还是改成英文比较顺眼。<br>修改<code>~/.bashrc</code>文件加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Set Git language to English</span><br><span class="line">#alias git=&#x27;LANG=en_US git&#x27;</span><br><span class="line">alias git=&#x27;LANG=en_GB git&#x27;</span><br></pre></td></tr></table></figure>
<p>关闭命令行，重新打开，如如git命令就会提示英文了</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git语言</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里云ecs主机打造shadowsocks服务器,实现科学上网</title>
    <url>/2019/04/11/2019/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ecs%E4%B8%BB%E6%9C%BA%E6%89%93%E9%80%A0shadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<p>要想打造一台自己的ss(shadowsocks)或ssr（shadowsocksR）服务器。要具备一下条件：</p>
<ol>
<li>要有一台自己的服务器vps或ecs云主机都可以，虚拟主机是不行滴</li>
<li>服务器一定要在海外或中国香港。推荐日、韩、香港、新加坡服务器<br>下面已阿里ecs为实例说明，主要是ecs降价了<code>366/年</code>的价格速度很快。比网上说的搬瓦工、Vultr强多了。</li>
</ol>
<span id="more"></span>

<h2 id="一-购买云主机"><a href="#一-购买云主机" class="headerlink" title="一 购买云主机"></a>一 购买云主机</h2><p>进入 <a href="https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=627kscqf">https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=627kscqf</a><br>选择第一项入门级配置的第一个就可以<code>1核1G 40G系统盘</code>，推荐选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区域：新加坡</span><br><span class="line">操作系统：centos 7</span><br><span class="line">带宽：1M</span><br></pre></td></tr></table></figure>
<p>区域选新加坡或香港都可以，不建议选欧美的，延时会比新加坡或香港高一丢丢。<br>带宽选择<code>1M</code>基本够用了，价格只有<code>￥366/年</code>,和买个爱奇艺会员差不多，2年也才<code>￥586</code>，非常便宜。<br>默认选择的是<code>2M</code> <code>￥504/年</code>的价格对我来说有点贵，如果你看电影多，可以选这个。<br>操作系统选centos7，是因为下面的操作命令是基于centos写的，如果你有一定linux基础，其实选择什么都可以。<br>选好了付款就可以了，支付宝付款很方便，还可以分期。</p>
<h2 id="二-打造shadowsocks服务环境"><a href="#二-打造shadowsocks服务环境" class="headerlink" title="二 打造shadowsocks服务环境"></a>二 打造shadowsocks服务环境</h2><p>买好了服务器，可以使用终端工具登录服务器。Xshell、Putty、SecureCRT都可以。<br>我平时使用的是deepin，所以使用自带的深度终端进行链接。给深度打个小广告，这是最好用的linux操作系统。</p>
<blockquote>
<p>注意，我买的是新加坡的服务器，执行ssh命令登录时有点慢，需要等待20秒左右才会出现密码输入。但是ping的时候很快，登录后使用时也很快，只是ssh验证慢。不知道什么原因。</p>
</blockquote>
<p>网上关于shadowsocks的安装教程有很多，但好多都比较麻烦，好在有人将安装过程做了打包。感谢一下作者。<br>开始正式安装，我们用最简单的方式，执行一下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/CecilWu/SSR-Chinese/master/ssr.sh &amp;&amp; chmod +x ssr.sh</span><br></pre></td></tr></table></figure>
<p>耐心等待就可以了，下载完成后，我们执行<code>ls</code>会发现，在当前目录出现了一个<code>ssr.sh</code>文件。这个就是管理脚本，我们运行它</p>
<ol>
<li>运行管理脚本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./ssr.sh</span><br></pre></td></tr></table></figure>
脚本运行起来了，内容如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ShadowsocksR 一键管理脚本 [v2.0.38]</span><br><span class="line">  ---- Toyo | doub.io/ss-jc42 ----</span><br><span class="line"></span><br><span class="line">  1. 安装 ShadowsocksR</span><br><span class="line">  2. 更新 ShadowsocksR</span><br><span class="line">  3. 卸载 ShadowsocksR</span><br><span class="line">  4. 安装 libsodium(chacha20)</span><br><span class="line">————————————</span><br><span class="line">  5. 查看 账号信息</span><br><span class="line">  6. 显示 连接信息</span><br><span class="line">  7. 设置 用户配置</span><br><span class="line">  8. 手动 修改配置</span><br><span class="line">  9. 切换 端口模式</span><br><span class="line">————————————</span><br><span class="line"> 10. 启动 ShadowsocksR</span><br><span class="line"> 11. 停止 ShadowsocksR</span><br><span class="line"> 12. 重启 ShadowsocksR</span><br><span class="line"> 13. 查看 ShadowsocksR 日志</span><br><span class="line">————————————</span><br><span class="line"> 14. 其他功能</span><br><span class="line"> 15. 升级脚本</span><br><span class="line"> </span><br><span class="line"> 当前状态: 已安装 并 已启动</span><br><span class="line"> 当前模式: 单端口</span><br><span class="line"></span><br><span class="line">请输入数字 [1-15]：</span><br></pre></td></tr></table></figure>
输入<code>1</code>开始安装。</li>
<li>设置端口<br>安装完毕后会要求你自定义端口，默认是2333，我们可以自己设置一个</li>
<li>设置密码<br>端口设置完成会提示你输入密码，输入一个密码回车即可。</li>
<li>选择加密方式<br>这里有很多加密方式，选择一种即可，一般选10：aes-256-cfb或rc4-md5</li>
<li>协议兼容原版<br>输入<code>y</code>回车</li>
<li>混淆插件<br>选择一种混淆插件，默认是<code>5</code>，选择<code>1</code>也可以</li>
<li>连接数和限速设置<br>个人用可以不设置，直接回车</li>
<li>安装部署<br>完成上面的操作，程序会开始下载需要的包，下载完成后会提示是否部署<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Is this ok [y/n]</span><br></pre></td></tr></table></figure>
出现这个提示输入<code>y</code>就可以了，等它自己安装完成。<br>安装完成后会显示先前的配置。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===================================================</span><br><span class="line"></span><br><span class="line"> ShadowsocksR账号 配置信息：</span><br><span class="line"></span><br><span class="line"> I  P	    : 47.123.123.123</span><br><span class="line"> 端口	    : 2333</span><br><span class="line"> 密码	    : 123456</span><br><span class="line"> 加密	    : rc4-md5</span><br><span class="line"> 协议	    : auth_sha1_v4_compatible</span><br><span class="line"> 混淆	    : plain</span><br><span class="line"> 设备数限制 : 0(无限)</span><br><span class="line"> 单线程限速 : 0 KB/S</span><br><span class="line"> 端口总限速 : 0 KB/S</span><br><span class="line"> SS    链接 : ss://sdfsdfsdfsdfsdfaadsffasd </span><br><span class="line"> SS  二维码 : http://doub.pw/qr/qr.php?text=ss://asdfsdfsadfsdfsdf</span><br><span class="line"> SSR   链接 : ssr://dsfsdfsdfsdf </span><br><span class="line"> SSR 二维码 : http://doub.pw/qr/qr.php?text=ssr://sdfsdfsdfsd</span><br><span class="line"> </span><br><span class="line">  提示: </span><br><span class="line"> 在浏览器中，打开二维码链接，就可以看到二维码图片。</span><br><span class="line"> 协议和混淆后面的[ _compatible ]，指的是 兼容原版协议/混淆。</span><br><span class="line"></span><br><span class="line">===================================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>
看到这个提示说明安装成功了。后期如果需要重新配置或查看配置，可以执行<code>ssr.sh</code>。还会弹出操作菜单。</li>
</ol>
<h2 id="设置阿里云主机端口"><a href="#设置阿里云主机端口" class="headerlink" title="设置阿里云主机端口"></a>设置阿里云主机端口</h2><p>这一步很重要，阿里云入方向默认只开了22和3389端口。我们需要将Shadowsocks需要的端口打开，上面我们配置的是2333。具体方法如下<br>进入控制台-》商品与服务-》云服务器ecs， 然后在左侧菜单中找到<code>安全组</code>。右侧找到服务器，点击<code>配置规则</code>。<br>在配置页面选择<code>入方向</code>。点击右上角的<code>添加安全规则</code>。进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">规则方向：入方向</span><br><span class="line">授权策略：允许</span><br><span class="line">协议类型：自定义TCP</span><br><span class="line">端口范围：2000/3000</span><br><span class="line">优先级:1</span><br><span class="line">授权类型：IPv4地址段访问</span><br><span class="line">授权对象：0.0.0.0/0</span><br></pre></td></tr></table></figure>
<p>这样你的电脑无论在哪里都可以链接到服务器了</p>
<h2 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h2><p>Shadowsocks客户端有很多百度一下就可以了。安装后根据服务器的设置，配置一下客户端的参数就可以了。<br>我用的是deepin，使用的<code>Shadowsocks for Deepin</code>很好用，下载地址 <a href="https://github.com/lolimay/shadowsocks-deepin/blob/master/docs/README_CN.md">https://github.com/lolimay/shadowsocks-deepin/blob/master/docs/README_CN.md</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.5xiaobo.com/?id=693">https://www.5xiaobo.com/?id=693</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>科学上网</tag>
        <tag>shadowsocksR</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离session跨域解决方案</title>
    <url>/2019/02/01/2019/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBsession%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>php的session比cookie安全，这是好多人知道的常识。session的数据是存放在服务端的，那么程序是如何取到对应的session呢？<br>那是因为每一个session都有一个身份证号，那就是session id。这个东西一般情况下，服务器会发送给客户端，客户端将它放在cookie里。<br>cookie是存在跨域问题的，什么叫跨域呢？a.domain.com下创建的cookie,在b.domain.com下是无法使用的，我们需要进行跨域设置。</p>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>用过vue开发前后端分离程序的人对axios相比都不陌生了，js前后端分离，如果前后端用两个域名，也存在跨域问题。</p>
<span id="more"></span>
<p>跨域是个老生常谈的问题了，特别是前后端分离以后。解决前后端分离其实没有想象中的那么难，主要是明白其中的道理。首先先了解介个基本知识。</p>
<h2 id="session-1"><a href="#session-1" class="headerlink" title="session"></a>session</h2><p>php的session比cookie安全，这是好多人知道的常识。session的数据是存放在服务端的，那么程序是如何取到对应的session呢？<br>那是因为每一个session都有一个身份证号，那就是session id。这个东西一般情况下，服务器会发送给客户端，客户端将它放在cookie里。<br>cookie是存在跨域问题的，什么叫跨域呢？a.domain.com下创建的cookie,在b.domain.com下是无法使用的，我们需要进行跨域设置。</p>
<h2 id="axios-1"><a href="#axios-1" class="headerlink" title="axios"></a>axios</h2><p>用过vue开发前后端分离程序的人对axios相比都不陌生了，js前后端分离，如果前后端用两个域名，也存在跨域问题。</p>
<h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><p>前端请求后端接口跨域很容易解决，服务端设置好返回头就可以了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;$http_origin&#x27;;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, PUT, DELETE, OPTIONS&#x27;;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Origin, DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type, Accept, authKey, sessionId, business,shop&#x27;;</span><br><span class="line">                    #add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;*&#x27;;</span><br><span class="line">                    add_header &#x27;Access-Control-Max-Age&#x27; 1728000;</span><br><span class="line">                    add_header &#x27;Content-Type&#x27; &#x27;text/plain charset=UTF-8&#x27;;</span><br><span class="line">                    add_header &#x27;Content-Length&#x27; 0;</span><br><span class="line"></span><br><span class="line">                    return 204;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>发个全一点的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">                if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;$http_origin&#x27;;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, PUT, DELETE, OPTIONS&#x27;;</span><br><span class="line">                    add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Origin, DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type, Accept, authKey, sessionId, business,shop&#x27;;</span><br><span class="line">                    #add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;*&#x27;;</span><br><span class="line">                    add_header &#x27;Access-Control-Max-Age&#x27; 1728000;</span><br><span class="line">                    add_header &#x27;Content-Type&#x27; &#x27;text/plain charset=UTF-8&#x27;;</span><br><span class="line">                    add_header &#x27;Content-Length&#x27; 0;</span><br><span class="line"></span><br><span class="line">                    return 204;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!-e $request_filename) &#123;</span><br><span class="line">                    rewrite  ^(.*)$  /index.php?s=/$1  last;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                # First attempt to serve request as file, then</span><br><span class="line">                # as directory, then fall back to displaying a 404.</span><br><span class="line">                try_files $uri $uri/ =404;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样设置后，普通的ajax跨域请求基本就可以了，当然这里的location要根据你的实际情况，也有可能是<code>location ~ \.php$ </code><br>如果这写头信息无法满足，你也可以使用php的header函数重新设置header头。<br>经过上面的配置普通的跨域请求就可以正常执行了。接下来说一下携带cookie的跨域解决。</p>
<h2 id="session跨域"><a href="#session跨域" class="headerlink" title="session跨域"></a>session跨域</h2><p>上面说过session默认依赖cookie，所以我们创建session的时候要进行一下设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ini_set(&#x27;session.cookie_domain&#x27;, &#x27;.domain.com&#x27;);</span><br></pre></td></tr></table></figure>
<p>创建session之前一定要有上面的设置，这样cookie就可以在a.domain.com和b.domain.com都有效。<br>后端支持了，还有前端，ajax请求默认不携带cookie信息，如何让它带上呢。很简单，ajax对象有一个<code>withCredentials</code>属性，将它设置为true就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容</span><br><span class="line"></span><br><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">xhr.open(&#x27;post&#x27;, &#x27;http://a.domain.com:8080/login&#x27;, true);</span><br><span class="line">xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);</span><br><span class="line">xhr.send(&#x27;user=admin&#x27;);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面是普通ajax的实例，axios可以按下面的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.defaults.withCredentials = true</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>axios</tag>
        <tag>vue</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>团队开发中如何使用git分支</title>
    <url>/2019/02/15/2019/%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p>git已经成为团队代码管理的标配，合理的使用git分支进行开发，可以大大提高开发效率，降低管理成本。好多人听过git fllow，但都是一知半解，其实并不神秘，也很简单。这是很多研发团队总结出来的一种分支策略而已。</p>
<span id="more"></span>

<h2 id="功能分支使用策略"><a href="#功能分支使用策略" class="headerlink" title="功能分支使用策略"></a>功能分支使用策略</h2><p>首先，我们有两个环境，测试环境（dev分支）和生产环境（master分支）。<br>其次，有两个团队同时进行开发两个不同的功能模块，这两个模块是相对独立的。</p>
<p>开发前，两个团队要在master的基础上创建不同的功能分支，团队一使用branch-1，团队二使用branch-2。</p>
<p>当需要测试时，团队需要将功能分支合并到测试分支dev，线上构建后，开始测试。比如团队1的功能需要测试了，就将branch-1的代码合并到dev，团队二需要测试了将branch-2合并到dev，<strong>这里的合并用merge</strong>。这样两个团队都可以进行测试，互不影响。</p>
<p>其中一个功能完成后，比如branch-1，将其合并到master**(这里合并用merge)**进行发布就可以了。</p>
<h2 id="多人合作分支使用策略"><a href="#多人合作分支使用策略" class="headerlink" title="多人合作分支使用策略"></a>多人合作分支使用策略</h2><p>上面说道了branch-1和branch-2是功能分支，由两个团队负责，每个团队都有若干个人，这时候就需要考虑团队合作问题。<br>以团队1为例，团队中的每个人，都应该基于branch-1去checkout一个自己的个人分支，进行开发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout branch-1</span><br><span class="line">git checkout -b mybranch #创建自己的分支</span><br><span class="line">...</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;开发说明&quot;</span><br></pre></td></tr></table></figure>
<p>当自己的开发完成后，将代码合并到功能分支，可以简单的使用下面的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout branch-1 # 切换到功能分支</span><br><span class="line">git pull              # 拉取最新代码</span><br><span class="line">git merge mybranch    # 合并个人代码</span><br><span class="line">git push              # 上传功能分支</span><br></pre></td></tr></table></figure>
<p>更好的方式是利用rebase让合并历史更加清晰，方便维护，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout branch-1 # 切换到功能分支</span><br><span class="line">git pull              # 拉取最新代码</span><br><span class="line">git checkout mybranch # 切换到个人分支</span><br><span class="line">git rebase branch-1   # 合并功能分支的代码，这个可以让你的分支历史更加清晰，易于管理</span><br><span class="line">git checkout branch-1 # 切换到功能分支</span><br><span class="line">git merge mybranch    # 将个人分支的修改合并进来</span><br><span class="line">git push              # 上传功能分支</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>分支</tag>
        <tag>多人协作</tag>
      </tags>
  </entry>
  <entry>
    <title>省略sudo使用docker</title>
    <url>/2019/04/25/2019/%E7%9C%81%E7%95%A5sudo%E4%BD%BF%E7%94%A8docker/</url>
    <content><![CDATA[<h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install docker</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>为什么需要创建 docker 用户组？<br>Docker 守候进程绑定的是一个 unix socket，而不是 TCP 端口。这个套接字默认的属主是 root，其他是用户可以使用 sudo 命令来访问这个套接字文件。因为这个原因，docker 服务进程都是以 root 帐号的身份运行的。</p>
<span id="more"></span>

<p>为了避免每次运行 docker 命令的时候都需要输入 sudo，可以创建一个 docker 用户组，并把相应的用户添加到这个分组里面。当 docker 进程启动的时候，会设置该套接字可以被 docker 这个分组的用户读写。这样只要是在 docker 这个组里面的用户就可以直接执行 docker 命令了。<br>因为该 dockergroup 等同于 root 帐号</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><ol>
<li>执行以下命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>退出重新登录，这个很重要。</li>
<li>执行 docker 命令测试以下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.runoob.com/docker/ubuntu-docker-install.html">http://www.runoob.com/docker/ubuntu-docker-install.html</a><br><a href="http://www.docker.org.cn/book/install/run-docker-without-sudo-30.html">http://www.docker.org.cn/book/install/run-docker-without-sudo-30.html</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>sudo</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式基本原则大白话</title>
    <url>/2019/04/01/2019/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E5%A4%A7%E7%99%BD%E8%AF%9D/</url>
    <content><![CDATA[<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>   简单点说就是最小化封装，一个方法只负责一个功能，一个类只负责一类功能。如果一个功能比较复杂，那就差分成多个小功能，然后去实现。<br>   这样做的好处是</p>
<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>   简单点说就是子类可以扩展父类的功能，但不能改变父类原有的功能。<br>   注意一下几点即可</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<p>这样做可以有效避免，功能耦合度太高，改一个小功能影响到其他功能的情况</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>   依赖倒置就是控制翻转，又名 IOC，简单点说，就是将需要的外部对象，通过构造函数参数传递或属性赋值的方式，让当前对象可以使用注入的外部对象。<br>   注意一下几点即可</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则</li>
</ul>
<p>这样做可以有效解耦，功能发生改变时，只需要替换外部的依赖对象，而不必修改主体功能代码。</p>
<span id="more"></span>

<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>   简单点说就是将接口功能进行拆分，拆分成多个小一点的接口。在实现时只实现需要的功能即可。<br>   注意一下几点即可</p>
<ul>
<li>接口要尽量小，但要保持一个最小化的完成功能，拆分过细，容易造成接口过多，设计太过复杂。先对功能进行思考后，适度的进行拆分。</li>
<li>实现时只实现必要的接口</li>
<li>提高完整性，避免过多的外部依赖</li>
</ul>
<p>其实这根单一原则很相似，不过单一原则针对的是类和函数，接口隔离原则针对的是接口，对接口进行拆分可以有效避免不必要的代码实现，避免代码臃肿。</p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>   简单点说就是降低耦合度，尽可能的实现解耦。这是很核心的原则，其实上面的四个原则很大程度上都为这个原则服务。不过上面的几个原则只针对代码层面。这个原则还有另一侧含义。<br>   迪米特法则又叫最少知道原则，这么说就更容易理解了吧。代码方面要注意属性、方法的保密性和安全性，这也是为什么属性一般使用 private 的原因。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>   简单点说就是开放扩展，关闭修改。意思是设计时要有扩展性，遇到问题，尽量不修改已有功能，而是通过扩展新功能的方式去解决问题。</p>
<blockquote>
<p>小节：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>设计模式基本原则</tag>
      </tags>
  </entry>
  <entry>
    <title>rust语言字符串笔记</title>
    <url>/2021/01/20/2021/rust%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>每种语言都免不了和字符串打交道，rust也不例外。由于rust本身的一些特性，字符串的使用和其他语言有很大的不同。</p>
<span id="more"></span>

<h2 id="从最简单的单个字符说起-char"><a href="#从最简单的单个字符说起-char" class="headerlink" title="从最简单的单个字符说起-char"></a>从最简单的单个字符说起-char</h2><p><code>char</code>类型可以简单的定义单字符变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let c = &#x27;a&#x27;;</span><br><span class="line">let d = &#x27;好&#x27;; //这个将会报错</span><br></pre></td></tr></table></figure>
<p>这样就简单的定义了一个<code>char</code>类型。为什么不能用中文呢？其实不只是中文，非英文之外的语言都会出现问题。rust采用utf8进行字符编码。<code>好</code>虽然看起来是一个汉字，但对于机器来说其实是3个字符。</p>
<h2 id="了解一下字符串"><a href="#了解一下字符串" class="headerlink" title="了解一下字符串"></a>了解一下字符串</h2><p>char只能定义一个英文或数字等简单字符显然是不够的，使用过程中字符串比这要复杂的多。于是就有了<code>str</code>类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s = &quot;好&quot;;</span><br><span class="line">let s2 = &quot;hello&quot;;</span><br></pre></td></tr></table></figure>
<p>这样写其实是建立了一个<code>&amp;str</code>类型。他是一个<code>str</code>类型的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = &quot;hello&quot;.to_string();</span><br></pre></td></tr></table></figure>
<p>这样就得到了两个<code>String</code>类型的字符串。</p>
<p>既然<code>&amp;str</code>可以转换成<code>String</code>，那能不能反过来呢？答案是可以。使用切片(slice)可以做到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = &amp;s1[..]</span><br></pre></td></tr></table></figure>
<p>这样s2就是<code>&amp;str</code>类型的变量了。</p>
<p>有<code>&amp;str</code>就应该有<code>str</code>类型的数据吧？当然。</p>
<ul>
<li><code>str</code> 是 Rust 核心语言类型<ul>
<li>存放在栈上</li>
<li>不可变更</li>
</ul>
</li>
<li><code>String</code>类型是rust标准公共库提供的一种数据类型，它的功能更完善——它支持字符串的追加、清空等实用的操作。String 和 str 除了同样拥有一个字符开始位置属性和一个字符串长度属性以外还有一个容量（capacity）属性。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin双内核管理</title>
    <url>/2021/06/30/2021/deepin%E5%8F%8C%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="如何手动安装双内核："><a href="#如何手动安装双内核：" class="headerlink" title="如何手动安装双内核："></a>如何手动安装双内核：</h2><p>深度操作系统内核版本，会以一定周期进行更新，已经安装系统的用户，需要安装最新的内核版本，可通过在[终端]应用中输入命令行操作。</p>
<h3 id="安装LTS内核"><a href="#安装LTS内核" class="headerlink" title="安装LTS内核"></a>安装LTS内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install linux-image-deepin-amd64 linux-headers-deepin-amd64</span><br></pre></td></tr></table></figure>
<h3 id="安装stable内核"><a href="#安装stable内核" class="headerlink" title="安装stable内核"></a>安装stable内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install linux-image-deepin-stable-amd64 linux-headers-deepin-stable-amd64</span><br></pre></td></tr></table></figure>
<h3 id="查询当前系统已安装内核并获取完整包名："><a href="#查询当前系统已安装内核并获取完整包名：" class="headerlink" title="查询当前系统已安装内核并获取完整包名："></a>查询当前系统已安装内核并获取完整包名：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpkg -l | grep &quot;linux-image\|linux-headers&quot;</span><br></pre></td></tr></table></figure>
<h3 id="卸载其中一个内核"><a href="#卸载其中一个内核" class="headerlink" title="卸载其中一个内核"></a>卸载其中一个内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt purge linux-image-5.10.18-amd64-desktop linux-headers-5.10.18-amd64-desktop</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 18.04 Temporary failure in name resolution DNS解析问题，解决方法</title>
    <url>/2021/09/15/2021/ubuntu%2018.04%20Temporary%20failure%20in%20name%20resolution%20DNS%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在ubuntu18.04 配置环境，发现无法下载网络资源，但是用ip可以访问外网资源。问题应该是dns没有解析。<br>试了好多种方法无效，最后找到了解决方法，记录一下</p>
<p>修改<code>/etc/systemd/resolved.conf</code>将里面的dns注释去掉，配置上自己的dns就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Resolve]</span><br><span class="line">DNS=114.114.114.114</span><br></pre></td></tr></table></figure>
<p>注意：修改完成后，需要重启一下服务器</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>解决element ui el-select控件多选时option设置为disabled，但可以删除标签，造成无法恢复的bug</title>
    <url>/2019/09/25/2019/%E8%A7%A3%E5%86%B3element-ui-el-select%E6%8E%A7%E4%BB%B6%E5%A4%9A%E9%80%89%E6%97%B6option%E8%AE%BE%E7%BD%AE%E4%B8%BAdisabled%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE%EF%BC%8C%E9%80%A0%E6%88%90%E6%97%A0%E6%B3%95%E6%81%A2%E5%A4%8D%E7%9A%84bug/</url>
    <content><![CDATA[<h2 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h2><p>今天遇到一个问题，需求是，客户选择栏目时，不属于自己的栏目不可修改。但需要显示出来。实现需求使用了element ui的el-select组件。<br>对于已选栏目的显示，和对栏目的选项取消都比较好。不属于自己的栏目使用了option的<code>disabled</code>属性。列表中的选项控制正常，对于<code>disabled</code>属性为<code>true</code>的元素不可选。<br>但是在展示已选则的栏目时，option中禁用的选项依然有删除的小叉号。而且还是可以使用的，点击后就被删除了。在列表中的选中状态也取消了。这可闹大了，没法恢复啊。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>思路很简单，在对选项进行移除时做个判断。如果选项是禁用的，就不操作。<br>实现中用到了<code>value</code>属性，用于显示备选项。<code>change</code>事件用于处理选中的值，<code>remove-tag</code>事件处理移除选项时的判断<br>有几个问题需要注意，事件的执行顺序是先出发<code>change</code>后出发<code>remove-tag</code>所以要让数据返回变为异步，保证<code>remove-tag</code>事件完成后在返回数据</p>
<span id="more"></span>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>为了方便项目中使用，封装了个小组件,使用时直接载入组,件用<code>v-model</code>绑定数据就可以了很方便</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-select filterable</span><br><span class="line">             :value=&quot;value&quot;</span><br><span class="line">             @change=&quot;changeHandle&quot;</span><br><span class="line">             @remove-tag=&quot;removeHandle&quot;</span><br><span class="line">             v-bind=&quot;$attrs&quot;</span><br><span class="line">             placeholder=&quot;请选择&quot;&gt;</span><br><span class="line">    &lt;el-option v-for=&quot;item in list&quot;</span><br><span class="line">               :key=&quot;item.id&quot;</span><br><span class="line">               :label=&quot;item.name&quot;</span><br><span class="line">               :value=&quot;item.id&quot;</span><br><span class="line">               :disabled=&quot;item.disabled&quot;&gt;</span><br><span class="line">    &lt;/el-option&gt;</span><br><span class="line">  &lt;/el-select&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#x27;value&#x27;,</span><br><span class="line">    event: &#x27;input&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: null</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      selected: [],</span><br><span class="line">      list: [</span><br><span class="line">        &#123;id:1,name:&#x27;a&#x27;,disabled:false&#125;&#125;,</span><br><span class="line">        &#123;id:2,name:&#x27;b&#x27;,disabled:false&#125;&#125;,</span><br><span class="line">        &#123;id:3,name:&#x27;c&#x27;,disabled:true&#125;&#125;,</span><br><span class="line">      ],</span><br><span class="line">      draftId: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeHandle (val) &#123;</span><br><span class="line">      this.selected = val</span><br><span class="line">      // 延时返回数据，主要是因为element会先执行change然后在执行remove，为了恢复不可删除的栏目，所以延时返回数据</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        this.$emit(&#x27;input&#x27;, this.selected)</span><br><span class="line">      &#125;, 10)</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandle (val) &#123;</span><br><span class="line">      // 检查选项是否可用</span><br><span class="line">      let removeItem = this.list.find((item) =&gt; &#123;</span><br><span class="line">        return item.id === val &amp;&amp; item.disabled === false</span><br><span class="line">      &#125;)</span><br><span class="line">      console.log(val, removeItem)</span><br><span class="line">      // 如果找不到表示不可删除</span><br><span class="line">      if (typeof removeItem === &#x27;undefined&#x27;) &#123;</span><br><span class="line">        this.selected = this.value</span><br><span class="line">      &#125; else &#123;        </span><br><span class="line">        // 如果找到可删除，则过滤</span><br><span class="line">        this.selected = this.value.filter((item) =&gt; &#123;</span><br><span class="line">          return item !== val</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>element ui</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu18.4多版本php安装</title>
    <url>/2021/09/17/2021/ubuntu18-4%E5%A4%9A%E7%89%88%E6%9C%ACphp%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装php-ppa源"><a href="#安装php-ppa源" class="headerlink" title="安装php ppa源"></a>安装php ppa源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>老版本的12.4之前的ubuntu用下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-software-properties</span><br><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br></pre></td></tr></table></figure>
<h2 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h2 id="安装对应的版本"><a href="#安装对应的版本" class="headerlink" title="安装对应的版本"></a>安装对应的版本</h2><p>比如安装7.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y php7.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>0.教程介绍</title>
    <url>/2019/12/17/git/0.%E6%95%99%E7%A8%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>市面上已经有很多的git教程了，比如廖雪峰老师的git教程，还有阮一峰老师写的关于git的一些教程。我在刚开始接触git的时候，就是读的他们教程。他们写的都很好，git的所有功能都有所涵盖，但是很多人知道了命令，但在工作中还是不清楚该如何使用。</p>
<p>与网络上所有的教程都不同，本教程更注重使用场景，会根据不同的场景，选择最优的git命令，来解决问题。</p>
<p>教程中所有的命令都会有一段工作场景的介绍，我们可以跟随小白的视角，一起学习git是如何使用的。以及最后会做出总结，介绍命令的功能，以及一些使用技巧。</p>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>spring官方建议不要使用@Autowired，完美解决方案</title>
    <url>/2023/07/20/2023/spring-autowired/</url>
    <content><![CDATA[<p>Springboot官方建议使用final来修饰成员变量，然后通过构造方法来进行注入。原因：final修饰的成员变量是不能够被修改的，反射除外。</p>
<p>既然不推荐使用Autowired了，应该如何修改我们的代码呢？</p>
<span id="more"></span>
<h2 id="原代码"><a href="#原代码" class="headerlink" title="原代码"></a>原代码</h2><p>当前代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/terminalLocation&quot;)</span><br><span class="line">public class TerminalLocationController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TerminalLocationService terminalLocationService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/confirm&quot;)</span><br><span class="line">    public RestResponse&lt;String&gt; confirm(@RequestParam(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        terminalLocationService.confirm(id);</span><br><span class="line">        return RestResponse.success(&quot;确认成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="官方推荐"><a href="#官方推荐" class="headerlink" title="官方推荐"></a>官方推荐</h2><p>按照官方的说法我吗应该这样修改，去掉<code>@Autowired</code>，给属性添加<code>final</code>修饰符，创建构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/terminalLocation&quot;)</span><br><span class="line">public class TerminalLocationController &#123;</span><br><span class="line">    </span><br><span class="line">    private final TerminalLocationService terminalLocationService;</span><br><span class="line"></span><br><span class="line">    public TerminalLocationController(TerminalLocationService terminalLocationService) &#123;</span><br><span class="line">        this.terminalLocationService = terminalLocationService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/confirm&quot;)</span><br><span class="line">    public RestResponse&lt;String&gt; confirm(@RequestParam(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        terminalLocationService.confirm(id);</span><br><span class="line">        return RestResponse.success(&quot;确认成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="AllArgsConstructor"></a>AllArgsConstructor</h2><p>但是这样写好麻烦啊，每次添加一个依赖都要修改构造函数。好在我们有<code>lombok</code>，只需要添加一个<code>@AllArgsConstructor</code>注解，就可以帮我们生成构造函数了，代码简化为这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/terminalLocation&quot;)</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class TerminalLocationController &#123;</span><br><span class="line"></span><br><span class="line">    private final TerminalLocationService terminalLocationService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/confirm&quot;)</span><br><span class="line">    public RestResponse&lt;String&gt; confirm(@RequestParam(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        terminalLocationService.confirm(id);</span><br><span class="line">        return RestResponse.success(&quot;确认成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="RequiredArgsConstructor"></a>RequiredArgsConstructor</h2><p>这样虽然解决了自定生成构造函数的问题，但是，<code>@AllArgsConstructor</code>会给把所有属性都加入到构造函数中。这样就会带来一个问题，如果我们有一个属性使用了<code>@Value</code>也会被构造函数的参数覆盖。<br>如何解决呢？<br>通常使用<code>@Value</code>的属性我们通常是可以修改的，因此不会加上<code>final</code>修饰符<br>我们只把加入了<code>final</code>修饰符的属性加入到构造函数中就可以了，这时候使用<code>@RequiredArgsConstructor</code>注解就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/terminalLocation&quot;)</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class TerminalLocationController &#123;</span><br><span class="line"></span><br><span class="line">    private final TerminalLocationService terminalLocationService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/confirm&quot;)</span><br><span class="line">    public RestResponse&lt;String&gt; confirm(@RequestParam(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        terminalLocationService.confirm(id);</span><br><span class="line">        return RestResponse.success(&quot;确认成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完美方案是，在类上使用<code>@RequiredArgsConstructor</code>注解，属性去掉<code>@Autowired</code>注解，添加<code>final</code>修饰符。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>10.克隆远程仓库</title>
    <url>/2020/04/22/git/10.%E5%85%8B%E9%9A%86%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="小白的故事"><a href="#小白的故事" class="headerlink" title="小白的故事"></a>小白的故事</h2><blockquote>
<p>本故事纯属虚构，如有雷同，^0^那可太巧了</p>
</blockquote>
<p>吃过早饭，早早来到办公室。今天办公室和往常好像不一样。小白的工位旁边坐了个人。好面生啊。</p>
<p>“你好”，小白主动上前打招呼。<br>“你好，我是新来的。老大说让我跟你一组，以后我就跟你混了。”，新同事回答<br>“我叫小白，你叫什么啊？”，小白问道<br>“我叫小菜” 新同事回答<br>…<br>小白和小菜聊得很投缘。<br>上班时间到了，第一件事就是带领小菜熟悉项目。<br>“这是我u盘，把项目拷贝给我一份吧，我熟悉一下项目”，小菜说道，把u盘递给了小白</p>
<p>“不需要拷贝，现在都用git了，直接用git clone一份就可以了”，小白说着把u盘还给小菜</p>
<p>“这样啊，好高端”，小菜呵呵一笑</p>
<span id="more"></span>

<p>小白做到小菜的电脑前，打开git bash工具敲下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/shooke/learngit.git</span><br></pre></td></tr></table></figure>

<p>一会电脑上出现了 learngit的文件夹。</p>
<p>“这样项目就下来了”小白说道，心里美滋滋的。</p>
<p>小菜一脸崇拜的看着小白。</p>
<p>“这是我的学习笔记，你也好好学习一下git吧。”小白发给小菜一个文档。</p>
<p>就这样两人开始了组团升级的道路</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code> git clone &lt;版本库的网址&gt;</code> 可以克隆项目到本地，生成一个与项目同名的文件夹，版本库网址可以是https也可以是ssh类型的，这取决于服务器支持那种协议</li>
<li><code>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code> 如果想保存的时候换一个名字，可以在版本库地址后面增加一个目录名如<code>git clone https://github.com/shooke/learngit.git git_learn</code></li>
<li>git可以支持多种协议，比如下面的协议<ul>
<li>$ git clone http[s]:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</li>
<li>$ git clone ssh:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</li>
<li>$ git clone git:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</li>
<li>$ git clone &#x2F;opt&#x2F;git&#x2F;project.git </li>
<li>$ git clone file:&#x2F;&#x2F;&#x2F;opt&#x2F;git&#x2F;project.git</li>
<li>$ git clone ftp[s]:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</li>
<li>$ git clone rsync:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>1.啥是git</title>
    <url>/2019/12/18/git/1.%E5%95%A5%E6%98%AFgit/</url>
    <content><![CDATA[<p>事情要从linux说起，git的作者就是linux之父linus。在2002年以前，都是通过手工比较代码的方式来合并社区反馈的代码，进行合并。但随着linux项目越来月庞大。手工合并变得不现实了。当时市面上也有cvs或svn这样的版本控制软件。但linus反对使用这些集中式的版本控制系统，因为它们都必须联网才可以使用，而且速度比较慢。<br>有一些好用的速度快的系统，不过都是需要付费的，这与linux的开源精神不符。<br>2002年之前，由于没有合适的版本控制系统，linus都是通过手工diff去比较合并代码的。这时的工作太过繁重。<br>2002年的时候BitMover公司，将BitKeeper授权linux社区免费使用。人多的地方就有江湖，江湖中从来不乏高手，特别是linux社区。2005年，社区中有一些人将BitKeeper破解了。这可是人家BitMover公司吃饭的家伙啊，你破解了人家当然不愿意了。于是BitMover公司怒了，收回了免费使用权。<br>linus一看也不乐意啊。你不让我用那我就自己写一个呗。于是linus用了2周的时间，自己写了一个分布式的版本控制系统(牛人的世界就是这么牛X)。也就是git。很快(有多快呢，一个月左右)linux系统就全部由git管理了。<br>后来的事情大家都知道了。2008年github上线，让git走进了千家万户，是个知道开源的都知道github。知道github还不知道git(就相当于吃了猪肉，没见过猪跑一样)，那是不可能的。</p>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>2.把项目交给git</title>
    <url>/2019/12/19/git/2.%E6%8A%8A%E9%A1%B9%E7%9B%AE%E4%BA%A4%E7%BB%99git/</url>
    <content><![CDATA[<h2 id="小白的故事"><a href="#小白的故事" class="headerlink" title="小白的故事"></a>小白的故事</h2><blockquote>
<p>本故事纯属虚构，如有雷同，^0^那可太巧了</p>
</blockquote>
<p>小白接到上级指示，所有的项目代码都要用版本管理工具进行管理。本着对项目负责的态度，小白开始在网上搜索版本管理软件。<br>考察了svn和git后，最后决定使用git进行项目管理。</p>
<p>对于刚刚不如程序猿行列的小白来说，git好神秘啊，linus大神好神秘啊。</p>
<p>沐浴更衣，斋戒数天。开始使用git。</p>
<p>使用git的第一步当然是安装了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install git</span><br></pre></td></tr></table></figure>
<p>ok,搞定，这样就安装完了。</p>
<p>打开项目目录，输入神圣的git初始化命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /home/shooke/learngit/.git/</span><br></pre></td></tr></table></figure>
<p>完成了？这么简单？没有报错？小白小激动了一下，git初始化就这么简单？检查一下便知道。查看了一下，项目下果然多了个<code>.git</code>文件夹。</p>
<p>接下来我们把项目加入到git代码仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;init&quot;</span><br></pre></td></tr></table></figure>
<p>这样，文件就被git记录下来了。就是这么easy。</p>
<p>不一会小白写好了一个新功能，然后<code>git add .</code> <code>git commit -m &quot;我有完成了一个牛X的功能&quot;</code>记录下自己的工作。好开心，原来git这么简单，每次做完功能先 <code>add</code>然后<code>commit</code>就好了。</p>
<p>就这样小白开始了他的git之旅…</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>git init</code>可以初始化项目<br><code>git add .</code>可以将文件加入到暂存区，<code>.</code>是当前目录的意思，可以将目录下所有文件进行暂存，如果要针对某个文件可以加上文件名如<code>git add readme.md</code><br><code>git commit -m &quot;init&quot;</code>将文件加入到git代码仓库，并生成一条<code>init</code>的log记录</p>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>5.对比文件变化</title>
    <url>/2019/12/22/git/5.%E5%AF%B9%E6%AF%94%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="小白的故事"><a href="#小白的故事" class="headerlink" title="小白的故事"></a>小白的故事</h2><blockquote>
<p>本故事纯属虚构，如有雷同，^0^那可太巧了</p>
</blockquote>
<p>了解了工作去和版本库的区别，小白开始自己开动脑筋举一反三。既然<code>git status</code>可以查看哪些文件发生的变化。那能不能知道具体的变化是什么呢。</p>
<p>毕竟作为一个程序猿，临时被唐僧召唤的事情经常发生。小白正在思考着，产品经理就喊上了。有个新需求需要确认排期。小白只好怪怪的跑过去。<br>确认完排期，回到座位上，继续开发今天的功能。<code>add</code> <code>commit</code>已经熟练的飞起。貌似git也很简单嘛。</p>
<p>中午到了，开饭。吃过午饭回到坐位的小白发现电脑关机了。据说是某个不知名的家伙不小心提到了插座。<br>好吧，重新开机就好了，打开自己熟悉的ide，一切如常。上午的功能还没有commit，看下改过哪些文件吧。<code>git status</code>发现改了十几个文件。<br>好多都已经记不清改的什么了，肿木办？先把自己记忆清除的几个add。然后commit。剩下几个实在想不起来改过什么了。ide也没法回退了，这该如何是好啊。</p>
<p>正在小白苦恼的时候，老鸟过来了。<br>看着发呆的小白，老鸟关系的问“小猴子，今天怎么发呆了？”。<br>小白如实回答“有几个文件忘记改过什么地方了，电脑关过机，ide也没法撤销操作了”。<br>老鸟熟练的敲下了<code>git diff package.json</code>,这时候所有的改动一目了然的展现在了小白面前。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff package.json</span><br><span class="line">diff --git a/package.json b/package.json</span><br><span class="line">index 00570c9..f06efde 100755</span><br><span class="line">--- a/package.json</span><br><span class="line">+++ b/package.json</span><br><span class="line">@@ -16,7 +16,6 @@</span><br><span class="line">     &quot;@vue/cli-plugin-eslint&quot;: &quot;^4.1.0&quot;,</span><br><span class="line">     &quot;@vue/cli-service&quot;: &quot;^4.1.0&quot;,</span><br><span class="line">     &quot;babel-eslint&quot;: &quot;^10.0.3&quot;,</span><br><span class="line">-    &quot;eslint&quot;: &quot;^5.16.0&quot;,</span><br><span class="line">     &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">     &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">@@ -27,7 +26,7 @@</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;extends&quot;: [</span><br><span class="line">       &quot;plugin:vue/essential&quot;,</span><br><span class="line">-      &quot;eslint:recommended&quot;</span><br><span class="line">+      &quot;eslint:recommendeddd&quot;</span><br><span class="line">     ],</span><br><span class="line">     &quot;rules&quot;: &#123;</span><br><span class="line">       &quot;no-console&quot;: &quot;off&quot;</span><br></pre></td></tr></table></figure>
<p>还不待老鸟解释，小白已经明白减号<code>-</code>代表的是自己删除的行<code>+</code>是产生的新行。</p>
<p>这下好了，可以看出自己修改过的细节，就可以很清楚的解决问题了。</p>
<p>看着小白激动的目光，老鸟挥一挥衣袖，不带走一点代码。飘然而去。</p>
<p>望着老鸟离去的背影，小白激动的追上去，语出惊人“大神，留步！”</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>git diff --filename</code> 可以比较文件的变更情况。</p>
<ul>
<li>如果文件<code>git add</code>过，会显示工作区和暂存区的差别。</li>
<li>如果没有<code>git add</code>过，会显示工作区和仓库历史版本的差异。</li>
</ul>
<p><code>git diff --cached [file]</code> 显示暂存区和上一个commit的差异</p>
<p><code>git diff HEAD</code> 显示工作区与当前分支最新commit之间的差异</p>
<p><code>git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</code> 显示今天你写了多少行代码</p>
<p>关于工作区和版本库的介绍，可以看上一篇《4.工作区和版本库》</p>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>3.查看文件状态</title>
    <url>/2019/12/20/git/3.%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="小白的故事"><a href="#小白的故事" class="headerlink" title="小白的故事"></a>小白的故事</h2><blockquote>
<p>本故事纯属虚构，如有雷同，^0^那可太巧了</p>
</blockquote>
<p>第二天上班，小白开开心心的打开电脑，准备爽一把。忽然想起来，昨天好像有一个功能还没有做完，临走的时候没有执行<code>add</code>和<code>commit</code>。</p>
<p>糟糕好像忘记修改过哪几个文件了。这可如何是好啊？</p>
<p>一盏灯泡从小白的脑袋里亮起，好像我开始使用git了，git应该知道我昨天哪些代码没有<code>commit</code>吧。<br>小白打开百度，果然，git是可以查看文件状态的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>modified:   readme.md</code>，哦，原来是<code>readme.md</code>文件昨天修改过。马上<code>git add readme.md</code> <code>git commit -m &quot;readme&quot;</code>添加到仓库。</p>
<p>ok，继续快乐的工作。</p>
<p>开始开发新功能，创建一个新文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch 我最帅.txt</span><br></pre></td></tr></table></figure>
<p>不一会功能开发完成。脑袋好乱，刚才出去又忘记改了什么文件。还是用<code>git status</code>吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	&quot;\346\210\221\346\234\200\345\270\205.txt&quot;</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<p><code>&quot;\346\210\221\346\234\200\345\270\205.txt&quot;</code>是什么鬼，我们打开万能的百度，是因为git对对0x80以上的字符进行quote，解决方法很简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure>
<p>没有报错，应该没有问题吧，小白抱着试试看的态度敲下了<code>git status</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	我最帅.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>果然正常了。小白那个开心啊。内心YY道：“我就说吗git这么强大，怎么可能弱鸡到中文都不能正常显示，我果然是天才，一下就找到了原因”</p>
<p>马上开始保存到仓库，咦，不对，好像两次<code>git status</code>出现的提示不一样，这是怎么回事啊。</p>
<p>时间在小白的思考中慢慢流失，抬头一看，哇，这不8点60了吗。赶紧回家…</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>git status</code>可以查看项目的变更情况<br><code>git config --global core.quotepath false</code> 可以解决，git提示信息中文乱码问题</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为什么小白两次<code>git status</code>出现的提示不一样呢？这就要从git的管理机制，工作区和代码库说起了</p>
<p>预知后事如何，且看下回分解。</p>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>4.啥事工作区、暂存区和版本库</title>
    <url>/2019/12/21/git/4.%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E7%89%88%E6%9C%AC%E5%BA%93/</url>
    <content><![CDATA[<h2 id="小白的故事"><a href="#小白的故事" class="headerlink" title="小白的故事"></a>小白的故事</h2><blockquote>
<p>本故事纯属虚构，如有雷同，^0^那可太巧了</p>
</blockquote>
<p>回到家的小白，想着今天发生的事，为什么<code>git status</code>出来的提示信息不一样？为什么<code>git status</code>出来的提示信息不一样？为什么<code>git status</code>出来的提示信息不一样？<br>想着想着他就睡着了，梦里他遇到了linus大神，linus带他来到了一个神秘的机构。在这个房间里有2个人，还有一个大大的大屏幕。<br>每次大屏幕上显示<code>git add</code>，就会有一份文件到达一个人的手里，他会把信息进行整理。当大屏幕上显示<code>git commit</code>。第一个人就会把整理的内容放到第二个人的桌子上，然后回来继续工作。</p>
<p>小白疑惑的看向linus大神，大神和蔼的告诉他“小白，你不是一直奇怪，为什么<code>git status</code>出来的提示信息不一样？”，这就是你要的答案。</p>
<p>小白仔细打量着房间里的一切，第一个人的办公桌上有一个牌子，上面写着”stage”。<br>第二个人的办公桌上同样有一个牌子，上面写着”HEAD”。</p>
<p>小明若有所思，抬起头的时候，发现linus大神已经不见了。他冲出房门，发现街上根本没有大神的踪影，只有房子上高高挂起的牌匾写着”版本库”三个打字。</p>
<p>他大声的呼喊，这时耳边传来“叮铃铃叮铃铃”的响声。</p>
<p>小明从梦中醒来一看，哇，还有半小时就八点60了，飞快起身，背上背包冲向公司。</p>
<p>距离上班还有1秒钟的时候，小白打卡成功。</p>
<p>打开电脑，想起昨天遇到的情形，好像自己明白了什么，到网上一查，原来如此。</p>
<blockquote>
<p>git是分为工作区和版本库的。代码发生更改后，执行<code>git add</code>代码会放到代码库的暂存区(stage),当执行<code>git commit</code>时代码会形成版本记录(HEAD)，并且删除暂存取的记录。</p>
</blockquote>
<p>当我们执行<code>git status</code>时，git会将工作区（当前的代码）与暂存区的记录进行比较，如果暂存区没有记录，则会跟做过记录的版本作比较。从而提示你哪个文件发生过修改。</p>
<p>明白了这些，小白开始反思昨天看到的提示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	我最帅.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p><code>Untracked files</code>列出的是新建的文件，还没有被add和commit过，所以提示你<code>(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</code>，这表示需要进行<code>git add</code>操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p><code>Changes not staged for commit</code>列出被修改的文件，这时候文件还没有被add和commit。这时就是比较工作区和HEAD得出的结果。<code>modified:   readme.md</code>意思是这个文件发生了更改。</p>
<p>了解了不同提示的原因，小白果断<code>git add</code> <code>git commit</code>开始开发新功能。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>git是分为工作区和版本库的。代码发生更改后，执行<code>git add</code>代码会放到代码库的暂存区(stage),当执行<code>git commit</code>时代码会形成版本记录(HEAD)，并且删除暂存取的记录。工作区可以简单理解为项目目录，每次项目更改都会记录，这些变更记录就是版本库。</p>
<p>下面是各种状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line"># 已经执行过`git add`但没有执行`git commit`</span><br><span class="line">Changes to be committed:</span><br><span class="line">  # 可执行的命令，reset会移除暂存区记录，移除后需要重新进行add</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	renamed:    我最帅.txt -&gt; wo.txt</span><br><span class="line"></span><br><span class="line"># 文件发生修改时提示</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  # 可以执行的命令，文件修改是可以执行add加入到暂存区，也可以checkout进行撤销</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.md</span><br><span class="line"></span><br><span class="line"># 新增文件时提示</span><br><span class="line">Untracked files:</span><br><span class="line">  # 可以执行的命令，新增文件只要add到</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	我很帅.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>6.撤销操作</title>
    <url>/2019/12/23/git/6.%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h2 id="小白的故事"><a href="#小白的故事" class="headerlink" title="小白的故事"></a>小白的故事</h2><blockquote>
<p>本故事纯属虚构，如有雷同，^0^那可太巧了</p>
</blockquote>
<p>”大神！你是再叫我吗“，老鸟回过头问小白。<br>“是啊大神，虽然git diff很牛，可以让我知道改过什么，但我一点点的改回去好麻烦啊，有没有别的办法？”</p>
<p>大神，老鸟暗喜。这个大神的称号还是很少用的。老鸟摆出一副高深莫测的表情。<br>“办法当然有，既然你问了，就告诉你吧”</p>
<p>老鸟回到小白的工位入座。拿过键盘，开始实战时光回退大法，输入 <code>git checkout package.json</code>。施展至于本着经验精神不忘问一句，“你确定这些修改不要了？”<br>“恩恩，前面的思路有问题，我想到了一个更好的办法，所以还原吧。”小白虚心的说道。<br>只见老鸟手起指落，敲击在回车上。</p>
<p>再次查看文件，package.json文件真的恢复了。小白满眼崇拜的目光看向老鸟。<br>看到小白的表情，老鸟还是非常受用的。</p>
<p>“既然你这么好学，老夫就再教你一招，包你从此不会写错代码。”老鸟说道<br>“恩恩，大神请将”小白谦虚道。</p>
<p>“这个git呢要活学活用，你已经知道git分为工作区，暂存区和仓库了吧？”老鸟说道<br>“恩恩”小白道</p>
<p>“git diff的功能你也了解了吧”，老鸟继续说<br>“恩恩”小白点头道</p>
<p>“其实工作区，暂存区和仓库的概念是贯彻始终的，git checkout 也适用”，老鸟继续说<br>“大神的意思是说，如果我对package.json进行了 git add操作，checkout的时候就会回到add时候的代码，如果没有add过，就会回到上一次commit时候的代码？”。小白问道</p>
<p>“恩，不错悟性很好啊，记住一点，开发一个功能要常add，完成后在用commit收尾。这样在开发过程中出错，可以及时撤销，也可以减少不必要的commit历史”。老鸟提醒小白。<br>“恩恩，谢谢大神”，小白真诚的向老鸟道谢</p>
<p>一口一个大神，叫的老鸟飘飘然。老鸟也是非常的开心。临走不忘说一句“遇到问题尽管找我”</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>git checkout --filename</code> 可以撤销文件的变更。</p>
<ul>
<li>如果文件<code>git add</code>过，会撤回到add时的代码，即暂存区代码。</li>
<li>如果没有<code>git add</code>过，会撤回到上次commit时的代码，也就是版本库中，最近的版本。</li>
</ul>
<p>关于工作区和版本库的介绍，可以看上一篇《4.工作区和版本库》</p>
<p>如果一个功能比较复杂，可以完成一小部分执行一次add，或者是commit，这样在后续开发中发现改错了东西，可以及时撤回。</p>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>1.docker基础概念</title>
    <url>/2020/03/03/docker/1-docker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a>docker介绍</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）。</p>
<p>社区办免费使用。企业版由公司支持，可在经过认证的操作系统和云提供商中使用，并可运行来自Docker Store的、经过认证的容器和插件。</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>学习docker之前，需要先了解一下docker的几个基本概念：</p>
<p>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。<br>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>仓库（Repository）：仓库可看着一个代码控制中心，用来保存镜像。</p>
<p>这是比较官方的解释，看起来比较绕口。咱们换种容易理解的方式。安装过系统的人都知道，安装系统需要iso文件。<br><code>镜像就好比iso文件，容器就好比咱们在虚拟机里安好的系统，仓库就好比你下载iso的网站。</code>上面有好多iso文件哦。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在mac和windows上有ui程序，可以从界面管理docker。在docker官方下载即可<a href="https://hub.docker.com/search?q=&type=edition&offering=community&sort=updated_at&order=desc%E3%80%82%E4%B8%8B%E9%9D%A2%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Blinux%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%82">https://hub.docker.com/search?q=&amp;type=edition&amp;offering=community&amp;sort=updated_at&amp;order=desc。下面介绍一下linux下的安装。</a><br>我用的是deepin，所以就以ubuntu的按装为例</p>
<ol>
<li><p>删除老版本（如果你以前安装过docker的话）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装新版docker</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 更新数据源</span><br><span class="line">sudo apt-get update</span><br><span class="line"># 安装apt插件</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line"># 安装GPG key</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"># 验证指纹秘钥</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line"># 增加apt源</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br><span class="line"># 开始安装</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>安装完成后可以运行<code>sudo docker run hello-world</code>验证是否安装成功</p>
<h2 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h2><p>学习任何软件都要会看官方文档和帮助信息，docker也不例外。获取命令帮助信息可以在命令后面添加<code>--help</code>如<code>docker pull --help</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a> 其他系统的安装也可以在这里找到</p>
]]></content>
      <categories>
        <category>一点一点了解docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>8.再遇工作区和版本库</title>
    <url>/2019/12/25/git/8.%E5%86%8D%E9%81%87%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E7%89%88%E6%9C%AC%E5%BA%93/</url>
    <content><![CDATA[<h2 id="小白的故事"><a href="#小白的故事" class="headerlink" title="小白的故事"></a>小白的故事</h2><blockquote>
<p>本故事纯属虚构，如有雷同，^0^那可太巧了</p>
</blockquote>
<p>”大神我看你用使用<code>git reset</code>时使用了<code>--hard</code>参数，是不是还有其他参数啊。“小白虚心问道<br>”小伙很细心啊，不错，还有其余的2个参数，我挨个给你讲吧。刚才用过–hard，咱们从他讲起。咱们先创建个文件，加两条commit，方便讲解“老鸟说到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;1&quot;&gt; test.txt</span><br><span class="line">$ git add test.txt</span><br><span class="line">$ git commit -m &quot;1&quot;</span><br><span class="line">$ echo &quot;2&quot;&gt; test.txt</span><br><span class="line">$ git add test.txt</span><br><span class="line">$ git commit -m &quot;2&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>“咱们创建了2条commit记录了，第一条记录<code>test.txt</code>里的内容是<code>1</code>，第二条记录<code>test.txt</code>里的内容是<code>2</code>。先看一下记录” 老鸟说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit a609df431578e5061b5d0261bfa38cb0fa01efb1 (HEAD -&gt; master)</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Wed Mar 18 16:42:11 2020 +0800</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">commit b5a6d3a6c4d4f5899645f9469f116b050c9426b5</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Wed Mar 18 16:41:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br></pre></td></tr></table></figure>
<p>“接下来，咱们撤销一下看看效果”老鸟继续教导小白</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at b5a6d3a 1</span><br><span class="line">git log</span><br><span class="line">commit b5a6d3a6c4d4f5899645f9469f116b050c9426b5 (HEAD -&gt; master)</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Wed Mar 18 16:41:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>”现在历史被撤回了，咱们看git的状态“ 老鸟说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>”你看工作区和暂存区都是空的对吧“老鸟说<br>”恩恩，文件内容应该变成1了“小白说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>“回答正确，咱们先把历史还原，然后再来试试另一个参数”老鸟说。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard a609df431578e5061b5d0261bfa38cb0fa01efb1</span><br><span class="line">HEAD is now at a609df4 2</span><br><span class="line">$ git log</span><br><span class="line">commit a609df431578e5061b5d0261bfa38cb0fa01efb1 (HEAD -&gt; master)</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Wed Mar 18 16:42:11 2020 +0800</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">commit b5a6d3a6c4d4f5899645f9469f116b050c9426b5</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Wed Mar 18 16:41:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>“接下来试试<code>--mixed</code>,看看会是什么效果”老鸟说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --mixed HEAD^</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	test.txt</span><br><span class="line">$ git log</span><br><span class="line">commit b5a6d3a6c4d4f5899645f9469f116b050c9426b5 (HEAD -&gt; master)</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Wed Mar 18 16:41:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br></pre></td></tr></table></figure>
<p>“历史回退了”小白说<br>“恩，咱们看看文件状态有什么变化”老鸟说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>“这是什么意思啊，这个提示不是文件发生修改的时候才有的吗”，小白疑惑<br>“看一下文件内容你就明白了”老鸟说到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat test.txt </span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>”知道什么愿意你了吗“老鸟说<br>”哦，我明白了，历史回退了，按说文件的内容应该是1，但是现在内容是2，所以git以为文件发生了修改“小白说道。<br>”恭喜你答对了，<code>--mixed</code>参数会清空stage缓存区，但是不会直接修改文件的内容，如果需要将文件内容撤回，可以在执行<code>git checkout &lt;file&gt;</code>“老鸟解释道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout test.txt</span><br><span class="line">$ cat test.txt</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>”你看内容变了吧，接下来你猜一下<code>--soft</code>参数会是什么效果“老鸟说<br>”既然<code>--hard</code>文件工作区和缓存去都清空了，<code>--mixed</code>把缓存区清空了，那<code>--soft</code>是不是会保留缓存区啊“小白说道<br>”不错嘛，这都分析到了，没错，<code>--soft</code>参数只是撤销了记录，缓存区和工作区都不做修改，咱们来看下效果“。老鸟说，”先恢复一下记录方便看效果“</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard a609df431578e5061b5d0261bfa38cb0fa01efb1</span><br><span class="line">HEAD is now at a609df4 2</span><br><span class="line">$ git log</span><br><span class="line">commit a609df431578e5061b5d0261bfa38cb0fa01efb1 (HEAD -&gt; master)</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Wed Mar 18 16:42:11 2020 +0800</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">commit b5a6d3a6c4d4f5899645f9469f116b050c9426b5</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Wed Mar 18 16:41:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>”历史回来了，咱们开始看下<code>--soft</code>的作用“老鸟敲下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   test.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>”你看，是不是和你想的一样啊，要想清理缓存区可以按提示执行<code>git reset HEAD &lt;file&gt;</code>，剩下的就不用我说了吧“老鸟说道<br>”恩恩，明白，文件线下的内容应该还是2吧，我清理完缓存区，然后<code>git checkout &lt;file&gt;</code>文件内容就会变回commit对应的内容，对吧“小白问道</p>
<p>”没错，那你知道为什么会有这三种不同的参数吗“老鸟问<br>”不明白，<code>--hard</code>很方便啊，其他两种还要做其他操作才能回复文件内容，多麻烦。“小白回答</p>
<p>”你现在只是一个文件，如果你的一个历史记录有很多文件怎么办，如果你只需要撤回其中一个文件呢，用<code>--hard</code>不是自杀吗。使用<code>--mixed</code>或<code>--soft</code>可以保证文件内容不撤销，这样你就可以用<code>git checkout</code>针对你需要撤销的文件进行撤回。多方便 “老鸟说道<br>”哦，明白了，谢谢大神“小白激动的说</p>
<p>”走了，有问题随时问我“，老鸟再次潇洒离去，留下了激动的小白</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>--hard</code> 撤销commit记录，清空tage暂存区，清空工作区内容，文件内容彻底还原</li>
<li><code>--mixed</code> 撤销commit记录，清空tage暂存区，保留工作区内容，执行<code>git checkout &lt;file&gt;</code>可撤销修改，让文件内容还原</li>
<li><code>--soft</code> 撤销commit记录，保留stage暂存区，保留工作区内容，如果要撤回需要先执行<code>git reset HEAD &lt;file&gt;</code>撤销暂存区，然后执行<code>git checkout &lt;file&gt;</code> 撤销修改</li>
</ul>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>9.上传到远程仓库</title>
    <url>/2019/12/26/git/9.%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="小白的故事"><a href="#小白的故事" class="headerlink" title="小白的故事"></a>小白的故事</h2><blockquote>
<p>本故事纯属虚构，如有雷同，^0^那可太巧了</p>
</blockquote>
<p>这几天以来，小白学会了很多git的使用技巧。让他在应对问题的时候可以比较从容。比如需求反复修改。处理一些临时功能，后期要删除等比较繁琐的事情。</p>
<p>今天是小白负责的第一个项目发布的日子。</p>
<p>BOSS让小白把代码提交到远程仓库，这样负责发布的小伙伴就可以将代码进行发布了。</p>
<p>小白询问了老鸟如何将代码上传到github。回来开始操作。</p>
<ol>
<li>创建线上仓库</li>
</ol>
<p>进入github.com登录自己的账号，点击右上角的加号，选择<code>new repository</code></p>
<p><img src="/assets/images/posts/git_book/9-1.png" alt="new repository"></p>
<p>填写仓库名称然后点击绿色的<code>cteate repository</code>按钮</p>
<p><img src="/assets/images/posts/git_book/9-2.png" alt="create repository"></p>
<p>创建成功会有如下提示</p>
<p><img src="/assets/images/posts/git_book/9-3.png" alt="repository"></p>
<p>这时候说明已经创建成功了。这里会显示项目的远程地址，同时介绍了两种使用情况</p>
<ul>
<li>没有项目时可以先创建一个目录，进行<code>git init</code>初始化，然后用<code>git remote add</code>进行关联</li>
<li>如果已经有了本地项目直接使用<code>git remote add</code>进行关联</li>
</ul>
<p>小白一看我属于第二种情况。果断进入项目目录执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://github.com/shooke/learngit.git</span><br><span class="line">$ git push -u origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提示让<code>Username for &#39;https://github.com&#39;:</code>让输入git账号，小白果断输入，然后回车<br>再次提示<code>Password for &#39;https://xiaobai@163.com@github.com&#39;:</code>这里让输入密码</p>
<p>“奇怪怎么没有显示<code>*</code>啊”小白疑惑，这时候正好老鸟走过来<br>“BOSS让你上传代码，搞定了吗”，老鸟说<br>“就差一步了，为啥没法输入密码啊”小白问<br>“傻子，git命令行工具跟windows的cmd不一样的，这里是不会有星号提示的，但其实你的密码已经输入了，不行你可以试试”老鸟回答</p>
<p>小白重新输入密码，回车。出现了以下提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Counting objects: 26, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (22/22), done.</span><br><span class="line">Writing objects: 100% (26/26), 4.36 KiB | 4.36 MiB/s, done.</span><br><span class="line">Total 26 (delta 7), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (7/7), done.</span><br><span class="line">To https://github.com/shooke/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>“出现<code>[new branch]      master -&gt; master</code>是不是就表示上传成功了”小白问<br>“对啊，这个提示代表你本地的master分支，上传到了远程的master分支”老鸟回答</p>
<p>“啥事分支啊” 小白好奇的问<br>“分支啊，这可是好东西，多人协作全靠它了，我还有事明天给你讲” 老鸟回去忙自己的事了</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>git remote add [shortname] [url]</code>可以让本地仓库和远程仓库建立联系。<code>shortname</code>是仓库名称，方便执行命令时使用，一般情况下都用<code>origin</code>；<code>url</code>就是远程仓库的地址，比如上面例子中的<code>https://github.com/shooke/learngit.git</code></li>
<li><code>git remote -v</code> 显示所有远程仓库</li>
<li><code>git remote show [remote]</code> 显示某个远程仓库的信息</li>
</ul>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>7.时光倒流</title>
    <url>/2019/12/24/git/7.%E6%97%B6%E7%A9%BA%E7%A9%BF%E6%A2%AD/</url>
    <content><![CDATA[<h2 id="小白的故事"><a href="#小白的故事" class="headerlink" title="小白的故事"></a>小白的故事</h2><blockquote>
<p>本故事纯属虚构，如有雷同，^0^那可太巧了</p>
</blockquote>
<p>小白正在开心的写代码，刚刚完成了产品小伙伴的一个需求。还是小有成就感的，正准备起来活动活动喝杯水。谁知产品小伙伴有风风火火的跑过来。<br>“小白，小白，客户还是感觉以前的交互方式用着顺手。让把功能改回去”。产品小伙伴喊道。<br>听到这个消息，小白满脸的黑线。废了半天劲做出来的功能再改回去。这太坑了吧。<br>但是没办法，谁叫客户就是上帝呢，改吧。<br>开始撤销，<code>ctrl z</code>。。。<br>what，没法撤销了？编辑器撤销的步骤有限，这可如何是好啊，难道要手动改代码？这也太悲剧了吧。<br>“对了找大神问一下，看git有没有办法回退”小白灵光一闪想起来老鸟。</p>
<p>老鸟一听到小白喊他“大神”，瞬间心情舒畅跑过来知道小白。</p>
<p>“你是要回退以前的版本吗？”老鸟问道。<br>“恩恩”小白点头<br>“回退其实很简单，看我操作，要记住啊”说完，做到小白的坐位上开始了他的神操作。</p>
<p>“首先用<code>git log</code>看一下你的提交记录”，老鸟说道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line"></span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Sat Mar 14 16:45:03 2020 +0800</span><br><span class="line"></span><br><span class="line">    &lt;E7&gt;&lt;8A&gt;&lt;B6&gt;&lt;E6&gt;&lt;80&gt;&lt;81&gt;&lt;E4&gt;&lt;BF&gt;&lt;AE&gt;&lt;E6&gt;&lt;94&gt;&lt;B9&gt;&lt;E5&gt;&lt;92&gt;&lt;8C&gt;&lt;E5&gt;&lt;AF&gt;&lt;B9&gt;&lt;E6&gt;&lt;AF&gt;&lt;94&gt;&lt;E6&gt;&lt;97&gt;&lt;B6&gt;&lt;E9&gt;&lt;97&gt;&lt;B4&gt;</span><br><span class="line"></span><br><span class="line">commit 3e14b6822063c7add663cd79756e77818e821819</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Sat Mar 14 00:30:27 2020 +0800</span><br><span class="line"></span><br><span class="line">    &lt;E5&gt;&lt;AE&gt;&lt;A1&gt;&lt;E6&gt;&lt;A0&gt;&lt;B8&gt;&lt;E7&gt;&lt;8A&gt;&lt;B6&gt;&lt;E6&gt;&lt;80&gt;&lt;81&gt;&lt;E4&gt;&lt;BF&gt;&lt;AE&gt;&lt;E6&gt;&lt;94&gt;&lt;B9&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>“咦，你这里git log居然乱码啊”，老鸟说道<br>“这是咋回事啊”，小白疑惑<br>“好办，编码问题解决一下就可以了”。老鸟输入了如下三条命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line"></span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br><span class="line"></span><br><span class="line">export LESSCHARSET=utf-8 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再次执行<code>git log</code>果然好了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">commit 6531ff6013dd490f60bcd646ca01df61a1ecc8b1 (HEAD -&gt; dev, origin/master, origin/dev, origin/HEAD, master)</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Sat Mar 14 16:45:03 2020 +0800</span><br><span class="line"></span><br><span class="line">    状态修改和对比时间</span><br><span class="line"></span><br><span class="line">commit 3e14b6822063c7add663cd79756e77818e821819</span><br><span class="line">Author: shooke &lt;xingjiehu@163.com&gt;</span><br><span class="line">Date:   Sat Mar 14 00:30:27 2020 +0800</span><br><span class="line"></span><br><span class="line">    审核状态修改</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>“log记录有时候很多，你可以不停的按<code>j</code>和<code>k</code>来实现向下或向上查看内容，不行看了，就输入<code>:q</code>退出。就跟vim编辑器使用方式一样”老鸟说。</p>
<p>“想要退回到那里，用<code>git reset</code>会退到对应的commit id就可以了。比如会退到<code>审核状态修改</code>。老鸟边说变执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 3e14b6822063c</span><br></pre></td></tr></table></figure>
<p>打开编辑器，小白发现，代码真的回到以前了。</p>
<p>“大神，commit id怎么输入了一部分啊，不需要全部输入吗”，小白激动说道</p>
<p>“不需要，只要git能够确定唯一的commit就行了，一般也就输入前几位”，老鸟说。</p>
<p>“每次都要看commit id好麻烦啊，有没有简单的方法？”小白谦虚问道</p>
<p>“当然有啊，可以用HEAD加上<code>^</code>或者<code>～n</code>回退啊”。老鸟说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>“这样就会回退一条commit,如果退两条，就再加一个^，退几条就加几个^”老鸟说<br>”那退20条，岂不是20个^,多麻烦啊“，小白说<br>”孺子可教啊，这要用~n了，可以这样写“，老鸟说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~20</span><br></pre></td></tr></table></figure>
<p>“明白了，谢谢大神”小白说道。<br>”你刚才要回退到那条commit啊“老鸟问道<br>”啊，我只需要退一条就行了，咱们刚才退了这么多，怎么办啊“小白说</p>
<p>”这怕啥，你只要知道历史中的commit id，就不用担心，及时你回退了50条，要回到第二条也没问题“老鸟边说变敲下哦了命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 3e14b6822063c7add663cd79756e77818e821819</span><br></pre></td></tr></table></figure>
<p>”你看这不是回到你第二条命令时的状态了吗，只要你记得回退前的commit id，随时可以穿梭到任何commit“老鸟说道。</p>
<p>小白豁然开朗，原来历史是可以任意切换的，并不是回退了就抹除了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>解决乱码<br><code>git config --global i18n.commitencoding utf-8</code>  该命令表示提交命令的时候使用utf-8编码集提交</li>
</ol>
<p><code>git config --global i18n.logoutputencoding utf-8</code> 该命令表示日志输出时使用utf-8编码集显示</p>
<p><code>export LESSCHARSET=utf-8</code> 设置LESS字符集为utf-8，为了让配置一直有效，可以把这个设置添加到<code>~/.bashrc</code>,然后执行<code>source ~/.bashrc</code></p>
<ol start="2">
<li><p>查看历史<br><code>git log</code>可以查看历史。但是如果用<code>git reset</code>回退了，是看不到被退回的历史的，如果要保证历史，可以使用<code>git revert</code>，后面会讲这个命令<br><code>git log --stat</code> 显示commit历史，以及每次commit发生变更的文件<br><code>git log -S [keyword]</code> 搜索提交历史，根据关键词<br><code>git log [tag] HEAD --pretty=format:%s</code> 显示某个commit之后的所有变动，每个commit占据一行<br><code>git log [tag] HEAD --grep feature</code> 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件<br><code>git log --follow [file]</code>或<code>git whatchanged [file]</code> 显示某个文件的版本历史，包括文件改名<br><code>git log -p [file]</code> 显示指定文件相关的每一次diff<br><code>git log -5 --pretty --oneline</code> 显示过去5次提交</p>
</li>
<li><p>历史切换<br><code>git reset HEAD^</code>可以向前撤销一次，多个<code>^</code>可以撤销多条历史，或者使用<code>git reset HEAD~5</code>这样可以一次撤销5条历史<br><code>git reset</code>可以任意切换到某个历史，使用<code>git reset --hard commitid</code>即可，commit id不一定要全的，可以只写前几位</p>
</li>
</ol>
]]></content>
      <categories>
        <category>一点一点了解git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>docker仓库(Repository)</title>
    <url>/2020/03/03/docker/2.docker%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>仓库(Repository)是docker的重要概念之一，它是集中存放镜像的地方。docker官方提供了镜像仓库  <a href="https://hub.docker.com/">Docker Hub</a>。<br>大多数情况下我们可以直接下载官方的镜像，直接使用或进行二次配置。</p>
<span id="more"></span>

<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>在 <a href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h2 id="登录和退出"><a href="#登录和退出" class="headerlink" title="登录和退出"></a>登录和退出</h2><p>执行<code>docker login</code>命令，会提示输入用户名和密码，输入后就登录了。注意，输入密码时不会有任何显示，windows上一般显示<code>*</code>,但linux不会有显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: shooke</span><br><span class="line">Password: </span><br></pre></td></tr></table></figure>
<p>执行<code>docker logout</code>就可以退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure>

<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>可以通过<code>docker search</code>命令查找官方仓库中的镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search ubuntu</span><br><span class="line">NAME                                                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">ubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   10575               [OK]                </span><br><span class="line">dorowu/ubuntu-desktop-lxde-vnc                            Docker image to provide HTML5 VNC interface …   398                                     [OK]</span><br><span class="line">rastasheep/ubuntu-sshd                                    Dockerized SSH service, built on top of offi…   243                                     [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>在仓库中找到自己想要的镜像后，就可以下载使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure>
<p>这样就可以从官方仓库下载<code>ubuntu:18.04</code>镜像到本地使用。<br>关于镜像的详细内容看《3.docker镜像》</p>
<p>#参考资料<br><a href="https://www.runoob.com/docker/docker-repository.html">https://www.runoob.com/docker/docker-repository.html</a></p>
]]></content>
      <categories>
        <category>一点一点了解docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker repository</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 配置</title>
    <url>/2020/06/12/springboot/springboot-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="application-properties配置中文乱码问题"><a href="#application-properties配置中文乱码问题" class="headerlink" title="application.properties配置中文乱码问题"></a>application.properties配置中文乱码问题</h2><p>删除现有的文件，设置idea。setting-&gt;editor-&gt;file encodings 将<code>Global Encoding</code> <code>Project Encoding</code> <code>Default encoding for properties files</code>都设置成<code>utf-8</code>.并且勾选<code>Transparent native-to-ascii conversion</code></p>
<h2 id="多配置时spring-profiles-active-dev不生效"><a href="#多配置时spring-profiles-active-dev不生效" class="headerlink" title="多配置时spring.profiles.active=dev不生效"></a>多配置时<code>spring.profiles.active=dev</code>不生效</h2><p>如果只有<code>application.properties</code>和<code>application-dev.properties</code>这两个文件，是不行的，需要在增加一个文件比如<code>application-prod.properties</code>。<br>只有配置文件多余2个才会生效</p>
<span id="more"></span>

<h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><p>application-dev.properties内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.dudu.name=&quot;张三&quot;</span><br><span class="line">com.dudu.want=&quot;跑步&quot;</span><br><span class="line">com.dudu.sex=&quot;男&quot;</span><br></pre></td></tr></table></figure>
<h3 id="直接使用配置"><a href="#直接使用配置" class="headerlink" title="直接使用配置"></a>直接使用配置</h3><p>在需要用到的地方使用,在属性上使用<code>@Value</code>注解就可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;com.dudu.name&#125;&quot;)</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure>
<h3 id="使用bean对象方式"><a href="#使用bean对象方式" class="headerlink" title="使用bean对象方式"></a>使用bean对象方式</h3><p>config&#x2F;ConfigBean.java 代码如下，值得注意的是<code>@Configuration</code>注解非常重要，如果没有这个注解是不生效的。<br>其实还有<code>@EnableConfigurationProperties</code>注解方式，但使用起来不如<code>@configuration</code>方便。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.springboot.config.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shooke</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix=&quot;com.dudu&quot;)</span><br><span class="line">public class ConfigBean &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String sex;</span><br><span class="line">    private String want;</span><br><span class="line"></span><br><span class="line">    public String getWant() &#123; return want;&#125;</span><br><span class="line"></span><br><span class="line">    public void setWant(String want) &#123; this.want = want;&#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要用到配置的地方，直接初始化一个ConfigBean的对象就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">ConfigBean conf;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/dev&quot;)</span><br><span class="line">public String dev()&#123;</span><br><span class="line">    return conf.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用自定义properties"><a href="#使用自定义properties" class="headerlink" title="使用自定义properties"></a>使用自定义properties</h2><p>有时候配置项太多了，咱们就拆分成不同的文件。拆分的文件使用需要用到<code>@PropertySource</code>注解，指定一下配置文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author shooke</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;com.md&quot;)</span><br><span class="line">@PropertySource(&quot;classpath:test.properties&quot;)</span><br><span class="line">public class ConfigTestBean &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String want;</span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getWant() &#123;</span><br><span class="line">        return want;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWant(String want) &#123;</span><br><span class="line">        this.want = want;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://gitee.com/shooke/springboot/tree/master/springboot-config">https://gitee.com/shooke/springboot/tree/master/springboot-config</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://tengj.top/2017/02/28/springboot2/">http://tengj.top/2017/02/28/springboot2/</a></p>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>spring boot 配置</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器(Container)</title>
    <url>/2020/03/03/docker/4.docker%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>容器就是独立运行起来的程序,一个容器就好比你在虚拟机里装好的一个系统。</p>
<p>我们可以创建、启动、停止、删除它。同时也可以将容器需要的数据放在容器之外。比如有一个数据库容器，里面有mysql服务，但数据不能放在容器里。我们可以把数据放在主机里，通过映射的方式让容器访问。</p>
<span id="more"></span>

<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>
<p>新建并启动容器使用<code>docker run</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run ubuntu:18.04 /bin/echo &#x27;Hello world&#x27;</span><br></pre></td></tr></table></figure>
<p>启动后会看到<code>Hello world</code>，本本地使用<code>echo &#39;hello world&#39; </code>没什么两样。但这个hello world是容器输出的。不是主机输出的。容器启动后自己就终止了，所以会误认为主机输出的。</p>
<blockquote>
<p>docker run命令会检查本地是否存在镜像，如果不存在，会自动到官方仓库下载。比如上面的<code>ubuntu:18.04</code></p>
</blockquote>
<p>在执行<code>docker run</code>命令时，可以添加<code>-t</code> <code>-i</code>参数，让容器不退出，保持交互。</p>
<blockquote>
<p>-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，<br>-i 则让容器的标准输入保持打开</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -t -i ubuntu:18.04 /bin/bash</span><br></pre></td></tr></table></figure>
<p>这样容器就不会退出了，你会发现shell中出现出现了<code>root@af8bae53bdd3:/</code>这样的提示，这说明你进入了容器，你所执行的命令都是在容器内运行。</p>
<p><code>root</code> 是容器的用户<br><code>af8bae53bdd3</code> 是容器的id，每个容器启动后后有一个容器id。我们反复启动一个容器，就靠它。</p>
<blockquote>
<p>如果在交互模式下，退出容器可以输入<code>exit</code>就退出来了。</p>
</blockquote>
<h2 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h2><p>就好比，咱们不能每次都在<code>virtualBox</code>里新装一个系统，我们只要运行安装过得系统。<br>当容器退出后，想再次启动已经创建过的容器。这时候可以采用<code>docker container start</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container start af8bae53bdd3</span><br></pre></td></tr></table></figure>
<p>这样就启动了上次生成的容器</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ol>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ol>
]]></content>
      <categories>
        <category>一点一点了解docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker Container</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像(Image)</title>
    <url>/2020/03/03/docker/3.docker%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>镜像在学习docker的过程中非常重要，创建出一个适用于自己的镜像，才能让业务系统准确运行。</p>
<span id="more"></span>

<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>拉取镜像使用<code>docker pull</code>命令，格式如下：</p>
<blockquote>
<p>docker pull [选项] [Docker Registry 地址[:端口号]&#x2F;]仓库名[:标签]</p>
</blockquote>
<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名&#x2F;IP&gt;[:端口号]。默认地址是 Docker Hub。</li>
<li>仓库名：<code>（叫镜像名更容易理解一些，毕竟pull下来在本地就是镜像）</code> 这里的仓库名是两段式名称，即 &lt;用户名&gt;&#x2F;&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为<code>library</code>，也就是官方镜像。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure>
<p>这样就从官方镜像仓库中拉取了<code>ubuntu 18.04</code>版本的镜像。本地生成的镜像名称是<code>ubuntu</code> tag是<code>18.04</code></p>
<h2 id="列出本地镜像列表"><a href="#列出本地镜像列表" class="headerlink" title="列出本地镜像列表"></a>列出本地镜像列表</h2><p><code>docker images</code>或<code>docker image ls</code>命令可以查看本地所有镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images          </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到本地所有镜像的列表，列表中有:仓库名(REPOSITORY)、标签(TAG)、镜像id(IMAGE ID)，创建时间(CREATED)，以及镜像大小(SIZE)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        12 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">training/webapp     latest              6fae60ef3446        11 months ago       348.8 MB</span><br></pre></td></tr></table></figure>

<h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p>有拉取就有推送，用户登录后可以通过<code>docker push</code>命令将自己的额镜像推送到<code>Docker Hub</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag ubuntu:18.04 username/ubuntu:18.04</span><br></pre></td></tr></table></figure>
<p>这样就把<code>ubuntu:18.04</code>推送到了<code>Docker Hub</code>上，自己的仓库空间下。其他人拉取的时候通过<code>username</code>来区分，就可以拉取你的镜像了。</p>
<h2 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h2><p>执行<code>docker run</code>命令就可以启动本地镜像，生成容器了。详细内容看《4.docker容器》</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/docker/docker-image-usage.html">https://www.runoob.com/docker/docker-image-usage.html</a><br><a href="https://yeasy.gitbooks.io/docker_practice/content/image/pull.html">https://yeasy.gitbooks.io/docker_practice/content/image/pull.html</a><br><a href="https://yeasy.gitbooks.io/docker_practice/content/image/list.html">https://yeasy.gitbooks.io/docker_practice/content/image/list.html</a></p>
]]></content>
      <categories>
        <category>一点一点了解docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker image</tag>
      </tags>
  </entry>
</search>
